<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NodaTime</name>
    </assembly>
    <members>
        <member name="T:NodaTime.Offset">
            <summary>
              An offset from UTC in milliseconds. A positive value means that the local time is
              ahead of UTC (e.g. for Europe); a negative value means that the local time is behind
              UTC (e.g. for America).
            </summary>
            <remarks>
              <para>
                Offsets are constrained to the range (-24 hours, 24 hours). If the millisecond value given
                is outside this range then the value is forced into the range by considering that time wraps
                as it goes around the world multiple times.
              </para>
              <para>
                Internally, offsets are stored as an <see cref="T:System.Int32"/> number of milliseconds instead of
                as ticks. This is because as a description of the offset of a time zone from UTC, there is
                no offset of less than one second. Using milliseconds gives more than enough resolution and
                allows us to save 4 bytes per Offset.
              </para>
              <para>
                This type is immutable and thread-safe.
              </para>
            </remarks>
        </member>
        <member name="F:NodaTime.Offset.Zero">
            <summary>
            An offset of zero ticks - effectively the permanent offset for UTC.
            </summary>
        </member>
        <member name="F:NodaTime.Offset.MinValue">
            <summary>
            The minimum permitted offset; one millisecond less than a standard day before UTC.
            </summary>
        </member>
        <member name="F:NodaTime.Offset.MaxValue">
            <summary>
            The minimum permitted offset; one millisecond less than a standard day after UTC.
            </summary>
        </member>
        <member name="M:NodaTime.Offset.#ctor(System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:NodaTime.Offset"/> struct.
            </summary>
            <remarks>
              Offsets are constrained to the range (-24 hours, 24 hours). If the millisecond value
              given is outside this range then the value is forced into the range by considering that
              time wraps as it goes around the world multiple times.
            </remarks>
            <param name="milliseconds">The number of milliseconds.</param>
        </member>
        <member name="M:NodaTime.Offset.Max(NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Returns the greater offset of the given two, i.e. the one which will give a later local
            time when added to an instant.
            </summary>
        </member>
        <member name="M:NodaTime.Offset.Min(NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Returns the lower offset of the given two, i.e. the one which will give an earlier local
            time when added to an instant.
            </summary>
        </member>
        <member name="M:NodaTime.Offset.op_UnaryNegation(NodaTime.Offset)">
            <summary>
              Implements the unary operator - (negation).
            </summary>
            <param name="offset">The offset to negate.</param>
            <returns>A new <see cref="T:NodaTime.Offset"/> instance with a negated value.</returns>
        </member>
        <member name="M:NodaTime.Offset.Negate(NodaTime.Offset)">
            <summary>
            Returns the negation of the specified offset. This is the method form of the unary minus operator.
            </summary>
        </member>
        <member name="M:NodaTime.Offset.op_UnaryPlus(NodaTime.Offset)">
            <summary>
              Implements the unary operator + .
            </summary>
            <param name="offset">The operand.</param>
            <returns>The same <see cref="T:NodaTime.Offset"/> instance</returns>
        </member>
        <member name="M:NodaTime.Offset.Plus(NodaTime.Offset)">
            <summary>
            Returns the specified offset. This is the method form of the unary plus operator.
            </summary>
        </member>
        <member name="M:NodaTime.Offset.op_Addition(NodaTime.Offset,NodaTime.Offset)">
            <summary>
              Implements the operator + (addition).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Offset"/> representing the sum of the given values.</returns>
        </member>
        <member name="M:NodaTime.Offset.Add(NodaTime.Offset,NodaTime.Offset)">
            <summary>
              Adds one Offset to another. Friendly alternative to <c>operator+()</c>.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Offset"/> representing the sum of the given values.</returns>
        </member>
        <member name="M:NodaTime.Offset.op_Subtraction(NodaTime.Offset,NodaTime.Offset)">
            <summary>
              Implements the operator - (subtraction).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Offset"/> representing the difference of the given values.</returns>
        </member>
        <member name="M:NodaTime.Offset.Subtract(NodaTime.Offset,NodaTime.Offset)">
            <summary>
              Subtracts one Offset from another. Friendly alternative to <c>operator-()</c>.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Offset"/> representing the difference of the given values.</returns>
        </member>
        <member name="M:NodaTime.Offset.op_Equality(NodaTime.Offset,NodaTime.Offset)">
            <summary>
              Implements the operator == (equality).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Offset.op_Inequality(NodaTime.Offset,NodaTime.Offset)">
            <summary>
              Implements the operator != (inequality).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are not equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Offset.op_LessThan(NodaTime.Offset,NodaTime.Offset)">
            <summary>
              Implements the operator &lt; (less than).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is less than the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Offset.op_LessThanOrEqual(NodaTime.Offset,NodaTime.Offset)">
            <summary>
              Implements the operator &lt;= (less than or equal).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is less than or equal to the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Offset.op_GreaterThan(NodaTime.Offset,NodaTime.Offset)">
            <summary>
              Implements the operator &gt; (greater than).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is greater than the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Offset.op_GreaterThanOrEqual(NodaTime.Offset,NodaTime.Offset)">
            <summary>
              Implements the operator &gt;= (greater than or equal).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is greater than or equal to the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Offset.CompareTo(NodaTime.Offset)">
            <summary>
              Compares the current object with another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
              A 32-bit signed integer that indicates the relative order of the objects being compared.
              The return value has the following meanings:
              <list type = "table">
                <listheader>
                  <term>Value</term>
                  <description>Meaning</description>
                </listheader>
                <item>
                  <term>&lt; 0</term>
                  <description>This object is less than the <paramref name = "other" /> parameter.</description>
                </item>
                <item>
                  <term>0</term>
                  <description>This object is equal to <paramref name = "other" />.</description>
                </item>
                <item>
                  <term>&gt; 0</term>
                  <description>This object is greater than <paramref name = "other" />.</description>
                </item>
              </list>
            </returns>
        </member>
        <member name="M:NodaTime.Offset.Equals(NodaTime.Offset)">
            <summary>
              Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
              true if the current object is equal to the <paramref name = "other" /> parameter;
              otherwise, false.
            </returns>
        </member>
        <member name="M:NodaTime.Offset.Equals(System.Object)">
            <summary>
              Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance;
              otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NodaTime.Offset.GetHashCode">
            <summary>
              Returns a hash code for this instance.
            </summary>
            <returns>
              A hash code for this instance, suitable for use in hashing algorithms and data
              structures like a hash table. 
            </returns>
        </member>
        <member name="M:NodaTime.Offset.ToString(System.String,System.IFormatProvider)">
            <summary>
              Formats the value of the current instance using the specified format.
            </summary>
            <returns>
              A <see cref="T:System.String" /> containing the value of the current instance in the specified format.
            </returns>
            <param name="format">The <see cref="T:System.String" /> specifying the format to use.
              -or- 
              null to use the default format defined for the type of the <see cref="T:System.IFormattable" /> implementation. 
            </param>
            <param name="formatProvider">The <see cref="T:System.IFormatProvider" /> to use to format the value.
              -or- 
              null to obtain the numeric format information from the current locale setting of the operating system. 
            </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.Offset.ToString">
            <summary>
              Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:NodaTime.Offset.ToString(System.String)">
            <summary>
              Formats the value of the current instance using the specified format.
            </summary>
            <returns>
              A <see cref="T:System.String" /> containing the value of the current instance in the specified format.
            </returns>
            <param name="format">The <see cref="T:System.String" /> specifying the format to use.
              -or- 
              null to use the default format defined for the type of the <see cref="T:System.IFormattable" /> implementation. 
            </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.Offset.ToString(System.IFormatProvider)">
            <summary>
              Formats the value of the current instance using the specified format.
            </summary>
            <returns>
              A <see cref="T:System.String" /> containing the value of the current instance in the specified format.
            </returns>
            <param name="formatProvider">The <see cref="T:System.IFormatProvider" /> to use to format the value.
              -or- 
              null to obtain the format information from the current locale setting of the operating system. 
            </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.Offset.Parse(System.String)">
            <summary>
            Parses the given string using the current culture's default format provider.
            </summary>
        </member>
        <member name="M:NodaTime.Offset.Parse(System.String,System.IFormatProvider)">
            <summary>
            Parses the given string using the specified format provider.
            </summary>
        </member>
        <member name="M:NodaTime.Offset.Parse(System.String,System.IFormatProvider,NodaTime.Format.DateTimeParseStyles)">
            <summary>
            Parses the given string using the specified format provider and style.
            </summary>
        </member>
        <member name="M:NodaTime.Offset.ParseExact(System.String,System.String,System.IFormatProvider)">
            <summary>
            Parses the given string using the specified format pattern and format provider.
            </summary>
        </member>
        <member name="M:NodaTime.Offset.ParseExact(System.String,System.String,System.IFormatProvider,NodaTime.Format.DateTimeParseStyles)">
            <summary>
            Parses the given string using the specified format pattern, format provider and style.
            </summary>
        </member>
        <member name="M:NodaTime.Offset.ParseExact(System.String,System.String[],System.IFormatProvider,NodaTime.Format.DateTimeParseStyles)">
            <summary>
            Parses the given string using the specified format patterns, format provider and style.
            </summary>
        </member>
        <member name="M:NodaTime.Offset.TryParse(System.String,NodaTime.Offset@)">
            <summary>
            Attempts to parse the given string using the current culture's default format provider. If the parse is successful,
            the result is stored in the <paramref name="result"/> parameter and the return value is true;
            otherwise <see cref="F:NodaTime.Instant.MinValue"/> is stored in the parameter and the return value is false.
            </summary>
            <returns>true if the value was parsed successfully; false otherwise.</returns>
        </member>
        <member name="M:NodaTime.Offset.TryParse(System.String,System.IFormatProvider,NodaTime.Format.DateTimeParseStyles,NodaTime.Offset@)">
            <summary>
            Attempts to parse the given string using the specified format provider and style.
            If the parse is successful, the result is stored in the <paramref name="result"/> parameter and the return value is true;
            otherwise <see cref="F:NodaTime.Instant.MinValue"/> is stored in the parameter and the return value is false.
            </summary>
            <returns>true if the value was parsed successfully; false otherwise.</returns>
        </member>
        <member name="M:NodaTime.Offset.TryParseExact(System.String,System.String,System.IFormatProvider,NodaTime.Format.DateTimeParseStyles,NodaTime.Offset@)">
            <summary>
            Attempts to parse the given string using the specified format pattern, format provider and style.
            If the parse is successful, the result is stored in the <paramref name="result"/> parameter and the return value is true;
            otherwise <see cref="F:NodaTime.Instant.MinValue"/> is stored in the parameter and the return value is false.
            </summary>
            <returns>true if the value was parsed successfully; false otherwise.</returns>
        </member>
        <member name="M:NodaTime.Offset.TryParseExact(System.String,System.String[],System.IFormatProvider,NodaTime.Format.DateTimeParseStyles,NodaTime.Offset@)">
            <summary>
            Attempts to parse the given string using the specified format patterns, format provider and style.
            If the parse is successful, the result is stored in the <paramref name="result"/> parameter and the return value is true;
            otherwise <see cref="F:NodaTime.Instant.MinValue"/> is stored in the parameter and the return value is false.
            </summary>
            <returns>true if the value was parsed successfully; false otherwise.</returns>
        </member>
        <member name="M:NodaTime.Offset.FromMilliseconds(System.Int32)">
            <summary>
              Returns the offset for the given milliseconds value.
            </summary>
            <param name="milliseconds">The int milliseconds value.</param>
            <returns>The <see cref="T:NodaTime.Offset"/> for the given milliseconds value</returns>
        </member>
        <member name="M:NodaTime.Offset.FromTicks(System.Int64)">
            <summary>
              Froms the ticks.
            </summary>
            <param name="ticks">The ticks.</param>
            <returns></returns>
        </member>
        <member name="M:NodaTime.Offset.ForHours(System.Int32)">
            <summary>
              Creates an offset with the specified number of hours.
            </summary>
            <param name="hours">The number of hours.</param>
            <returns>
              A new <see cref="T:NodaTime.Offset"/> representing the given value.
            </returns>
        </member>
        <member name="M:NodaTime.Offset.Create(System.Int32,System.Int32)">
            <summary>
              Creates an offset with the specified number of hours and minutes.
            </summary>
            <param name="hours">The number of hours.</param>
            <param name="minutes">The number of minutes.</param>
            <returns>
              A new <see cref="T:NodaTime.Offset"/> representing the given values.
            </returns>
            <remarks>
              TODO: not sure about the name. Anyone got a better one?
            </remarks>
        </member>
        <member name="M:NodaTime.Offset.Create(System.Int32,System.Int32,System.Int32)">
            <summary>
              Creates an offset with the specified number of hours, minutes, and seconds.
            </summary>
            <param name="hours">The number of hours.</param>
            <param name="minutes">The number of minutes.</param>
            <param name="seconds">The number of seconds.</param>
            <returns>
              A new <see cref="T:NodaTime.Offset"/> representing the given values.
            </returns>
            <remarks>
              TODO: not sure about the name. Anyone got a better one?
            </remarks>
        </member>
        <member name="M:NodaTime.Offset.Create(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
              Creates an offset with the specified number of hours, minutes, seconds, and
              milliseconds.
            </summary>
            <param name="hours">The number of hours.</param>
            <param name="minutes">The number of minutes.</param>
            <param name="seconds">The number of seconds.</param>
            <param name="fractionalSeconds">The number of milliseconds.</param>
            <returns>
              A new <see cref="T:NodaTime.Offset"/> representing the given values.
            </returns>
            <remarks>
              TODO: not sure about the name. Anyone got a better one?
              TODO: The behaviour around negative values needs documenting too! (Make this internal for now?)
            </remarks>
        </member>
        <member name="M:NodaTime.Offset.ToTimeSpan">
            <summary>
            Converts this offset to a .NET standard <see cref="T:System.TimeSpan"/> value.
            </summary>
        </member>
        <member name="P:NodaTime.Offset.IsNegative">
            <summary>
              Gets a value indicating whether this instance is negative.
            </summary>
            <value>
              <c>true</c> if this instance is negative; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:NodaTime.Offset.Hours">
            <summary>
              Gets the hours of the offset. This is always a positive value.
            </summary>
        </member>
        <member name="P:NodaTime.Offset.Minutes">
            <summary>
              Gets the minutes of the offset. This is always a positive value.
            </summary>
        </member>
        <member name="P:NodaTime.Offset.Seconds">
            <summary>
              Gets the seconds of the offset. This is always a positive value.
            </summary>
        </member>
        <member name="P:NodaTime.Offset.FractionalSeconds">
            <summary>
              Gets the fractional seconds of the offset i.e. the milliseconds of the second. This is always a positive value.
            </summary>
        </member>
        <member name="P:NodaTime.Offset.Milliseconds">
            <summary>
              Gets the number of milliseconds in the offset.
            </summary>
        </member>
        <member name="P:NodaTime.Offset.Ticks">
            <summary>
              Returns the number of ticks represented by this offset.
            </summary>
            <value>The number of ticks.</value>
        </member>
        <member name="T:NodaTime.Format.OffsetFormat">
            <summary>
              Supports the formatting of <see cref="T:NodaTime.Offset"/> objects.
            </summary>
        </member>
        <member name="M:NodaTime.Format.OffsetFormat.Format(NodaTime.Offset,System.String,NodaTime.Globalization.NodaFormatInfo)">
            <summary>
              Formats the given <see cref="T:NodaTime.Offset"/> value using the given format.
            </summary>
            <param name="value">The value to format.</param>
            <param name="format">The format string. If <c>null</c> or empty defaults to "g".</param>
            <param name="formatProvider">The <see cref="T:NodaTime.Globalization.NodaFormatInfo"/> to use. Must not be null.</param>
            <exception cref="T:System.FormatException">if the value cannot be formatted.</exception>
            <returns>The value formatted as a string.</returns>
        </member>
        <member name="T:NodaTime.Format.INodaFormatter`1">
            <summary>
            Provides an interface for value formatters in the Noda Time package. The formatters
            provided by Noda Time are all immutable and thread-safe.
            </summary>
            <para>
            Noda Time supports the common .NET model of overloaded ToString, Parse and TryParse methods,
            but using this type and <see cref="T:NodaTime.Format.INodaParser`1"/> allows formatting patterns and 
            options to be set one and then reused.
            </para>
            <typeparam name="T">The type to format.</typeparam>
        </member>
        <member name="M:NodaTime.Format.INodaFormatter`1.Format(`0)">
            <summary>
            Formats the specified value using the <see cref="T:System.IFormatProvider"/> given when the formatter
            was constructed. This does NOT use the current thread <see cref="T:System.IFormatProvider"/>.
            </summary>
            <param name="value">The value to format.</param>
            <returns>The value formatted as a string.</returns>
        </member>
        <member name="M:NodaTime.Format.INodaFormatter`1.WithFormatProvider(System.IFormatProvider)">
            <summary>
            Returns a new copy of this formatter that uses the given <see cref="T:System.IFormatProvider"/> for
            formatting instead of the one that this formatter uses.
            </summary>
            <param name="formatProvider">The format provider to use.</param>
            <returns>A new copy of this formatter using the given <see cref="T:System.IFormatProvider"/>.</returns>
        </member>
        <member name="P:NodaTime.Format.INodaFormatter`1.FormatProvider">
            <summary>
            Gets the format provider use by this formatter to format values.
            </summary>
            <value>
            The format provider.
            </value>
        </member>
        <member name="M:NodaTime.Format.AbstractNodaFormatter`1.#ctor(System.IFormatProvider)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.Format.AbstractNodaFormatter`1"/> class.
            </summary>
            <param name="formatProvider">The format provider.</param>
        </member>
        <member name="M:NodaTime.Format.AbstractNodaFormatter`1.Format(`0)">
            <summary>
            Formats the specified value using the <see cref="T:System.IFormatProvider"/> given when the formatter
            was constructed. This does NOT use the current thread <see cref="T:System.IFormatProvider"/>.
            </summary>
            <param name="value">The value to format.</param>
            <returns>The value formatted as a string.</returns>
        </member>
        <member name="M:NodaTime.Format.AbstractNodaFormatter`1.WithFormatProvider(System.IFormatProvider)">
            <summary>
            Returns a new copy of this formatter that uses the given <see cref="T:System.IFormatProvider"/> for
            formatting instead of the one that this formatter uses.
            </summary>
            <param name="formatProvider">The format provider to use.</param>
            <returns>A new copy of this formatter using the given <see cref="T:System.IFormatProvider"/>.</returns>
        </member>
        <member name="P:NodaTime.Format.AbstractNodaFormatter`1.FormatProvider">
            <summary>
            Gets the format provider use by this formatter to format values..
            </summary>
            <value>
            The format provider.
            </value>
        </member>
        <member name="T:NodaTime.ZonedDateTime">
            <summary>
            A date and time with an associated chronology - or to look at it a different way, a
            LocalDateTime plus a time zone.
            </summary>
            <remarks>
            <para>
            Some seemingly valid values do not represent a valid instant due to the local time moving
            forward during a daylight saving transition, thus "skipping" the given value. Other values
            occur twice (due to local time moving backward), in which case a ZonedDateTime will always
            represent the later of the two possible times, when converting it to an instant.
            </para>
            <para>
            A value constructed with "new ZonedDateTime()" will represent the Unix epoch in the ISO
            calendar system in the UTC time zone. That is the only situation in which the chronology is
            assumed rather than specified.
            </para>
            </remarks>
        </member>
        <member name="M:NodaTime.ZonedDateTime.#ctor(NodaTime.LocalInstant,NodaTime.Offset,NodaTime.Chronology)">
            <summary>
            Internal constructor used by other code that has already validated and 
            computed the appropriate field values. No further validation is performed.
            </summary>
        </member>
        <member name="M:NodaTime.ZonedDateTime.#ctor(NodaTime.Instant,NodaTime.Chronology)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.ZonedDateTime"/> struct.
            </summary>
            <param name="instant">The instant.</param>
            <param name="chronology">The chronology.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if the <paramref name="chronology"/> is <c>null</c>.</exception>
        </member>
        <member name="M:NodaTime.ZonedDateTime.#ctor(NodaTime.Instant,NodaTime.DateTimeZone)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.ZonedDateTime"/> struct in the specified time zone
            and the ISO calendar.
            </summary>
            <param name="instant">The instant of time to represent.</param>
            <param name="zone">The time zone to represent the instant within.</param>
        </member>
        <member name="M:NodaTime.ZonedDateTime.ValidateZone(NodaTime.DateTimeZone)">
            <summary>
            Used by the constructor above to allow us to perform argument validation
            but still chain to another constructor.
            </summary>
        </member>
        <member name="M:NodaTime.ZonedDateTime.ToInstant">
            <summary>
            Converts this value to the instant it represents on the time line.
            If two instants are represented by the same set of values, the later
            instant is returned.
            </summary>
            <remarks>
            Conceptually this is a conversion (which is why it's not a property) but
            in reality the conversion is done at the point of construction.
            </remarks>
        </member>
        <member name="M:NodaTime.ZonedDateTime.Equals(NodaTime.ZonedDateTime)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.
                            </param>
        </member>
        <member name="M:NodaTime.ZonedDateTime.Equals(System.Object)">
            <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
            <returns>
            true if <paramref name="obj"/> and this instance are the same type and represent the same value; otherwise, false.
            </returns>
            <param name="obj">Another object to compare to. 
                            </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.ZonedDateTime.GetHashCode">
            <summary>
            Computes the hash code for this instance.
            </summary>
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.ZonedDateTime.op_Equality(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)">
            <summary>
            Implements the operator ==.
            </summary>
        </member>
        <member name="M:NodaTime.ZonedDateTime.op_Inequality(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)">
            <summary>
            Implements the operator !=.
            </summary>
        </member>
        <member name="M:NodaTime.ZonedDateTime.op_Addition(NodaTime.ZonedDateTime,NodaTime.Duration)">
            <summary>
            Returns a new ZonedDateTime with the time advanced by the given duration. Note that
            due to daylight saving time changes this may not advance the local time by the same amount.
            </summary>
            <remarks>
            The returned value uses the same calendar system and time zone as the left operand.
            </remarks>
            <param name="left">The ZonedDateTime to add the duration to.</param>
            <param name="right">The duration to add.</param>
        </member>
        <member name="M:NodaTime.ZonedDateTime.Add(NodaTime.ZonedDateTime,NodaTime.Duration)">
            <summary>
            Adds a duration to zoned date and time. Friendly alternative to <c>operator+()</c>.
            </summary>
        </member>
        <member name="M:NodaTime.ZonedDateTime.Subtract(NodaTime.ZonedDateTime,NodaTime.Duration)">
            <summary>
            Subtracts a duration from zoned date and time. Friendly alternative to <c>operator-()</c>.
            </summary>
        </member>
        <member name="M:NodaTime.ZonedDateTime.op_Subtraction(NodaTime.ZonedDateTime,NodaTime.Duration)">
            <summary>
            Returns a new ZonedDateTime with the duration subtracted. Note that
            due to daylight saving time changes this may not change the local time by the same amount.
            </summary>
            <remarks>
            The returned value uses the same calendar system and time zone as the left operand.
            </remarks>
            <param name="left">The ZonedDateTime to subtract the duration from.</param>
            <param name="right">The duration to add.</param>
        </member>
        <member name="M:NodaTime.ZonedDateTime.ToString">
            <summary>
            Converts this date and time to text according to the default formatting for the culture.
            </summary>
        </member>
        <member name="M:NodaTime.ZonedDateTime.ToDateTimeOffset">
            <summary>
            Constructs a <see cref="T:System.DateTimeOffset"/> value with the same local time and offset from
            UTC as this value.
            </summary>
            <remarks>
            An offset does not convey as much information as a time zone; a <see cref="T:System.DateTimeOffset"/>
            represents an instant in time along with an associated local time, but it doesn't allow you
            to find out what the local time would be for another instant.
            </remarks>
        </member>
        <member name="M:NodaTime.ZonedDateTime.ToDateTimeUtc">
            <summary>
            Constructs a <see cref="T:System.DateTime"/> from this ZonedDateTime which has a <see cref="P:System.DateTime.Kind"/>
            of <see cref="F:System.DateTimeKind.Utc"/> and represents the same instant of time as this value
            rather than the same local time.
            </summary>
        </member>
        <member name="M:NodaTime.ZonedDateTime.ToDateTimeUnspecified">
            <summary>
            Constructs a <see cref="T:System.DateTime"/> from this ZonedDateTime which has a <see cref="P:System.DateTime.Kind"/>
            of <see cref="F:System.DateTimeKind.Unspecified"/> and represents the same local time as this value
            rather than the same instant in time.
            </summary>
            <remarks>
            <see cref="F:System.DateTimeKind.Unspecified"/> is slightly odd - it can be treated as UTC if you use <see cref="M:System.DateTime.ToLocalTime"/>
            or as system local time if you use <see cref="M:System.DateTime.ToUniversalTime"/>, but it's the only kind which allows
            you to construct a <see cref="T:System.DateTimeOffset"/> with an arbitrary offset, which makes it as close to
            the Noda Time non-system-specific "local" concept as exists in .NET.
            </remarks>
        </member>
        <member name="P:NodaTime.ZonedDateTime.Chronology">
            <summary>
            Gets the chronology.
            </summary>
        </member>
        <member name="P:NodaTime.ZonedDateTime.Offset">
            <summary>
            Gets the offset 
            </summary>
        </member>
        <member name="P:NodaTime.ZonedDateTime.Zone">
            <summary>
            Gets the time zone 
            </summary>
        </member>
        <member name="P:NodaTime.ZonedDateTime.LocalInstant">
            <summary>
            Gets the local instant.
            </summary>
        </member>
        <member name="P:NodaTime.ZonedDateTime.LocalDateTime">
            <summary>
            Gets the local date and time represented by this zoned date and time. The returned <see cref="P:NodaTime.ZonedDateTime.LocalDateTime"/>
            will have the same calendar system and return the same values for each of the calendar properties
            (Year, MonthOfYear and so on), but not be associated with any particular time zone.
            </summary>
        </member>
        <member name="P:NodaTime.ZonedDateTime.Era">
            <summary>
            Gets the era for this date and time. The precise meaning of this value depends on the calendar
            system in use.
            </summary>
        </member>
        <member name="P:NodaTime.ZonedDateTime.CenturyOfEra">
            <summary>
            Gets the century within the era of this date and time.
            </summary>
        </member>
        <member name="P:NodaTime.ZonedDateTime.Year">
            <summary>
            Gets the year of this date and time.
            </summary>
        </member>
        <member name="P:NodaTime.ZonedDateTime.YearOfCentury">
            <summary>
            Gets the year of this date and time within its century.
            </summary>
        </member>
        <member name="P:NodaTime.ZonedDateTime.YearOfEra">
            <summary>
            Gets the year of this date and time within its era.
            </summary>
        </member>
        <member name="P:NodaTime.ZonedDateTime.WeekYear">
            <summary>
            Gets the "week year" of this date and time.
            </summary>
            <remarks>
            <para>
            The WeekYear is the year that matches with the WeekOfWeekYear field.
            In the standard ISO8601 week algorithm, the first week of the year
            is that in which at least 4 days are in the year. As a result of this
            definition, day 1 of the first week may be in the previous year.
            The WeekYear allows you to query the effective year for that day
            </para>
            <para>
            For example, January 1st 2011 was a Saturday, so only two days of that week
            (Saturday and Sunday) were in 2011. Therefore January 1st is part of
            week 52 of WeekYear 2010. Conversely, December 31st 2012 is a Monday,
            so is part of week 1 of WeekYear 2013.
            </para>
            </remarks>
        </member>
        <member name="P:NodaTime.ZonedDateTime.MonthOfYear">
            <summary>
            Gets the month of this date and time within the year.
            </summary>
        </member>
        <member name="P:NodaTime.ZonedDateTime.WeekOfWeekYear">
            <summary>
            Gets the week within the WeekYear. See <see cref="P:NodaTime.ZonedDateTime.WeekYear"/> for more details.
            </summary>
        </member>
        <member name="P:NodaTime.ZonedDateTime.DayOfYear">
            <summary>
            Gets the day of this date and time within the year.
            </summary>
        </member>
        <member name="P:NodaTime.ZonedDateTime.DayOfMonth">
            <summary>
            Gets the day of this date and time within the month.
            </summary>
        </member>
        <member name="P:NodaTime.ZonedDateTime.IsoDayOfWeek">
            <summary>
            Gets the week day of this date and time expressed as an <see cref="T:NodaTime.IsoDayOfWeek"/> value,
            for calendars which use ISO days of the week.
            </summary>
            <exception cref="T:System.InvalidOperationException">The underlying calendar doesn't use ISO days of the week.</exception>
        </member>
        <member name="P:NodaTime.ZonedDateTime.DayOfWeek">
            <summary>
            Gets the week day of this date and time as a number.
            </summary>
            <remarks>
            For calendars using ISO week days, this gives 1 for Monday to 7 for Sunday.
            </remarks>
            <seealso cref="P:NodaTime.ZonedDateTime.IsoDayOfWeek"/>
        </member>
        <member name="P:NodaTime.ZonedDateTime.HourOfDay">
            <summary>
            Gets the hour of day of this date and time, in the range 0 to 23 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.ZonedDateTime.MinuteOfHour">
            <summary>
            Gets the minute of this date and time, in the range 0 to 59 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.ZonedDateTime.SecondOfMinute">
            <summary>
            Gets the second of this date and time within the minute, in the range 0 to 59 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.ZonedDateTime.SecondOfDay">
            <summary>
            Gets the second of this date and time within the day, in the range 0 to 86,399 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.ZonedDateTime.MillisecondOfSecond">
            <summary>
            Gets the millisecond of this date and time within the second, in the range 0 to 999 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.ZonedDateTime.MillisecondOfDay">
            <summary>
            Gets the millisecond of this date and time within the day, in the range 0 to 86,399,999 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.ZonedDateTime.TickOfMillisecond">
            <summary>
            Gets the tick of this date and time within the millisceond, in the range 0 to 9,999 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.ZonedDateTime.TickOfDay">
            <summary>
            Gets the tick of this date and time within the day, in the range 0 to 863,999,999,999 inclusive.
            </summary>
        </member>
        <member name="T:NodaTime.Interval">
            <summary>
            An interval between two instants in time.
            </summary>
            <remarks>
            This type is immutable and thread-safe.
            </remarks>
        </member>
        <member name="M:NodaTime.Interval.#ctor(NodaTime.Instant,NodaTime.Instant)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.Interval"/> struct. The <see cref="T:NodaTime.Interval"/> includes the <paramref name="start"/> instant and excludes the
            <paramref name="end"/> instant.
            </summary>
            <param name="start">The start <see cref="T:NodaTime.Instant"/>.</param>
            <param name="end">The end <see cref="T:NodaTime.Instant"/>.</param>
        </member>
        <member name="M:NodaTime.Interval.Equals(NodaTime.Interval)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter;
            otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:NodaTime.Interval.Equals(System.Object)">
            <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
            <returns>
            true if <paramref name="obj"/> and this instance are the same type and represent the same value; otherwise, false.
            </returns>
            <param name="obj">Another object to compare to. 
                            </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.Interval.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.Interval.op_Equality(NodaTime.Interval,NodaTime.Interval)">
            <summary>
            Implements the operator ==.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:NodaTime.Interval.op_Inequality(NodaTime.Interval,NodaTime.Interval)">
            <summary>
            Implements the operator !=.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="P:NodaTime.Interval.Start">
            <summary>
            Gets the start instant.
            </summary>
            <value>The start <see cref="T:NodaTime.Instant"/>.</value>
        </member>
        <member name="P:NodaTime.Interval.End">
            <summary>
            Gets the end instant.
            </summary>
            <value>The end <see cref="T:NodaTime.Instant"/>.</value>
        </member>
        <member name="P:NodaTime.Interval.Duration">
            <summary>
            Gets the duration.
            </summary>
            <value>The duration.</value>
        </member>
        <member name="T:NodaTime.TimeZones.TransitionMode">
            <summary>
            Specifies how transitions are calculated. Whether relative to UTC, the time zones standard
            offset, or the wall (or daylight savings) offset.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.TransitionMode.Utc">
            <summary>
            Calculate transitions against UTC.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.TransitionMode.Wall">
            <summary>
            Calculate transitions against wall offset.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.TransitionMode.Standard">
            <summary>
            Calculate transitions against standard offset.
            </summary>
        </member>
        <member name="T:NodaTime.TimeZones.ZoneTransition">
            <summary>
            Represents a transition two different time references.
            </summary>
            <remarks>
            <para>
            Normally this is between standard time and daylight savings time but it might be for other
            purposes like the discontinuity in the Gregorian calendar to account for leap time.
            </para>
            <para>
            Immutable, thread safe.
            </para>
            </remarks>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneTransition.#ctor(NodaTime.Instant,System.String,NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.ZoneTransition"/> class.
            </summary>
            <remarks>
            <para>
            Assumption 1: Offset.MaxValue &lt;&lt; Instant.MaxValue
            </para>
            <para>
            Assumption 2: Offset.MinValue &gt;&gt; Instant.MinValue
            </para>
            <para>
            Therefore the sum of an Instant with an Offset of the opposite sign cannot overflow or
            underflow. We only have to worry about summing an Instant with an Offset of the same
            sign over/underflowing.
            </para>
            </remarks>
            <param name="instant">The instant that this transistion occurs at.</param>
            <param name="name">The name for the time at this transition e.g. PDT or PST.</param>
            <param name="standardOffset">The standard offset at this transition.</param>
            <param name="savings">The actual offset at this transition.</param>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneTransition.CompareTo(NodaTime.TimeZones.ZoneTransition)">
            <summary>
            Compares the current object with another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            A 32-bit signed integer that indicates the relative order of the objects being compared. 
            The return value has the following meanings:
            Value
            Meaning
            Less than zero
            This object is less than the <paramref name="other"/> parameter.
            Zero
            This object is equal to <paramref name="other"/>.
            Greater than zero
            This object is greater than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneTransition.op_Equality(NodaTime.TimeZones.ZoneTransition,NodaTime.TimeZones.ZoneTransition)">
            <summary>
            Implements the operator ==.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneTransition.op_Inequality(NodaTime.TimeZones.ZoneTransition,NodaTime.TimeZones.ZoneTransition)">
            <summary>
            Implements the operator !=.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneTransition.Equals(NodaTime.TimeZones.ZoneTransition)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter;
            otherwise, false.
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneTransition.IsTransitionFrom(NodaTime.TimeZones.ZoneTransition)">
            <summary>
            Determines whether is a transition from the given transition.
            </summary>
            <remarks>
            To be a transition from another the instant at which the transition occurs must be
            greater than the given transition's and either the wall offset or the name must be
            different. If this is not true then this transition is considered to be redundant
            and should not be used.
            TODO: Consider whether going from "standard=0,savings=1" to "standard=1,savings=0"
            should be considered a transition. Currently we don't expose the standard/savings
            aspect of a time zone, but we may well in the future.
            </remarks>
            <param name="other">The <see cref="T:NodaTime.TimeZones.ZoneTransition"/> to compare to.</param>
            <returns>
            <c>true</c> if this is a transition from the given transition; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneTransition.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
            <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance;
            otherwise, <c>false</c>.
            </returns>
            <exception cref="T:System.NullReferenceException">
            The <paramref name="obj"/> parameter is null.
            </exception>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneTransition.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data
            structures like a hash table. 
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneTransition.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="T:NodaTime.Period">
            <summary>
            Represents a period of time expressed in human chronological terms: hours, days,
            weeks, months and so on. All implementations in Noda Time are immutable, and return fields
            in descending size order: hours before minutes, for example.
            </summary>
            <remarks>
            Periods operate on calendar-related types such as
            <see cref="T:NodaTime.LocalDateTime"/> whereas <see cref="T:NodaTime.Duration"/> operates on instants
            on the time line. Although <see cref="T:NodaTime.ZonedDateTime"/> includes both concepts, it is generally
            simpler to consider period-based arithmetic solely on local dates and times, so only
            duration-based arithmetic is supported on ZonedDateTime. This avoids ambiguities
            and skipped date/time values becoming a problem within a series of calculations; instead,
            these can be considered just once, at the point of conversion to a ZonedDateTime.
            </remarks>
        </member>
        <member name="M:NodaTime.Period.#ctor(NodaTime.PeriodType,System.Int64[])">
            <summary>
            Creates a new period with the given array without copying it. The array contents must
            not be changed after the value has been constructed - which is why this method is private.
            </summary>
            <param name="periodType">Type of this period, describing which fields are present</param>
            <param name="values">Values for each field in the period type</param>
        </member>
        <member name="M:NodaTime.Period.FromYears(System.Int64)">
            <summary>
            Creates a period representing the specified number of years.
            </summary>
        </member>
        <member name="M:NodaTime.Period.FromMonths(System.Int64)">
            <summary>
            Creates a period representing the specified number of months.
            </summary>
        </member>
        <member name="M:NodaTime.Period.FromDays(System.Int64)">
            <summary>
            Creates a period representing the specified number of days.
            </summary>
        </member>
        <member name="M:NodaTime.Period.FromHours(System.Int64)">
            <summary>
            Creates a period representing the specified number of hours.
            </summary>
        </member>
        <member name="M:NodaTime.Period.FromMinutes(System.Int64)">
            <summary>
            Creates a period representing the specified number of minutes.
            </summary>
        </member>
        <member name="M:NodaTime.Period.FromSeconds(System.Int64)">
            <summary>
            Creates a period representing the specified number of seconds.
            </summary>
        </member>
        <member name="M:NodaTime.Period.FromMillseconds(System.Int64)">
            <summary>
            Creates a period representing the specified number of miliseconds.
            </summary>
        </member>
        <member name="M:NodaTime.Period.FromTicks(System.Int64)">
            <summary>
            Creates a period representing the specified number of ticks.
            </summary>
        </member>
        <member name="M:NodaTime.Period.op_Addition(NodaTime.Period,NodaTime.Period)">
            <summary>
            Adds two periods together, by simply adding the values for each field. Currently this
            returns a period with a period type of "all fields".
            </summary>
        </member>
        <member name="M:NodaTime.Period.op_Subtraction(NodaTime.Period,NodaTime.Period)">
            <summary>
            Subtracts one periods from another, by simply subtracting each field value. Currently this
            returns a period with a period type of "all fields".
            </summary>
        </member>
        <member name="M:NodaTime.Period.Between(NodaTime.LocalDateTime,NodaTime.LocalDateTime,NodaTime.PeriodType)">
            <summary>
            Returns the period between a start and an end date/time, using the set of fields in the given
            period type.
            </summary>
            <remarks>
            If <paramref name="end"/> is before <paramref name="start"/>, each field in the returned period
            will be negative. If the given period type cannot exactly reach the end point (e.g. finding
            the difference between 1am and 3:15am in hours) the result will be such that adding it to <paramref name="start"/>
            will give a value between <paramref name="start"/> and <paramref name="end"/>. In other words,
            any rounding is "towards start"; this is true whether the resulting period is negative or positive.
            </remarks>
            <param name="start">Start date/time</param>
            <param name="end">End date/time</param>
            <param name="periodType">Period type to use for calculations</param>
            <exception cref="T:System.ArgumentException"><paramref name="start"/> and <paramref name="end"/> use different calendars</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="periodType"/> is null</exception>
            <returns>The period between the given date/times</returns>
        </member>
        <member name="M:NodaTime.Period.Between(NodaTime.LocalDateTime,NodaTime.LocalDateTime)">
            <summary>
            Returns the difference between two date/times using the "all fields" period type.
            </summary>
        </member>
        <member name="M:NodaTime.Period.Between(NodaTime.LocalDate,NodaTime.LocalDate,NodaTime.PeriodType)">
            <summary>
            Returns the period between a start and an end date, using the set of fields in the given
            period type.
            </summary>
            <remarks>
            If <paramref name="end"/> is before <paramref name="start"/>, each field in the returned period
            will be negative. If the given period type cannot exactly reach the end point (e.g. finding
            the difference between 12th February and 15th March in months) the result will be such that adding it to <paramref name="start"/>
            will give a value between <paramref name="start"/> and <paramref name="end"/>. In other words,
            any rounding is "towards start"; this is true whether the resulting period is negative or positive.
            </remarks>
            <param name="start">Start date/time</param>
            <param name="end">End date/time</param>
            <param name="periodType">Period type to use for calculations</param>
            <exception cref="T:System.ArgumentException"><paramref name="periodType"/> contains time fields</exception>
            <exception cref="T:System.ArgumentException"><paramref name="start"/> and <paramref name="end"/> use different calendars</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="periodType"/> is null</exception>
            <returns>The period between the given dates</returns>
        </member>
        <member name="M:NodaTime.Period.Between(NodaTime.LocalDate,NodaTime.LocalDate)">
            <summary>
            Returns the difference between two dates using the "year month day" period type.
            </summary>
        </member>
        <member name="M:NodaTime.Period.Between(NodaTime.LocalTime,NodaTime.LocalTime,NodaTime.PeriodType)">
            <summary>
            Returns the period between a start and an end time, using the set of fields in the given
            period type.
            </summary>
            <remarks>
            If <paramref name="end"/> is before <paramref name="start"/>, each field in the returned period
            will be negative. If the given period type cannot exactly reach the end point (e.g. finding
            the difference between 3am and 4.30am in hours) the result will be such that adding it to <paramref name="start"/>
            will give a value between <paramref name="start"/> and <paramref name="end"/>. In other words,
            any rounding is "towards start"; this is true whether the resulting period is negative or positive.
            </remarks>
            <param name="start">Start date/time</param>
            <param name="end">End date/time</param>
            <param name="periodType">Period type to use for calculations</param>
            <exception cref="T:System.ArgumentException"><paramref name="periodType"/> contains time fields</exception>
            <exception cref="T:System.ArgumentException"><paramref name="start"/> and <paramref name="end"/> use different calendars</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="periodType"/> is null</exception>
            <returns>The period between the given times</returns>
        </member>
        <member name="M:NodaTime.Period.Between(NodaTime.LocalTime,NodaTime.LocalTime)">
            <summary>
            Returns the difference between two dates using the "time" period type.
            </summary>
        </member>
        <member name="M:NodaTime.Period.GetEnumerator">
            <summary>
            Returns the fields and values within this period.
            </summary>
        </member>
        <member name="M:NodaTime.Period.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns the fields and values within this period.
            </summary>
        </member>
        <member name="M:NodaTime.Period.Equals(System.Object)">
            <summary>
            Compares the given object for equality with this one, as per <see cref="M:NodaTime.Period.Equals(NodaTime.Period)"/>.
            </summary>
        </member>
        <member name="M:NodaTime.Period.GetHashCode">
            <summary>
            Returns the hash code for this period, consistent with <see cref="M:NodaTime.Period.Equals(NodaTime.Period)"/>.
            </summary>
        </member>
        <member name="M:NodaTime.Period.Equals(NodaTime.Period)">
            <summary>
            Compares the given period for equality with this one.
            </summary>
            <remarks>
            Periods are equal if they contain the same values for the same fields, regardless of period type
            - so a period of "one hour" is the same whether or not it's potentially got other fields with
            a zero value. However, no normalization takes place, so "one hour" is not equal to "sixty minutes".
            </remarks>
        </member>
        <member name="P:NodaTime.Period.PeriodType">
            <summary>
            Returns the type of this period, which describes the fields within this period.
            </summary>
        </member>
        <member name="P:NodaTime.Period.Item(NodaTime.Fields.DurationFieldType)">
            <summary>
            Returns the value of the given field within this period. If the period does not contain
            the given field, 0 is returned.
            </summary>
        </member>
        <member name="P:NodaTime.Period.Years">
            <summary>
            Gets the number of years within this period.
            </summary>
        </member>
        <member name="P:NodaTime.Period.Months">
            <summary>
            Gets the number of months within this period.
            </summary>
        </member>
        <member name="P:NodaTime.Period.Weeks">
            <summary>
            Gets the number of weeks within this period.
            </summary>
        </member>
        <member name="P:NodaTime.Period.Days">
            <summary>
            Gets the number of days within this period.
            </summary>
        </member>
        <member name="P:NodaTime.Period.Hours">
            <summary>
            Gets the number of hours within this period.
            </summary>
        </member>
        <member name="P:NodaTime.Period.Minutes">
            <summary>
            Gets the number of minutes within this period.
            </summary>
        </member>
        <member name="P:NodaTime.Period.Seconds">
            <summary>
            Gets the number of seconds within this period.
            </summary>
        </member>
        <member name="P:NodaTime.Period.Milliseconds">
            <summary>
            Gets the number of milliseconds within this period.
            </summary>
        </member>
        <member name="P:NodaTime.Period.Ticks">
            <summary>
            Gets the number of ticks within this period.
            </summary>
        </member>
        <member name="T:NodaTime.Fields.IsoYearOfEraDateTimeField">
            <summary>
            Still need to do AddWrapField.
            </summary>
        </member>
        <member name="T:NodaTime.Fields.DecoratedDateTimeField">
            <summary>
            Derives from <see cref="T:NodaTime.Fields.DateTimeField"/>, implementing
            only the minimum required set of methods. These implemented methods
            delegate to a wrapped field.
            Porting status: Done.
            </summary>
            <remarks>
            <para>
            This design allows new DateTimeField types to be defined that piggyback
            on top of another, inheriting all the safe method implementations from
            DateTimeField. Should any method require pure delegation to the wrapped
            field, simply override and use the provided WrappedField property.
            </para>
            <para>
            Note that currently following the Joda Time model, this type does not delegate
            leap-related methods and properties - those would need to be overridden directly.
            However, presumably that's not required as Joda doesn't use it...
            </para>
            </remarks>
        </member>
        <member name="T:NodaTime.Fields.DateTimeField">
            <summary>
            Defines the calculation engine for date and time fields.
            The interface defines a set of methods that manipulate a LocalInstant
            with regards to a single field, such as monthOfYear or secondOfMinute.
            </summary>
        </member>
        <member name="M:NodaTime.Fields.DateTimeField.GetValue(NodaTime.LocalInstant)">
            <summary>
            Get the value of this field from the local instant.
            </summary>
            <param name="localInstant">The local instant to query</param>
            <returns>The value of the field, in the units of the field</returns>
        </member>
        <member name="M:NodaTime.Fields.DateTimeField.GetInt64Value(NodaTime.LocalInstant)">
            <summary>
            Get the value of this field from the local instant.
            </summary>
            <param name="localInstant">The local instant to query</param>
            <returns>The value of the field, in the units of the field</returns>
        </member>
        <member name="M:NodaTime.Fields.DateTimeField.Add(NodaTime.LocalInstant,System.Int32)">
            <summary>
            Adds a value (which may be negative) to the local instant value.
            </summary>
            <remarks>
            <para>
            The value will be added to this field. If the value is too large to be
            added solely to this field, larger fields will increase as required.
            Smaller fields should be unaffected, except where the result would be
            an invalid value for a smaller field. In this case the smaller field is
            adjusted to be in range. For example, in the ISO chronology:
            </para>
            <list type="bullet">
            <item>2000-08-20 add six months is 2001-02-20</item>
            <item>2000-08-20 add twenty months is 2002-04-20</item>
            <item>2000-08-20 add minus nine months is 1999-11-20</item>
            <item>2001-01-31 add one month  is 2001-02-28</item>
            <item>2001-01-31 add two months is 2001-03-31</item>
            </list>
            </remarks>
            <param name="localInstant">The local instant to add to</param>
            <param name="value">The value to add, in the units of the field</param>
            <returns>The updated local instant</returns>
        </member>
        <member name="M:NodaTime.Fields.DateTimeField.Add(NodaTime.LocalInstant,System.Int64)">
            <summary>
            Adds a value (which may be negative) to the local instant value.
            </summary>
            <remarks>
            <para>
            The value will be added to this field. If the value is too large to be
            added solely to this field, larger fields will increase as required.
            Smaller fields should be unaffected, except where the result would be
            an invalid value for a smaller field. In this case the smaller field is
            adjusted to be in range. For example, in the ISO chronology:
            </para>
            <list type="bullet">
            <item>2000-08-20 add six months is 2001-02-20</item>
            <item>2000-08-20 add twenty months is 2002-04-20</item>
            <item>2000-08-20 add minus nine months is 1999-11-20</item>
            <item>2001-01-31 add one month  is 2001-02-28</item>
            <item>2001-01-31 add two months is 2001-03-31</item>
            </list>
            </remarks>
            <param name="localInstant">The local instant to add to</param>
            <param name="value">The value to add, in the units of the field</param>
            <returns>The updated local instant</returns>
        </member>
        <member name="M:NodaTime.Fields.DateTimeField.AddWrapField(NodaTime.LocalInstant,System.Int32)">
            <summary>
            Adds a value (which may be negative) to the local instant,
            wrapping within this field.
            </summary>
            <param name="localInstant">The local instant to add to</param>
            <param name="value">The value to add, in the units of the field</param>
            <returns>The updated local instant</returns>
            <remarks>
            <para>
            The value will be added to this field. If the value is too large to be
            added solely to this field then it wraps. Larger fields are always
            unaffected. Smaller fields should be unaffected, except where the
            result would be an invalid value for a smaller field. In this case the
            smaller field is adjusted to be in range. For example, in the ISO chronology:
            </para>
            <list type="bullet">
            <item>2000-08-20 AddWrapField six months is 2000-02-20</item>
            <item>2000-08-20 AddWrapField twenty months is 2000-04-20</item>
            <item>2000-08-20 AddWrapField minus nine months is 2000-11-20</item>
            <item>2001-01-31 AddWrapField one month  is 2001-02-28</item>
            <item>2001-01-31 AddWrapField two months is 2001-03-31</item>
            </list>
            </remarks>
        </member>
        <member name="M:NodaTime.Fields.DateTimeField.GetDifference(NodaTime.LocalInstant,NodaTime.LocalInstant)">
            <summary>
            Computes the difference between two instants, as measured in the units
            of this field. Any fractional units are dropped from the result. Calling
            GetDifference reverses the effect of calling add. In the following code:
            <code>
            LocalInstant instant = ...
            int v = ...
            int age = GetDifference(Add(instant, v), instant);
            </code>
            The value 'age' is the same as the value 'v'.
            </summary>
            <param name="minuendInstant">The local instant to subtract from</param>
            <param name="subtrahendInstant">The local instant to subtract from minuendInstant</param>
            <returns>The difference in the units of this field</returns>
        </member>
        <member name="M:NodaTime.Fields.DateTimeField.GetInt64Difference(NodaTime.LocalInstant,NodaTime.LocalInstant)">
            <summary>
            Computes the difference between two instants, as measured in the units
            of this field. Any fractional units are dropped from the result. Calling
            GetDifference reverses the effect of calling add. In the following code:
            <code>
            LocalInstant instant = ...
            int v = ...
            int age = GetDifference(Add(instant, v), instant);
            </code>
            The value 'age' is the same as the value 'v'.
            </summary>
            <param name="minuendInstant">The local instant to subtract from</param>
            <param name="subtrahendInstant">The local instant to subtract from minuendInstant</param>
            <returns>The difference in the units of this field</returns>
        </member>
        <member name="M:NodaTime.Fields.DateTimeField.SetValue(NodaTime.LocalInstant,System.Int64)">
            <summary>
            Sets a value in the local instant supplied.
            <para>
            The value of this field will be set.
            If the value is invalid, an exception if thrown.
            </para>
            <para>
            If setting this field would make other fields invalid, then those fields
            may be changed. For example if the current date is the 31st January, and
            the month is set to February, the day would be invalid. Instead, the day
            would be changed to the closest value - the 28th/29th February as appropriate.
            </para>
            </summary>
            <param name="localInstant">The local instant to set in</param>
            <param name="value">The value to set, in the units of the field</param>
            <returns>The updated local instant</returns>
        </member>
        <member name="M:NodaTime.Fields.DateTimeField.IsLeap(NodaTime.LocalInstant)">
            <summary>
            Defaults to non-leap.
            </summary>
        </member>
        <member name="M:NodaTime.Fields.DateTimeField.GetLeapAmount(NodaTime.LocalInstant)">
            <summary>
            Defaults to 0.
            </summary>
        </member>
        <member name="M:NodaTime.Fields.DateTimeField.GetMaximumValue(NodaTime.LocalInstant)">
            <summary>
            Defaults to the absolute maximum for the field.
            </summary>
        </member>
        <member name="M:NodaTime.Fields.DateTimeField.GetMaximumValue">
            <summary>
            Get the maximum allowable value for this field.
            </summary>
            <returns>The maximum valid value for this field, in the units of the field</returns>
        </member>
        <member name="M:NodaTime.Fields.DateTimeField.GetMinimumValue(NodaTime.LocalInstant)">
            <summary>
            Defaults to the absolute minimum for the field.
            </summary>
        </member>
        <member name="M:NodaTime.Fields.DateTimeField.GetMinimumValue">
            <summary>
            Get the minimum allowable value for this field.
            </summary>
            <returns>The minimum valid value for this field, in the units of the field</returns>
        </member>
        <member name="M:NodaTime.Fields.DateTimeField.RoundFloor(NodaTime.LocalInstant)">
            <summary>
            Round to the lowest whole unit of this field. After rounding, the value
            of this field and all fields of a higher magnitude are retained. The
            fractional ticks that cannot be expressed in whole increments of this
            field are set to minimum.
            <para>
            For example, a datetime of 2002-11-02T23:34:56.789, rounded to the
            lowest whole hour is 2002-11-02T23:00:00.000.
            </para>
            </summary>
            <param name="localInstant">The local instant to round</param>
            <returns>Rounded local instant</returns>
        </member>
        <member name="M:NodaTime.Fields.DateTimeField.RoundCeiling(NodaTime.LocalInstant)">
            <summary>
            Round to the highest whole unit of this field. The value of this field
            and all fields of a higher magnitude may be incremented in order to
            achieve this result. The fractional ticks that cannot be expressed in
            whole increments of this field are set to minimum.
            <para>
            For example, a datetime of 2002-11-02T23:34:56.789, rounded to the
            highest whole hour is 2002-11-03T00:00:00.000.
            </para>
            </summary>
            <param name="localInstant">The local instant to round</param>
            <returns>Rounded local instant</returns>
        </member>
        <member name="M:NodaTime.Fields.DateTimeField.RoundHalfFloor(NodaTime.LocalInstant)">
            <summary>
            Round to the nearest whole unit of this field. If the given local instant
            is closer to the floor or is exactly halfway, this function
            behaves like RoundFloor. If the local instant is closer to the
            ceiling, this function behaves like RoundCeiling.
            </summary>
            <param name="localInstant">The local instant to round</param>
            <returns>Rounded local instant</returns>
        </member>
        <member name="M:NodaTime.Fields.DateTimeField.RoundHalfCeiling(NodaTime.LocalInstant)">
            <summary>
            Round to the nearest whole unit of this field. If the given local instant
            is closer to the floor, this function behaves like RoundFloor. If
            the local instant is closer to the ceiling or is exactly halfway,
            this function behaves like RoundCeiling.
            </summary>
            <param name="localInstant">The local instant to round</param>
            <returns>Rounded local instant</returns>
        </member>
        <member name="M:NodaTime.Fields.DateTimeField.RoundHalfEven(NodaTime.LocalInstant)">
            <summary>
            Round to the nearest whole unit of this field. If the given local instant
            is closer to the floor, this function behaves like RoundFloor. If
            the local instant is closer to the ceiling, this function behaves
            like RoundCeiling.
            </summary>
            <param name="localInstant">The local instant to round</param>
            <returns>Rounded local instant</returns>
        </member>
        <member name="M:NodaTime.Fields.DateTimeField.Remainder(NodaTime.LocalInstant)">
            <summary>
            Returns the fractional duration of this field. In other words, 
            calling Remainder returns the duration that RoundFloor would subtract.
            <para>
            For example, on a datetime of 2002-11-02T23:34:56.789, the remainder by
            hour is 34 minutes and 56.789 seconds.
            </para>
            </summary>
            <param name="localInstant">The local instant to get the remainder</param>
            <returns>Remainder duration</returns>
        </member>
        <member name="P:NodaTime.Fields.DateTimeField.FieldType">
            <summary>
            Get the type of the field.
            </summary>
        </member>
        <member name="P:NodaTime.Fields.DateTimeField.Name">
            <summary>
            Get the name of the field.
            </summary>
            <remarks>
            By convention, names follow a pattern of "dddOfRrr", where "ddd" represents
            the (singular) duration unit field name and "Rrr" represents the (singular)
            duration range field name. If the range field is not applicable, then
            the name of the field is simply the (singular) duration field name.
            </remarks>
        </member>
        <member name="P:NodaTime.Fields.DateTimeField.DurationField">
            <summary>
            Gets the duration per unit value of this field, or UnsupportedDurationField if field has no duration.
            For example, if this
            field represents "hour of day", then the duration is an hour.
            </summary>
        </member>
        <member name="P:NodaTime.Fields.DateTimeField.RangeDurationField">
            <summary>
            Returns the range duration of this field. For example, if this field
            represents "hour of day", then the range duration is a day.
            </summary>
        </member>
        <member name="P:NodaTime.Fields.DateTimeField.IsSupported">
            <summary>
            Defaults to fields being supported
            </summary>
        </member>
        <member name="P:NodaTime.Fields.DateTimeField.IsLenient">
            <summary>
            Returns true if the set method is lenient. If so, it accepts values that
            are out of bounds. For example, a lenient day of month field accepts 32
            for January, converting it to February 1.
            </summary>
        </member>
        <member name="P:NodaTime.Fields.DateTimeField.LeapDurationField">
            <summary>
            Defaults to null, i.e. no leap duration field.
            </summary>
        </member>
        <member name="P:NodaTime.Fields.DecoratedDateTimeField.WrappedField">
            <summary>
            Gets the wrapped date time field.
            </summary>
        </member>
        <member name="T:NodaTime.IClock">
            <summary>
            Represents a clock which can tell the current time as an <see cref="T:NodaTime.Instant"/>.
            </summary>
        </member>
        <member name="P:NodaTime.IClock.Now">
            <summary>
            Gets the current instant in time according to this clock. This is an instant on
            the time line which is independent of both time zone and calendar system.
            </summary>
        </member>
        <member name="T:NodaTime.Format.InstantParse">
            <summary>
              Provides the implementation for parsing strings into <see cref="T:NodaTime.Instant"/> values.
            </summary>
            <remarks>
              The concept and general format for this class comes from the Microsoft system libraries and their
              implementations of parsing of objects like <see cref="T:System.Int32"/> and <see cref="T:System.DateTime"/>.
            </remarks>
        </member>
        <member name="M:NodaTime.Format.InstantParse.Parse(System.String,NodaTime.Globalization.NodaFormatInfo,NodaTime.Format.DateTimeParseStyles)">
            <summary>
              Implements the Parse methods.
            </summary>
            <remarks>
              This attempts to parse the value in each of the valid formats until one matches.
            </remarks>
            <param name="value">The string value to parse.</param>
            <param name="formatInfo">The <see cref="T:System.IFormatProvider"/> to use.</param>
            <param name="styles">The <see cref="T:NodaTime.Format.DateTimeParseStyles"/> flags.</param>
            <returns>The parsed <see cref="T:NodaTime.Instant"/> value.</returns>
            <exception cref="T:System.ArgumentNullException">value is <c>null</c>.</exception>
            <exception cref="T:System.FormatException">value is not a valid <see cref="T:NodaTime.Instant"/> string.</exception>
        </member>
        <member name="M:NodaTime.Format.InstantParse.ParseExact(System.String,System.String,NodaTime.Globalization.NodaFormatInfo,NodaTime.Format.DateTimeParseStyles)">
            <summary>
              Implements the ParseExact methods.
            </summary>
            <remarks>
              This attempts to parse the value in the given format.
            </remarks>
            <param name="value">The string value to parse.</param>
            <param name="format">The format to use.</param>
            <param name="formatInfo">The <see cref="T:System.IFormatProvider"/> to use.</param>
            <param name="styles">The <see cref="T:NodaTime.Format.DateTimeParseStyles"/> flags.</param>
            <returns>The parsed <see cref="T:NodaTime.Instant"/> value.</returns>
            <exception cref="T:System.ArgumentNullException">value or format is <c>null</c>.</exception>
            <exception cref="T:System.FormatException">value is not a valid <see cref="T:NodaTime.Instant"/> string.</exception>
        </member>
        <member name="M:NodaTime.Format.InstantParse.ParseExact(System.String,System.String[],NodaTime.Globalization.NodaFormatInfo,NodaTime.Format.DateTimeParseStyles)">
            <summary>
              Implements the ParseExact methods that take multiple formats.
            </summary>
            <remarks>
              This attempts to parse the value in the given formats. The first one to match is used.
            </remarks>
            <param name="value"></param>
            <param name="formats"></param>
            <param name="formatInfo"></param>
            <param name="styles"></param>
            <returns></returns>
        </member>
        <member name="T:NodaTime.Format.ParseInfo">
            <summary>
              Provides a container for the interim parsed pieces of values.
            </summary>
        </member>
        <member name="M:NodaTime.Format.ParseInfo.#ctor(System.IFormatProvider)">
            <summary>
              Initializes a new instance of the <see cref="T:NodaTime.Format.ParseInfo"/> class.
            </summary>
            <param name="formatProvider">The format info.</param>
        </member>
        <member name="M:NodaTime.Format.ParseInfo.#ctor(System.IFormatProvider,NodaTime.Format.DateTimeParseStyles)">
            <summary>
              Initializes a new instance of the <see cref="T:NodaTime.Format.ParseInfo"/> class.
            </summary>
            <param name="formatProvider">The format info.</param>
            <param name="parseStyles">The parse styles.</param>
        </member>
        <member name="M:NodaTime.Format.ParseInfo.AssignNewValue``1(System.Nullable{``0}@,``0,System.Char)">
            <summary>
              Assigns the new value if the current value is not set.
            </summary>
            <remarks>
              When parsing an object by pattern a particular value (e.g. hours) can only be set once, or if set
              more than once it should be set to the same value. This method checks thatthe value has not been
              previously set or if it has that the new value is the same as the old one. If the new value is
              different than the old one then a failure is set.
            </remarks>
            <typeparam name="T">The base type of the values.</typeparam>
            <param name="currentValue">The current value.</param>
            <param name="newValue">The new value.</param>
            <param name="patternCharacter">The pattern character for the error message if any.</param>
            <returns><c>true</c> if the current value is not set or if the current value equals the new value, <c>false</c> otherwise.</returns>
        </member>
        <member name="P:NodaTime.Format.ParseInfo.AllowInnerWhite">
            <summary>
              Gets a value indicating whether inner white space is allowed.
            </summary>
            <value>
              <c>true</c> if inner white is allowed; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:NodaTime.Format.ParseInfo.AllowLeadingWhite">
            <summary>
              Gets a value indicating whether leading white space is allowed.
            </summary>
            <value>
              <c>true</c> if leading white space is allowed; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:NodaTime.Format.ParseInfo.AllowTrailingWhite">
            <summary>
              Gets a value indicating whether trailing white space is allowed.
            </summary>
            <value>
              <c>true</c> if trailing white space is allowed; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:NodaTime.Format.ParseInfo.FormatInfo">
            <summary>
              Gets the format info object that controls the parsing of the object.
            </summary>
        </member>
        <member name="T:NodaTime.Fields.SkipZeroDateTimeField">
            <summary>
            Field which skips zero. In Joda Time this is more general (SkipDateTimeField)
            but it never skips any value *other* than zero, so that's hard-coded here.
            </summary>
        </member>
        <member name="T:NodaTime.Fields.DelegatedDateTimeField">
            <summary>
            DateTimeField which simply delegates every call to another field, allowing
            selective members to be overridden.
            </summary>
        </member>
        <member name="T:NodaTime.DateTimeZone">
            <summary>
              Represents a time zone.
            </summary>
            <remarks>
              Time zones primarily encapsulate two facts: an offset from UTC and a set of rules on how
              the values are adjusted.
            </remarks>
        </member>
        <member name="F:NodaTime.DateTimeZone.UtcId">
            <summary>
              This is the ID of the UTC (Coordinated Universal Time) time zone.
            </summary>
        </member>
        <member name="F:NodaTime.DateTimeZone.DefaultDateTimeZoneProvider">
            <summary>
            Gets the default time zone provider, which is initialized from resources within the NodaTime assembly.
            </summary>
        </member>
        <member name="M:NodaTime.DateTimeZone.ForId(System.String)">
            <summary>
              Returns the time zone with the given id.
            TODO: Consider whether this should be ForID (as ID is a two-letter abbreviation).
            </summary>
            <param name="id">The time zone id to find.</param>
            <returns>The <see cref="T:NodaTime.DateTimeZone"/> with the given id or <c>null</c> if there isn't one defined.</returns>
        </member>
        <member name="M:NodaTime.DateTimeZone.AddProvider(NodaTime.TimeZones.IDateTimeZoneProvider)">
            <summary>
              Adds the given time zone provider to the front of the provider list.
            </summary>
            <remarks>
              Because this adds the new provider to the from of the list, it will be checked first for
              time zone definitions and therefore can override the default system definitions. This
              allows for adding new or replacing existing time zones without updating the system. If
              the provider is already on the list nothing changes.
            </remarks>
            <param name="provider">The <see cref="T:NodaTime.TimeZones.IDateTimeZoneProvider"/> to add.</param>
        </member>
        <member name="M:NodaTime.DateTimeZone.RemoveProvider(NodaTime.TimeZones.IDateTimeZoneProvider)">
            <summary>
              Removes the given time zone provider from the provider list.
            </summary>
            <remarks>
              If the provider is not on the list nothing changes.
            </remarks>
            <param name="provider">The <see cref="T:NodaTime.TimeZones.IDateTimeZoneProvider"/> to remove.</param>
            <returns><c>true</c> if the provider was removed.</returns>
        </member>
        <member name="M:NodaTime.DateTimeZone.SetUtcOnly(System.Boolean)">
            <summary>
              Sets the UTC time zone only mode.
            </summary>
            <remarks>
              <para>
                If the mode is set to <c>true</c> then only the UTC time zone provider will be available
                and only the UTC time zone will be accessible. This is mainly for use during the
                building of the system when there is no existing time zone database.
              </para>
              <para>
                When this method is called all existing providers are removed from the list. Then the UTC
                provideer will be added and if the <paramref name = "utcOnlyFlag" /> is <c>false</c> then default
                provider. This means that any providers added by user code will be removed. The
                <see cref="P:NodaTime.DateTimeZone.Current" /> setting will also be lost.
              </para>
            </remarks>
            <param name="utcOnlyFlag">if set to <c>true</c> then only the UTC provider will be available.</param>
        </member>
        <member name="M:NodaTime.DateTimeZone.#ctor(System.String,System.Boolean,NodaTime.Offset,NodaTime.Offset)">
            <summary>
              Initializes a new instance of the <see cref="T:NodaTime.DateTimeZone" /> class.
            </summary>
            <param name="id">The unique id of this time zone.</param>
            <param name="isFixed">Set to <c>true</c> if this time zone has no transitions.</param>
            <param name="minOffset">Minimum offset applied within this zone</param>
            <param name="maxOffset">Maximum offset applied within this zone</param>
        </member>
        <member name="M:NodaTime.DateTimeZone.ToIsoChronology">
            <summary>
            Returns a chronology based on this time zone, in the ISO calendar system.
            </summary>
        </member>
        <member name="M:NodaTime.DateTimeZone.GetOffsetFromUtc(NodaTime.Instant)">
            <summary>
              Returns the offset from UTC, where a positive duration indicates that local time is
              later than UTC. In other words, local time = UTC + offset.
            </summary>
            <param name="instant">The instant for which to calculate the offset.</param>
            <returns>
              The offset from UTC at the specified instant.
            </returns>
        </member>
        <member name="M:NodaTime.DateTimeZone.GetZoneInterval(NodaTime.Instant)">
            <summary>
              Gets the zone interval for the given instant. This will never return null.
            </summary>
            <param name="instant">The <see cref="T:NodaTime.Instant" /> to query.</param>
            <returns>The defined <see cref="T:NodaTime.TimeZones.ZoneInterval" />.</returns>
        </member>
        <member name="M:NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.LocalInstant)">
            <summary>
            Finds all zone intervals for the given local instant. Usually there's one (i.e. only a single
            instant is mapped to the given local instant within the time zone) but during DST transitions
            there can be either 0 (the given local instant doesn't exist, e.g. local time skipped from 1am to
            2am, but you gave us 1.30am) or 2 (the given local instant is ambiguous, e.g. local time skipped
            from 2am to 1am, but you gave us 1.30am).
            </summary>
            <remarks>
            This method is implemented in terms of GetZoneInterval(Instant) within DateTimeZone,
            and should work for any zone. However, derived classes may override this method
            for optimization purposes, e.g. if the zone interval is always ambiguous with
            a fixed value.
            </remarks>
            <param name="localInstant">The local instant to find matching zone intervals for</param>
            <returns>The struct containing up to two ZoneInterval references.</returns>
        </member>
        <member name="M:NodaTime.DateTimeZone.Write(NodaTime.TimeZones.DateTimeZoneWriter)">
            <summary>
            Writes the time zone to the specified writer. Used within ZoneInfoCompiler.
            </summary>
            <param name="writer">The writer to write to.</param>
        </member>
        <member name="M:NodaTime.DateTimeZone.AtExactly(NodaTime.LocalDateTime)">
            <summary>
            If the given local date/time is mapped unambiguously to a single ZonedDateTime value, that is returned.
            For ambiguous or skipped local date/time values, AmbiguousTimeException or SkippedTimeException are thrown respectively.
            </summary>
            <exception cref="T:NodaTime.SkippedTimeException">The given LocalDateTime is skipped due to a transition where the clocks go forward</exception>
            <exception cref="T:NodaTime.AmbiguousTimeException">The given LocalDateTime is ambiguous due to a transition where the clocks go forward</exception>
        </member>
        <member name="M:NodaTime.DateTimeZone.AtEarlier(NodaTime.LocalDateTime)">
            <summary>
            If the given local date/time is mapped unambiguously to a single ZonedDateTime value, that is returned.
            For ambiguous local date/time values, the earlier mapping is returned.
            For skipped local date/time values, SkippedTimeException is thrown.
            </summary>
            <exception cref="T:NodaTime.SkippedTimeException">The given LocalDateTime is skipped due to a transition where the clocks go forward</exception>
            <exception cref="T:NodaTime.AmbiguousTimeException">The given LocalDateTime is ambiguous due to a transition where the clocks go forward</exception>
        </member>
        <member name="M:NodaTime.DateTimeZone.AtLater(NodaTime.LocalDateTime)">
            <summary>
            If the given local date/time is mapped unambiguously to a single ZonedDateTime value, that is returned.
            For ambiguous local date/time values, the later mapping is returned.
            For skipped local date/time values, SkippedTimeException is thrown.
            </summary>
            <exception cref="T:NodaTime.SkippedTimeException">The given LocalDateTime is skipped due to a transition where the clocks go forward</exception>
            <exception cref="T:NodaTime.AmbiguousTimeException">The given LocalDateTime is ambiguous due to a transition where the clocks go forward</exception>
        </member>
        <member name="M:NodaTime.DateTimeZone.AtStartOfDay(NodaTime.LocalDate)">
            <summary>
            Returns the ZonedDateTime with a LocalDateTime as early as possible on the given date.
            If midnight exists unambiguously on the given date, it is returned.
            If the given date has an amgbiguous start time (e.g. the clocks go back from 1am to midnight)
            then the earlier ZonedDateTime is returned. If the given date has no midnight (e.g. the clocks
            go forward from midnight to 1am) then the earliest valid value is returned; this will be the instant
            of the transition.
            </summary>
        </member>
        <member name="M:NodaTime.DateTimeZone.MapLocalDateTime(NodaTime.LocalDateTime)">
            <summary>
            Returns complete information about how the given LocalDateTime is mapped in this time zone.
            </summary>
            <remarks>Use this method if you need to know whether the given value is ambiguous, or if you
            want to find out about a potential "gap" in local dates and times due to a daylight saving transition.
            </remarks>
        </member>
        <member name="M:NodaTime.DateTimeZone.GetEarlierMatchingInterval(NodaTime.TimeZones.ZoneInterval,NodaTime.LocalInstant)">
            <summary>
            Returns the interval before this one, if it contains the given local instant, or null otherwise.
            </summary>
        </member>
        <member name="M:NodaTime.DateTimeZone.GetLaterMatchingInterval(NodaTime.TimeZones.ZoneInterval,NodaTime.LocalInstant)">
            <summary>
            Returns the next interval after this one, if it contains the given local instant, or null otherwise.
            </summary>
        </member>
        <member name="M:NodaTime.DateTimeZone.ToString">
            <summary>
              Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
            <returns>
              A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:NodaTime.DateTimeZone.Utc">
            <summary>
              Gets the UTC (Coordinated Universal Time) time zone.
            </summary>
            <value>The UTC <see cref="T:NodaTime.DateTimeZone" />.</value>
        </member>
        <member name="P:NodaTime.DateTimeZone.SystemDefault">
            <summary>
              Gets the system default time zone which can only be changed by the system.
            </summary>
            <remarks>
              <para>
                The time zones defined in the operating system are different than the ones defines in
                this library so a mapping will occur. If an exact mapping can be made then that will be
                used otherwise UTC will be used.
              </para>
            </remarks>
            <value>The system default <see cref="T:NodaTime.DateTimeZone" /> this will never be <c>null</c>.</value>
        </member>
        <member name="P:NodaTime.DateTimeZone.Ids">
            <summary>
              Gets the complete list of valid time zone ids provided by all of the registered
              providers. This list will be sorted in lexigraphical order by the id name.
            </summary>
            <value>The <see cref="T:System.Collections.Generic.IEnumerable`1"/> of string ids.</value>
        </member>
        <member name="P:NodaTime.DateTimeZone.Id">
            <summary>
              The database ID for the time zone.
            </summary>
            <remarks>
              This must be unique across all time zone providers.
            </remarks>
        </member>
        <member name="P:NodaTime.DateTimeZone.IsFixed">
            <summary>
              Indicates whether the time zone is fixed, i.e. contains no transitions.
            </summary>
            <remarks>
              This is used as an optimization. If the time zone has not transitions but returns <c>true</c>
              for this then the behavior will be correct but the system will have to do extra work. However
              if the time zone has transitions and this returns <c>false</c> then the transitions will never
              be examined.
            </remarks>
        </member>
        <member name="P:NodaTime.DateTimeZone.MinOffset">
            <summary>
            Returns the least offset within this time zone.
            </summary>
        </member>
        <member name="P:NodaTime.DateTimeZone.MaxOffset">
            <summary>
            Returns the greatest offset within this time zone.
            </summary>
        </member>
        <member name="T:NodaTime.Fields.GJEraDateTimeField">
            <summary>
            Porting status: needs text
            TODO: Rename to "GregulianEraDateTimeField" or something similar?
            </summary>
        </member>
        <member name="T:NodaTime.Format.FormatError.FormatValueException">
            <summary>
            Thrown when the value could not be parsed and the multiple pattern calls should try
            the next pattern.
            </summary>
        </member>
        <member name="T:NodaTime.Instant">
            <summary>
              Represents an instant on the timeline, measured in ticks from the Unix epoch,
              which is typically described as January 1st 1970, midnight, UTC (ISO calendar).
              (There are 10,000 ticks in a millisecond.)
            </summary>
            <remarks>
              This type is immutable and thread-safe.
            </remarks>
        </member>
        <member name="F:NodaTime.Instant.BeginningOfTimeLabel">
            <summary>
            String used to represent "the beginning of time" (as far as Noda Time is concerned).
            </summary>
        </member>
        <member name="F:NodaTime.Instant.EndOfTimeLabel">
            <summary>
            String used to represent "the end of time" (as far as Noda Time is concerned).
            </summary>
        </member>
        <member name="F:NodaTime.Instant.UnixEpoch">
            <summary>
            The instant at the Unix epoch of midnight 1st January 1970 UTC.
            </summary>
        </member>
        <member name="F:NodaTime.Instant.MinValue">
            <summary>
            The minimum instant value, which is also used to represent the beginning of time.
            </summary>
        </member>
        <member name="F:NodaTime.Instant.MaxValue">
            <summary>
            The maximum instant value, which is also used to represent the end of time.
            </summary>
        </member>
        <member name="M:NodaTime.Instant.#ctor(System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.Instant"/> struct.
            </summary>
            <param name="ticks">The ticks from the unix epoch.</param>
        </member>
        <member name="M:NodaTime.Instant.CompareTo(NodaTime.Instant)">
            <summary>
              Compares the current object with another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
              A 32-bit signed integer that indicates the relative order of the objects being compared.
              The return value has the following meanings:
              <list type = "table">
                <listheader>
                  <term>Value</term>
                  <description>Meaning</description>
                </listheader>
                <item>
                  <term>&lt; 0</term>
                  <description>This object is less than the <paramref name = "other" /> parameter.</description>
                </item>
                <item>
                  <term>0</term>
                  <description>This object is equal to <paramref name = "other" />.</description>
                </item>
                <item>
                  <term>&gt; 0</term>
                  <description>This object is greater than <paramref name = "other" />.</description>
                </item>
              </list>
            </returns>
        </member>
        <member name="M:NodaTime.Instant.Equals(System.Object)">
            <summary>
              Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance;
              otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NodaTime.Instant.GetHashCode">
            <summary>
              Returns a hash code for this instance.
            </summary>
            <returns>
              A hash code for this instance, suitable for use in hashing algorithms and data
              structures like a hash table. 
            </returns>
        </member>
        <member name="M:NodaTime.Instant.op_Addition(NodaTime.Instant,NodaTime.Duration)">
            <summary>
              Implements the operator + (addition) for <see cref="T:NodaTime.Instant"/> + <see cref="T:NodaTime.Duration"/>.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Instant"/> representing the sum of the given values.</returns>
        </member>
        <member name="M:NodaTime.Instant.Plus(NodaTime.Offset)">
            <summary>
              Adds the given offset to this instant, to return a <see cref="T:NodaTime.LocalInstant"/>.
            </summary>
            <remarks>
              This was previously an operator+ implementation, but operators can't be internal.
            </remarks>
            <param name="offset">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.LocalInstant"/> representing the sum of the given values.</returns>
        </member>
        <member name="M:NodaTime.Instant.Add(NodaTime.Instant,NodaTime.Duration)">
            <summary>
              Adds a duration to an instant. Friendly alternative to <c>operator+()</c>.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Instant"/> representing the sum of the given values.</returns>
        </member>
        <member name="M:NodaTime.Instant.op_Subtraction(NodaTime.Instant,NodaTime.Instant)">
            <summary>
              Implements the operator - (subtraction) for <see cref="T:NodaTime.Instant"/> - <see cref="T:NodaTime.Instant"/>.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Instant"/> representing the sum of the given values.</returns>
        </member>
        <member name="M:NodaTime.Instant.op_Subtraction(NodaTime.Instant,NodaTime.Duration)">
            <summary>
              Implements the operator - (subtraction) for <see cref="T:NodaTime.Instant"/> - <see cref="T:NodaTime.Duration"/>.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Instant"/> representing the sum of the given values.</returns>
        </member>
        <member name="M:NodaTime.Instant.Subtract(NodaTime.Instant,NodaTime.Instant)">
            <summary>
              Subtracts one instant from another. Friendly alternative to <c>operator-()</c>.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Duration"/> representing the difference of the given values.</returns>
        </member>
        <member name="M:NodaTime.Instant.Subtract(NodaTime.Instant,NodaTime.Duration)">
            <summary>
              Subtracts a duration from an instant. Friendly alternative to <c>operator-()</c>.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Instant"/> representing the difference of the given values.</returns>
        </member>
        <member name="M:NodaTime.Instant.op_Equality(NodaTime.Instant,NodaTime.Instant)">
            <summary>
              Implements the operator == (equality).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Instant.op_Inequality(NodaTime.Instant,NodaTime.Instant)">
            <summary>
              Implements the operator != (inequality).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are not equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Instant.op_LessThan(NodaTime.Instant,NodaTime.Instant)">
            <summary>
              Implements the operator &lt; (less than).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is less than the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Instant.op_LessThanOrEqual(NodaTime.Instant,NodaTime.Instant)">
            <summary>
              Implements the operator &lt;= (less than or equal).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is less than or equal to the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Instant.op_GreaterThan(NodaTime.Instant,NodaTime.Instant)">
            <summary>
              Implements the operator &gt; (greater than).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is greater than the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Instant.op_GreaterThanOrEqual(NodaTime.Instant,NodaTime.Instant)">
            <summary>
              Implements the operator &gt;= (greater than or equal).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is greater than or equal to the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Instant.FromUtc(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
              Returns a new instant corresponding to the given UTC date and time in the ISO calendar.
              In most cases applications should use <see cref="T:NodaTime.ZonedDateTime"/> to represent a date
              and time, but this method is useful in some situations where an <see cref="T:NodaTime.Instant"/> is
              required, such as time zone testing.
            </summary>
        </member>
        <member name="M:NodaTime.Instant.FromUtc(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
              Returns a new instant corresponding to the given UTC date and
              time in the ISO calendar. In most cases applications should 
              use <see cref="T:NodaTime.ZonedDateTime"/>
              to represent a date and time, but this method is useful in some 
              situations where an Instant is required, such as time zone testing.
            </summary>
        </member>
        <member name="M:NodaTime.Instant.Max(NodaTime.Instant,NodaTime.Instant)">
            <summary>
            Returns the later instant of the given two.
            </summary>
        </member>
        <member name="M:NodaTime.Instant.Min(NodaTime.Instant,NodaTime.Instant)">
            <summary>
            Returns the earlier instant of the given two.
            </summary>
        </member>
        <member name="M:NodaTime.Instant.GetFormatter(System.String,System.IFormatProvider)">
            <summary>
            Compiles the given format pattern string and returns a formatter object that formats
            <see cref="T:NodaTime.Instant"/> objects using the given format and the thread's current culture.
            </summary>
            <param name="format">The format pattern string.</param>
            <param name="formatProvider"></param>
            <returns>An <see cref="T:NodaTime.Format.INodaFormatter`1"/> formatter object.</returns>
        </member>
        <member name="M:NodaTime.Instant.ToString(System.String,System.IFormatProvider)">
            <summary>
              Formats the value of the current instance using the specified format.
            </summary>
            <returns>
              A <see cref="T:System.String" /> containing the value of the current instance in the specified format.
            </returns>
            <param name="format">The <see cref="T:System.String" /> specifying the format to use.
              -or- 
              null to use the default format defined for the type of the <see cref="T:System.IFormattable" /> implementation. 
            </param>
            <param name="formatProvider">The <see cref="T:System.IFormatProvider" /> to use to format the value.
              -or- 
              null to obtain the numeric format information from the current locale setting of the operating system. 
            </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.Instant.ToString">
            <summary>
              Returns a <see cref="T:System.String"/> that represents this instance. Equivilent to
              calling <c>ToString(null)</c>.
            </summary>
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:NodaTime.Instant.ToString(System.String)">
            <summary>
              Formats the value of the current instance using the specified format.
            </summary>
            <returns>
              A <see cref="T:System.String" /> containing the value of the current instance in the specified format.
            </returns>
            <param name="format">The <see cref="T:System.String" /> specifying the format to use.
              -or- 
              null to use the default format defined for the type. 
            </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.Instant.ToString(System.IFormatProvider)">
            <summary>
              Formats the value of the current instance using the specified <see cref="T:System.IFormatProvider"/>.
            </summary>
            <returns>
              A <see cref="T:System.String"/> containing the value of the current instance.
            </returns>
            <param name="formatProvider">The <see cref="T:System.IFormatProvider"/> to use to format the value.
              -or- 
              null to obtain the format information from the current locale setting of the current thread. 
            </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.Instant.Parse(System.String)">
            <summary>
            Parses the given string using the current culture's default format provider.
            </summary>
        </member>
        <member name="M:NodaTime.Instant.Parse(System.String,System.IFormatProvider)">
            <summary>
            Parses the given string using the specified format provider.
            </summary>
        </member>
        <member name="M:NodaTime.Instant.Parse(System.String,System.IFormatProvider,NodaTime.Format.DateTimeParseStyles)">
            <summary>
            Parses the given string using the specified format provider and style.
            </summary>
        </member>
        <member name="M:NodaTime.Instant.ParseExact(System.String,System.String,System.IFormatProvider)">
            <summary>
            Parses the given string using the specified format pattern and format provider.
            </summary>
        </member>
        <member name="M:NodaTime.Instant.ParseExact(System.String,System.String,System.IFormatProvider,NodaTime.Format.DateTimeParseStyles)">
            <summary>
            Parses the given string using the specified format pattern, format provider and style.
            </summary>
        </member>
        <member name="M:NodaTime.Instant.ParseExact(System.String,System.String[],System.IFormatProvider,NodaTime.Format.DateTimeParseStyles)">
            <summary>
            Parses the given string using the specified format patterns, format provider and style.
            </summary>
        </member>
        <member name="M:NodaTime.Instant.TryParse(System.String,NodaTime.Instant@)">
            <summary>
            Attempts to parse the given string using the current culture's default format provider. If the parse is successful,
            the result is stored in the <paramref name="result"/> parameter and the return value is true;
            otherwise <see cref="F:NodaTime.Instant.MinValue"/> is stored in the parameter and the return value is false.
            </summary>
            <returns>true if the value was parsed successfully; false otherwise.</returns>
        </member>
        <member name="M:NodaTime.Instant.TryParse(System.String,System.IFormatProvider,NodaTime.Format.DateTimeParseStyles,NodaTime.Instant@)">
            <summary>
            Attempts to parse the given string using the specified format provider and style.
            If the parse is successful, the result is stored in the <paramref name="result"/> parameter and the return value is true;
            otherwise <see cref="F:NodaTime.Instant.MinValue"/> is stored in the parameter and the return value is false.
            </summary>
            <returns>true if the value was parsed successfully; false otherwise.</returns>
        </member>
        <member name="M:NodaTime.Instant.TryParseExact(System.String,System.String,System.IFormatProvider,NodaTime.Format.DateTimeParseStyles,NodaTime.Instant@)">
            <summary>
            Attempts to parse the given string using the specified format pattern, format provider and style.
            If the parse is successful, the result is stored in the <paramref name="result"/> parameter and the return value is true;
            otherwise <see cref="F:NodaTime.Instant.MinValue"/> is stored in the parameter and the return value is false.
            </summary>
            <returns>true if the value was parsed successfully; false otherwise.</returns>
        </member>
        <member name="M:NodaTime.Instant.TryParseExact(System.String,System.String[],System.IFormatProvider,NodaTime.Format.DateTimeParseStyles,NodaTime.Instant@)">
            <summary>
            Attempts to parse the given string using the specified format patterns, format provider and style.
            If the parse is successful, the result is stored in the <paramref name="result"/> parameter and the return value is true;
            otherwise <see cref="F:NodaTime.Instant.MinValue"/> is stored in the parameter and the return value is false.
            </summary>
            <returns>true if the value was parsed successfully; false otherwise.</returns>
        </member>
        <member name="M:NodaTime.Instant.Equals(NodaTime.Instant)">
            <summary>
              Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
              true if the current object is equal to the <paramref name = "other" /> parameter;
              otherwise, false.
            </returns>
        </member>
        <member name="M:NodaTime.Instant.ToDateTimeUtc">
            <summary>
            Constructs a <see cref="T:System.DateTime"/> from this Instant which has a <see cref="P:System.DateTime.Kind"/>
            of <see cref="F:System.DateTimeKind.Utc"/> and represents the same instant of time as this value.
            </summary>
        </member>
        <member name="M:NodaTime.Instant.ToDateTimeOffset">
            <summary>
            Constructs a <see cref="T:System.DateTimeOffset"/> from this Instant which has an offset of zero.
            </summary>
        </member>
        <member name="M:NodaTime.Instant.FromDateTimeUtc(System.DateTime)">
            <summary>
            Converts a <see cref="T:System.DateTime"/> into a new Instant representing the same instant in time.
            </summary>
            <param name="dateTime">Date and time value which must have a <see cref="P:System.DateTime.Kind"/> of <see cref="F:System.DateTimeKind.Utc"/></param>
            <exception cref="T:System.ArgumentException"><paramref name="dateTime"/> has the wrong <see cref="P:System.DateTime.Kind"/>.</exception>
        </member>
        <member name="P:NodaTime.Instant.Ticks">
            <summary>
            Ticks since the Unix epoch.
            </summary>
        </member>
        <member name="T:NodaTime.Fields.DurationFieldType">
            <summary>
            Indicates the type of a value represented by a <see cref="T:NodaTime.Fields.DurationField"/>.
            </summary>
        </member>
        <member name="F:NodaTime.Fields.DurationFieldType.Eras">
            <summary>
            DurationFieldType for eras.
            </summary>
        </member>
        <member name="F:NodaTime.Fields.DurationFieldType.Centuries">
            <summary>
            DurationFieldType for centuries.
            </summary>
        </member>
        <member name="F:NodaTime.Fields.DurationFieldType.WeekYears">
            <summary>
            DurationFieldType for week-years.
            </summary>
        </member>
        <member name="F:NodaTime.Fields.DurationFieldType.Years">
            <summary>
            DurationFieldType for years.
            </summary>
        </member>
        <member name="F:NodaTime.Fields.DurationFieldType.Months">
            <summary>
            DurationFieldType for months.
            </summary>
        </member>
        <member name="F:NodaTime.Fields.DurationFieldType.Weeks">
            <summary>
            DurationFieldType for weeks.
            </summary>
        </member>
        <member name="F:NodaTime.Fields.DurationFieldType.Days">
            <summary>
            DurationFieldType for days.
            </summary>
        </member>
        <member name="F:NodaTime.Fields.DurationFieldType.HalfDays">
            <summary>
            DurationFieldType for half days.
            </summary>
        </member>
        <member name="F:NodaTime.Fields.DurationFieldType.Hours">
            <summary>
            DurationFieldType for hours.
            </summary>
        </member>
        <member name="F:NodaTime.Fields.DurationFieldType.Minutes">
            <summary>
            DurationFieldType for minutes.
            </summary>
        </member>
        <member name="F:NodaTime.Fields.DurationFieldType.Seconds">
            <summary>
            DurationFieldType for seconds.
            </summary>
        </member>
        <member name="F:NodaTime.Fields.DurationFieldType.Milliseconds">
            <summary>
            DurationFieldType for milliseconds.
            </summary>
        </member>
        <member name="F:NodaTime.Fields.DurationFieldType.Ticks">
            <summary>
            DurationFieldType for ticks.
            </summary>
        </member>
        <member name="T:NodaTime.Format.FormatUtils">
            <summary>
            Utility methods used by formatters.
            FormatUtils is thread-safe and immutable.
            </summary>
        </member>
        <member name="M:NodaTime.Format.FormatUtils.WriteUnpaddedInteger(System.IO.TextWriter,System.Int32)">
            <summary>
            Converts an integer to a string, and writes it to the given writer.
            </summary>
            <remarks>
            This method is optimized for converting small values to strings.
            </remarks>
            <param name="writer">Receives integer converted to a string</param>
            <param name="value">Value to convert to a string</param>
        </member>
        <member name="M:NodaTime.Format.FormatUtils.WritePaddedInteger(System.IO.TextWriter,System.Int32,System.Int32)">
            <summary>
            Converts an integer to a string, prepended with a variable amount of '0'
            pad characters, and writes it to the given writer.
            </summary>
            <remarks>
            This method is optimized for converting small values to strings.
            </remarks>
            <param name="writer">Receives integer converted to a string</param>
            <param name="value">Value to convert to a string</param>
            <param name="size">Minumum amount of significant digits to append(negative sign is not counted)</param>
        </member>
        <member name="T:NodaTime.TimeZones.WindowsToPosixResource">
            <summary>
            Provides a mapping between the time zone ids used by Noda Time (which are the POSIX names)
            and the names used by Microsoft Windows.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.WindowsToPosixResource.#cctor">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.DateTimeZoneResourceProvider"/> class.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.WindowsToPosixResource.GetIdFromWindowsName(System.String)">
            <summary>
            Gets the time zone id from the given Windows time zone name.
            </summary>
            <param name="windowsName">The Windows time zone name.</param>
            <returns>The time zone id or <c>null</c>.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.WindowsToPosixResource.GetWindowsNameFromId(System.String)">
            <summary>
            Gets the Windows time zone name from the given time zone id.
            </summary>
            <param name="id">The time zone id.</param>
            <returns>The Windows time zone name or <c>null</c>.</returns>
        </member>
        <member name="T:NodaTime.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Resources.Format_BadQuote">
            <summary>
              Looks up a localized string similar to Format string is missing a close quote: {0}.
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Resources.FormatDefaultExceptionMessage">
            <summary>
              Looks up a localized string similar to Format error..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Resources.Noda_ArgumentNull">
            <summary>
              Looks up a localized string similar to Argument cannot be null..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Resources.Noda_CannotChangeReadOnly">
            <summary>
              Looks up a localized string similar to Cannot change a read only object..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Resources.Noda_StringEmpty">
            <summary>
              Looks up a localized string similar to The string cannot be empty..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Resources.Noda_StringEmptyOrWhitespace">
            <summary>
              Looks up a localized string similar to The string cannot be empty or only contain white space..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Resources.OffsetPatternFull">
            <summary>
              Looks up a localized string similar to +H:mm:ss.fff.
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Resources.OffsetPatternLong">
            <summary>
              Looks up a localized string similar to +H:mm:ss.
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Resources.OffsetPatternMedium">
            <summary>
              Looks up a localized string similar to +H:mm.
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Resources.OffsetPatternShort">
            <summary>
              Looks up a localized string similar to +H.
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Resources.Parse_CannotParseValue">
            <summary>
              Looks up a localized string similar to The value &quot;{0}&quot; cannot be parsed into an instance of {1} using pattern &quot;{2}&quot;.
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Resources.Parse_DoubleAssignment">
            <summary>
              Looks up a localized string similar to The pattern flag &apos;{0}&apos; cannot appear twice and parse different values..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Resources.Parse_EmptyFormatsArray">
            <summary>
              Looks up a localized string similar to The list of formats cannot be empty..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Resources.Parse_EscapeAtEndOfString">
            <summary>
              Looks up a localized string similar to The format string has an escape character (backslash &apos;\&apos;) at the end of the string..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Resources.Parse_EscapedCharacterMismatch">
            <summary>
              Looks up a localized string similar to The value string does not match an escaped character in the format string: &quot;\{0}&quot;.
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Resources.Parse_ExtraValueCharacters">
            <summary>
              Looks up a localized string similar to The format matches a prefix of the value string but not the entire string. Part not matching: &quot;{0}&quot;..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Resources.Parse_FormatElementInvalid">
            <summary>
              Looks up a localized string similar to The items of the format string array cannot be null or empty..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Resources.Parse_FormatInvalid">
            <summary>
              Looks up a localized string similar to The format string is invalid: &quot;{0}&quot;.
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Resources.Parse_FormatStringEmpty">
            <summary>
              Looks up a localized string similar to The format string is empty..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Resources.Parse_Hour12PatternNotSupported">
            <summary>
              Looks up a localized string similar to The &apos;h&apos; pattern flag (12 hour format) is not supported by the {0} type..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Resources.Parse_MismatchedCharacter">
            <summary>
              Looks up a localized string similar to The value string does not match a simple character in the format string &quot;{0}&quot;..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Resources.Parse_MismatchedNumber">
            <summary>
              Looks up a localized string similar to The value string does not match the required number from the format string &quot;{0}&quot;..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Resources.Parse_MismatchedSpace">
            <summary>
              Looks up a localized string similar to The value string does not match a space in the format string..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Resources.Parse_MissingDecimalSeparator">
            <summary>
              Looks up a localized string similar to The format string contains a decimal separator that does not match the value and the decimal separator is not followed by an &quot;F&quot; pattern character..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Resources.Parse_MissingEndQuote">
            <summary>
              Looks up a localized string similar to The format string is missing the end quote character &quot;{0}&quot;..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Resources.Parse_MissingSign">
            <summary>
              Looks up a localized string similar to The required value sign is missing..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Resources.Parse_NoMatchingFormat">
            <summary>
              Looks up a localized string similar to None of the specified formats matches the given value string..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Resources.Parse_PercentAtEndOfString">
            <summary>
              Looks up a localized string similar to A percent sign (%) appears at the end of the format string..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Resources.Parse_PercentDoubled">
            <summary>
              Looks up a localized string similar to A percent sign (%) is followed by another percent sign in the format string..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Resources.Parse_PositiveSignInvalid">
            <summary>
              Looks up a localized string similar to A positive value sign is not valid at this point..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Resources.Parse_PrecisionNotSupported">
            <summary>
              Looks up a localized string similar to The standard format &quot;{0}&quot; for type {1} does not support a precision..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Resources.Parse_QuotedStringMismatch">
            <summary>
              Looks up a localized string similar to The value string does not match a quoted string in the pattern..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Resources.Parse_RepeatCountExceeded">
            <summary>
              Looks up a localized string similar to There were more consecutive copies of the pattern character &quot;{0}&quot; than the maximum allowed ({1}) in the format string..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Resources.Parse_StandardFormatWhitespace">
            <summary>
              Looks up a localized string similar to The standard format &quot;{0}&quot; for type {1} cannot contain white space..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Resources.Parse_TimeSeparatorMismatch">
            <summary>
              Looks up a localized string similar to The value string does not match a time separator in the format string..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Resources.Parse_UnexpectedEndOfString">
            <summary>
              Looks up a localized string similar to More characters were expected in the parsable string [{0}]..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Resources.Parse_UnknownFailure">
            <summary>
              Looks up a localized string similar to Internal Error: The specified ParseFailureKind is unknown [{0}]..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Resources.Parse_UnknownStandardFormat">
            <summary>
              Looks up a localized string similar to The standard format &quot;{0}&quot; is not valid for the {1} type..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Resources.Parse_ValueOutOfRange">
            <summary>
              Looks up a localized string similar to The value {0} is out of the legal range for the {1} type..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Resources.Parse_ValueStringEmpty">
            <summary>
              Looks up a localized string similar to The value string is empty..
            </summary>
        </member>
        <member name="T:NodaTime.CalendarSystem">
            <summary>
            CalendarSystem provides a skeleton implementation for CalendarSystem.
            Many utility methods are defined, but all fields are unsupported.
            <para>
            CalendarSystem is thread-safe and immutable, and all subclasses must be
            as well.
            </para>
            </summary>
            <remarks>
            This class roughly corresponds to Chronology in Joda Time, although it includes
            the functionality of Chronology, BaseChronology and AssembledChronology all mashed
            together. Unlike Chronology, there's no time zone handling in CalendarSystem - that's
            treated entirely separately to calendaring.
            </remarks>
        </member>
        <member name="M:NodaTime.CalendarSystem.GetGregorianCalendar(System.Int32)">
            <summary>
            Returns a pure proleptic Gregorian calendar system, which defines every
            fourth year as leap, unless the year is divisible by 100 and not by 400.
            This improves upon the Julian calendar leap year rule.
            </summary>
            <remarks>
            Although the Gregorian calendar did not exist before 1582 CE, this
            chronology assumes it did, thus it is proleptic. This implementation also
            fixes the start of the year at January 1, and defines the year zero.
            </remarks>
            <param name="minDaysInFirstWeek">The minimum number of days in the first week of the year.
            When computing the WeekOfWeekYear and WeekYear properties of a particular date, this is
            used to decide at what point the week year changes.</param>
        </member>
        <member name="M:NodaTime.CalendarSystem.GetJulianCalendar(System.Int32)">
            <summary>
            Returns a pure proleptic Julian calendar system, which defines every
            fourth year as leap. This implementation follows the leap year rule
            strictly, even for dates before 8 CE, where leap years were actually
            irregular. In the Julian calendar, year zero does not exist: 1 BCE is
            followed by 1 CE.
            </summary>
            <remarks>
            Although the Julian calendar did not exist before 45 BCE, this chronology
            assumes it did, thus it is proleptic. This implementation also fixes the
            start of the year at January 1.
            </remarks>
            <param name="minDaysInFirstWeek">The minimum number of days in the first week of the year.
            When computing the WeekOfWeekYear and WeekYear properties of a particular date, this is
            used to decide at what point the week year changes.</param>
        </member>
        <member name="M:NodaTime.CalendarSystem.#ctor(System.String,NodaTime.CalendarSystem.FieldAssembler)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.CalendarSystem"/> class.
            </summary>
            <param name="name">The name of the calendar</param>
            <param name="fieldAssembler">Delegate to invoke in order to assemble fields for this calendar.</param>
        </member>
        <member name="M:NodaTime.CalendarSystem.GetDaysInMonth(System.Int32,System.Int32)">
            <summary>
            Returns the number of days in the given month within the given year.
            </summary>
        </member>
        <member name="M:NodaTime.CalendarSystem.IsLeapYear(System.Int32)">
            <summary>
            Returns whether or not the given year is a leap year in this calendar.
            </summary>
            <param name="year"></param>
            <returns></returns>
        </member>
        <member name="M:NodaTime.CalendarSystem.GetLocalInstant(System.Int32,System.Int32,System.Int32,System.Int64)">
            <summary>
            Returns a local instant, formed from the given year, month, day, and ticks values.
            The set of given values must refer to a valid datetime, or else an IllegalArgumentException is thrown.
            <para>
            The default implementation calls upon separate DateTimeFields to
            determine the result. Subclasses are encouraged to provide a more
            efficient implementation.
            </para>
            </summary>
            <param name="year">Year to use</param>
            <param name="monthOfYear">Month to use</param>
            <param name="dayOfMonth">Day of month to use</param>
            <param name="tickOfDay">Tick of day to use</param>
            <returns>A LocalInstant instance</returns>
        </member>
        <member name="M:NodaTime.CalendarSystem.GetLocalInstant(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a local instant, formed from the given year, month, day, 
            hour, minute, second, millisecond and ticks values.
            </summary>
            <para>
            The default implementation calls upon separate DateTimeFields to
            determine the result. Subclasses are encouraged to provide a more
            efficient implementation.
            </para>        
            <param name="year">Year to use</param>
            <param name="monthOfYear">Month to use</param>
            <param name="dayOfMonth">Day of month to use</param>
            <param name="hourOfDay">Hour to use</param>
            <param name="minuteOfHour">Minute to use</param>
            <param name="secondOfMinute">Second to use</param>
            <param name="millisecondOfSecond">Millisecond to use</param>
            <param name="tickOfMillisecond">Tick to use</param>
            <returns>A LocalInstant instance</returns>
        </member>
        <member name="M:NodaTime.CalendarSystem.GetLocalInstant(NodaTime.LocalInstant,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a local instant, formed from the given instant, hour, minute, second, millisecond and ticks values.
            <para>
            The default implementation calls upon separate DateTimeFields to
            determine the result. Subclasses are encouraged to provide a more
            efficient implementation.
            </para>       
            </summary>
            <param name="localInstant">Instant to start from</param>
            <param name="hourOfDay">Hour to use</param>
            <param name="minuteOfHour">Minute to use</param>
            <param name="secondOfMinute">Second to use</param>
            <param name="millisecondOfSecond">Milliscond to use</param>
            <param name="tickOfMillisecond">Tick to use</param>
            <returns>A LocalInstant instance</returns>
        </member>
        <member name="M:NodaTime.CalendarSystem.WithZone(NodaTime.DateTimeZone)">
            <summary>
            Returns the logical combination of this calendar system with the specified time zone.
            </summary>
            <remarks>
            Logically, this is equivalent to just calling the Chronology constructor specifying
            the calendar system and the given time zone. However, in the common case of the ISO
            calendar, we can optimize by caching an ISO chronology with each time zone: the override
            of this method in the ISO calendar system uses this cached representation, avoiding creating
            objects unnecessarily.
            </remarks>
        </member>
        <member name="M:NodaTime.CalendarSystem.GetPeriodValues(NodaTime.LocalInstant,NodaTime.LocalInstant,NodaTime.PeriodType)">
            <summary>
            Gets the values of a period type from an interval.
            </summary>
            <param name="start">The start instant of an interval to query</param>
            <param name="end">The end instant of an interval to query</param>
            <param name="periodType">The period type to use</param>
            <returns>The values of the period extracted from the interval</returns>
        </member>
        <member name="M:NodaTime.CalendarSystem.ToString">
            <summary>
            Converts this calendar system to text by simply returning its name.
            </summary>
        </member>
        <member name="M:NodaTime.CalendarSystem.GetIsoDayOfWeek(NodaTime.LocalInstant)">
            <summary>
            Returns the IsoDayOfWeek corresponding to the day of week for the given local instant
            if this calendar uses ISO days of the week, or throws an InvalidOperationException otherwise.
            </summary>
            <param name="localInstant">The local instant to use to find the day of the week</param>
            <returns>The day of the week as an IsoDayOfWeek</returns>
        </member>
        <member name="P:NodaTime.CalendarSystem.Iso">
            <summary>
            Returns a calendar system that follows the rules of the ISO8601 standard,
            which is compatible with Gregorian for all modern dates.
            </summary>
            <remarks>
            <para>
            When ISO does not define a field, but it can be determined (such as AM/PM) it is included.
            </para>
            <para>
            With the exception of century related fields, the ISO calendar is exactly the
            same as the Gregorian calendar system. In this system, centuries and year
            of century are zero based. For all years, the century is determined by
            dropping the last two digits of the year, ignoring sign. The year of century
            is the value of the last two year digits.
            </para>
            </remarks>
        </member>
        <member name="P:NodaTime.CalendarSystem.Name">
            <summary>
            Gets the name of this calendar system. Each calendar system must have a unique name.
            </summary>
            <value>The calendar system name.</value>
        </member>
        <member name="P:NodaTime.CalendarSystem.UsesIsoDayOfWeek">
            <summary>
            Returns whether the day-of-week field refers to ISO days. If true, types such as LocalDateTime
            can use the IsoDayOfWeek property to avoid using magic numbers. This defaults to true, but can be
            overridden by specific calendars.
            </summary>
        </member>
        <member name="T:NodaTime.CalendarSystem.FieldAssembler">
            <summary>
            Delegate used to construct fields. This is called within the base constructor, before the
            derived class constructor bodies have been run - so it's *somewhat* unsafe to pass "this"
            reference, but derived classes will just need to be careful.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.BasicCalendarSystem.GetTotalTicksByYearMonth(System.Int32,System.Int32)">
            <summary>
            Returns the number of ticks from the start of the given year to the start of the given month.
            TODO: We always add this to the ticks at the start of the year. Why not just do it?
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.BasicCalendarSystem.GetYearTicks(System.Int32)">
            <summary>
            Fetches the start of the year from the cache, or calculates
            and caches it.
            </summary>
        </member>
        <member name="T:NodaTime.Calendars.BasicCalendarSystem.YearInfo">
            <summary>
            Immutable struct containing a year and the first tick of that year.
            This is cached to avoid it being calculated more often than is necessary.
            </summary>
        </member>
        <member name="T:NodaTime.Duration">
            <summary>
            A length of time in ticks. (There are 10,000 ticks in a millisecond.)
            </summary>
            <remarks>
            <para>
            There is no concept of fields, such as days or seconds, as these fields can vary in length.
            A duration may be converted to a <see cref="T:NodaTime.Period"/> to obtain field values. This
            conversion will typically cause a loss of precision.
            </para>
            <para>
            This type is immutable and thread-safe.
            </para>
            </remarks>
        </member>
        <member name="F:NodaTime.Duration.NegativeOne">
            <summary>
            Represents <see cref="T:NodaTime.Duration"/> value equal to negative 1 tick. 
            This field is read-only.
            </summary>
        </member>
        <member name="F:NodaTime.Duration.Zero">
            <summary>
            Represents the zero <see cref="T:NodaTime.Duration"/> value. 
            This field is read-only.
            </summary>
        </member>
        <member name="F:NodaTime.Duration.One">
            <summary>
            Represents the <see cref="T:NodaTime.Duration"/> value equals to 1 tick. 
            This field is read-only.
            </summary>
        </member>
        <member name="F:NodaTime.Duration.MinValue">
            <summary>
            Represents the mimimum <see cref="T:NodaTime.Duration"/> value. 
            This field is read-only.
            </summary>
            <remarks>
            The value of this field is equivalent to <see cref="F:System.Int64.MinValue"/> ticks. 
            The string representation of this value is PT-922337203685.4775808S.
            </remarks>
        </member>
        <member name="F:NodaTime.Duration.MaxValue">
            <summary>
            Represents the maximum <see cref="T:NodaTime.Duration"/> value. 
            This field is read-only.
            </summary>
            <remarks>
            The value of this field is equivalent to <see cref="F:System.Int64.MaxValue"/> ticks. 
            The string representation of this value is PT922337203685.4775807S.
            </remarks>
        </member>
        <member name="F:NodaTime.Duration.OneWeek">
            <summary>
            Represents the <see cref="T:NodaTime.Duration"/> value equals to number of ticks in 1 week.
            This field is constant.
            </summary>
            <remarks>
            The value of this constant is 6,048.000,000,000 ticks.
            </remarks>
        </member>
        <member name="F:NodaTime.Duration.OneDay">
            <summary>
            Represents the <see cref="T:NodaTime.Duration"/> value equals to number of ticks in 1 day.
            This field is constant.
            </summary>
            <remarks>
            The value of this constant is 864 billion ticks; that is, 864,000,000,000 ticks.
            </remarks>
        </member>
        <member name="F:NodaTime.Duration.OneHour">
            <summary>
            Represents the <see cref="T:NodaTime.Duration"/> value equals to number of ticks in 1 hour.
            This field is constant.
            </summary>
            <remarks>
            The value of this constant is 36 billion ticks; that is, 36,000,000,000 ticks.
            </remarks>
        </member>
        <member name="F:NodaTime.Duration.OneMinute">
            <summary>
            Represents the <see cref="T:NodaTime.Duration"/> value equals to number of ticks in 1 minute.
            This field is constant.
            </summary>
            <remarks>
            The value of this constant is 600 million ticks; that is, 600,000,000 ticks.
            </remarks>
        </member>
        <member name="F:NodaTime.Duration.OneSecond">
            <summary>
            Represents the <see cref="T:NodaTime.Duration"/> value equals to number of ticks in 1 second.
            This field is constant.
            </summary>
            <remarks>
            The value of this constant is 10 million ticks; that is, 10,000,000 ticks.
            </remarks>
        </member>
        <member name="F:NodaTime.Duration.OneMillisecond">
            <summary>
            Represents the <see cref="T:NodaTime.Duration"/> value equals to number of ticks in 1 millisecond.
            This field is constant.
            </summary>
            <remarks>
            TThe value of this constant is 10 thousand; that is, 10,000.
            </remarks>
        </member>
        <member name="M:NodaTime.Duration.#ctor(System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.Duration"/> struct.
            </summary>
            <param name="ticks">The number of ticks.</param>
        </member>
        <member name="M:NodaTime.Duration.#ctor(System.Int64,System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.Duration"/> struct as the difference
            betweeen the given ticks. This is effectively <c>new Duration(end - start)</c>.
            </summary>
            <param name="startTicks">The start ticks.</param>
            <param name="endTicks">The end ticks.</param>
        </member>
        <member name="M:NodaTime.Duration.#ctor(NodaTime.Instant,NodaTime.Instant)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.Duration"/> struct as the difference
            betweeen the given <see cref="T:NodaTime.Instant"/> values. This is effectively <c>new
            Duration(end.Ticks - start.Ticks)</c>.
            </summary>
            <param name="start">The start <see cref="T:NodaTime.Instant"/> value.</param>
            <param name="end">The end <see cref="T:NodaTime.Instant"/> value.</param>
        </member>
        <member name="M:NodaTime.Duration.#ctor(NodaTime.Interval)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.Duration"/> struct as the duration of the
            given <see cref="T:NodaTime.Interval"/> object.
            </summary>
            <param name="interval">The interval.</param>
        </member>
        <member name="M:NodaTime.Duration.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
            <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance;
            otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NodaTime.Duration.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data
            structures like a hash table. 
            </returns>
        </member>
        <member name="M:NodaTime.Duration.ToString">
            <summary>
            Gets the value as a <see cref="T:System.String"/> in the ISO8601 duration format including
            only seconds and ticks.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the instance as an ISO8601 string
            </returns>
            <example>
            For example, "PT72.3450000S" represents 1 minute, 12 seconds and 345 milliseconds.
            </example>
        </member>
        <member name="M:NodaTime.Duration.ToString(System.String)">
            <summary>
              Formats the value of the current instance using the specified format.
            </summary>
            <returns>
              A <see cref="T:System.String" /> containing the value of the current instance in the specified format.
            </returns>
            <param name="format">The <see cref="T:System.String" /> specifying the format to use.
              -or- 
              null to use the default format defined for the type of the <see cref="T:System.IFormattable" /> implementation. 
            </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.Duration.ToString(System.IFormatProvider)">
            <summary>
              Formats the value of the current instance using the specified format.
            </summary>
            <returns>
              A <see cref="T:System.String" /> containing the value of the current instance in the specified format.
            </returns>
            <param name="formatProvider">The <see cref="T:System.IFormatProvider" /> to use to format the value.
              -or- 
              null to obtain the format information from the current locale setting of the operating system. 
            </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.Duration.ToString(System.String,System.IFormatProvider)">
            <summary>
              Formats the value of the current instance using the specified format.
            </summary>
            <returns>
              A <see cref="T:System.String" /> containing the value of the current instance in the specified format.
            </returns>
            <param name="format">The <see cref="T:System.String" /> specifying the format to use.
              -or- 
              null to use the default format defined for the type of the <see cref="T:System.IFormattable" /> implementation. 
            </param>
            <param name="formatProvider">The <see cref="T:System.IFormatProvider" /> to use to format the value.
              -or- 
              null to obtain the numeric format information from the current locale setting of the operating system. 
            </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.Duration.op_Addition(NodaTime.Duration,NodaTime.Duration)">
            <summary>
            Implements the operator + (addition).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Duration"/> representing the sum of the given values.</returns>
        </member>
        <member name="M:NodaTime.Duration.Add(NodaTime.Duration,NodaTime.Duration)">
            <summary>
            Adds one duration to another. Friendly alternative to <c>operator+()</c>.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Duration"/> representing the sum of the given values.</returns>
        </member>
        <member name="M:NodaTime.Duration.op_Subtraction(NodaTime.Duration,NodaTime.Duration)">
            <summary>
            Implements the operator - (subtraction).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Duration"/> representing the difference of the given values.</returns>
        </member>
        <member name="M:NodaTime.Duration.Subtract(NodaTime.Duration,NodaTime.Duration)">
            <summary>
            Subtracts one duration from another. Friendly alternative to <c>operator-()</c>.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Duration"/> representing the difference of the given values.</returns>
        </member>
        <member name="M:NodaTime.Duration.op_Division(NodaTime.Duration,System.Int64)">
            <summary>
            Implements the operator / (division).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Duration"/> representing the duration divided by the scale.</returns>
        </member>
        <member name="M:NodaTime.Duration.Divide(NodaTime.Duration,System.Int64)">
            <summary>
            Divides a duration by a number. Friendly alternative to <c>operator/()</c>.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Duration"/> representing the quotient of the given values.</returns>
        </member>
        <member name="M:NodaTime.Duration.op_Multiply(NodaTime.Duration,System.Int64)">
            <summary>
            Implements the operator * (multiplication).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Duration"/> representing the duration multiplied by the scale.</returns>
        </member>
        <member name="M:NodaTime.Duration.op_Multiply(System.Int64,NodaTime.Duration)">
            <summary>
            Implements the operator * (multiplication).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Duration"/> representing the duration multiplied by the scale.</returns>
        </member>
        <member name="M:NodaTime.Duration.Multiply(NodaTime.Duration,System.Int64)">
            <summary>
            Multiplies a duration by a number. Friendly alternative to <c>operator*()</c>.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Duration"/> representing the product of the given values.</returns>
        </member>
        <member name="M:NodaTime.Duration.Multiply(System.Int64,NodaTime.Duration)">
            <summary>
            Multiplies a duration by a number. Friendly alternative to <c>operator*()</c>.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Duration"/> representing the product of the given values.</returns>
        </member>
        <member name="M:NodaTime.Duration.op_Equality(NodaTime.Duration,NodaTime.Duration)">
            <summary>
            Implements the operator == (equality).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Duration.op_Inequality(NodaTime.Duration,NodaTime.Duration)">
            <summary>
            Implements the operator != (inequality).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are not equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Duration.op_LessThan(NodaTime.Duration,NodaTime.Duration)">
            <summary>
            Implements the operator &lt; (less than).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is less than the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Duration.op_LessThanOrEqual(NodaTime.Duration,NodaTime.Duration)">
            <summary>
            Implements the operator &lt;= (less than or equal).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is less than or equal to the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Duration.op_GreaterThan(NodaTime.Duration,NodaTime.Duration)">
            <summary>
            Implements the operator &gt; (greater than).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is greater than the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Duration.op_GreaterThanOrEqual(NodaTime.Duration,NodaTime.Duration)">
            <summary>
            Implements the operator &gt;= (greater than or equal).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is greater than or equal to the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Duration.CompareTo(NodaTime.Duration)">
            <summary>
            Compares the current object with another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            A 32-bit signed integer that indicates the relative order of the objects being compared.
            The return value has the following meanings:
            <list type="table">
            <listheader>
            <term>Value</term>
            <description>Meaning</description>
            </listheader>
            <item>
            <term>&lt; 0</term>
            <description>This object is less than the <paramref name="other"/> parameter.</description>
            </item>
            <item>
            <term>0</term>
            <description>This object is equal to <paramref name="other"/>.</description>
            </item>
            <item>
            <term>&gt; 0</term>
            <description>This object is greater than <paramref name="other"/>.</description>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:NodaTime.Duration.Equals(NodaTime.Duration)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter;
            otherwise, false.
            </returns>
        </member>
        <member name="M:NodaTime.Duration.ToIntervalFrom(NodaTime.Instant)">
            <summary>
            Converts this duration to an <see cref="T:NodaTime.Interval"/> starting at the specified instant.
            </summary>
            <param name="start">The instant to start the interval at</param>
            <returns>An <see cref="T:NodaTime.Interval"/> starting at the specified instant</returns>
        </member>
        <member name="M:NodaTime.Duration.ToIntervalTo(NodaTime.Instant)">
            <summary>
            Converts this duration to an <see cref="T:NodaTime.Interval"/> ending at the specified instant.
            </summary>
            <param name="end">The instant to end the interval at</param>
            <returns>An <see cref="T:NodaTime.Interval"/> ending at the specified instant</returns>
        </member>
        <member name="M:NodaTime.Duration.FromStandardWeeks(System.Int64)">
            <summary>
            Returns a <see cref="T:NodaTime.Duration"/> that represents the given number of standard weeks made
            up from 7 24-hour days.
            </summary>
            <param name="weeks">The number of weeks.</param>
            <returns>A <see cref="T:NodaTime.Duration"/> number of weeks.</returns>
        </member>
        <member name="M:NodaTime.Duration.FromStandardDays(System.Int64)">
            <summary>
            Returns a <see cref="T:NodaTime.Duration"/> that represents the given number of standard days made
            up from 24 hours.
            </summary>
            <param name="days">The number of days.</param>
            <returns>A <see cref="T:NodaTime.Duration"/> number of days.</returns>
        </member>
        <member name="M:NodaTime.Duration.FromHours(System.Int64)">
            <summary>
            Returns a <see cref="T:NodaTime.Duration"/> that represents the given number of hours.
            </summary>
            <param name="hours">The number of hours.</param>
            <returns>A <see cref="T:NodaTime.Duration"/> number of hours.</returns>
        </member>
        <member name="M:NodaTime.Duration.FromMinutes(System.Int64)">
            <summary>
            Returns a <see cref="T:NodaTime.Duration"/> that represents the given number of minutes.
            </summary>
            <param name="minutes">The number of minutes.</param>
            <returns>A <see cref="T:NodaTime.Duration"/> number of minutes.</returns>
        </member>
        <member name="M:NodaTime.Duration.FromSeconds(System.Int64)">
            <summary>
            Returns a <see cref="T:NodaTime.Duration"/> that represents the given number of seconds.
            </summary>
            <param name="seconds">The number of seconds.</param>
            <returns>A <see cref="T:NodaTime.Duration"/> number of seconds.</returns>
        </member>
        <member name="M:NodaTime.Duration.FromMilliseconds(System.Int64)">
            <summary>
            Returns a <see cref="T:NodaTime.Duration"/> that represents the given number of milliseconds.
            </summary>
            <param name="milliseconds">The number of milliseconds.</param>
            <returns>A <see cref="T:NodaTime.Duration"/> number of milliseconds.</returns>
        </member>
        <member name="M:NodaTime.Duration.TryParse(System.String,NodaTime.Duration@)">
            <summary>
            Converts the string representation of a duration to its <see cref="T:NodaTime.Duration"/> equivalent 
            and returns a value that indicates whether the conversion succeeded.
            </summary>
            <param name="value">The value to parse.</param>
            <param name="result">When this method returns, contains an object that represents the duration specified by value,
            or Duration.Zero if the conversion failed. This parameter is passed uninitialized.</param>
            <returns>True if value was converted successfully; otherwise, false.</returns>
        </member>
        <member name="M:NodaTime.Duration.Parse(System.String)">
            <summary>
            Parses the specified value into a <see cref="T:NodaTime.Duration"/>.
            </summary>
            <param name="value">The value to parse.</param>
            <exception cref="T:System.FormatException">If the <paramref name="value"/> is badly formatted.</exception>
            <exception cref="T:System.ArgumentNullException">If the <paramref name="value"/> is <c>null</c>.</exception>
            <returns>The <see cref="T:NodaTime.Duration"/>.</returns>
        </member>
        <member name="P:NodaTime.Duration.Ticks">
            <summary>
            The number of ticks in the duration.
            </summary>
        </member>
        <member name="T:NodaTime.LocalDateTime">
            <summary>
            A date and time in a particular calendar system.
            </summary>
            <remarks>
            <para>
            A LocalDateTime value does not represent an instant on the time line, mostly because it has
            no associated time zone: "November 12th 2009 7pm, ISO calendar" occurred at different
            instants for different people around the world.
            </para>
            <para>
            This type defaults to using the IsoCalendarSystem unless a different calendar system is
            specified.
            </para>
            <para>
            This type is immutable and thread-safe.
            </para>
            </remarks>
        </member>
        <member name="M:NodaTime.LocalDateTime.#ctor(NodaTime.LocalInstant)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.LocalDateTime"/> struct using the ISO
            calendar system.
            </summary>
            <param name="localInstant">The local instant.</param>
        </member>
        <member name="M:NodaTime.LocalDateTime.#ctor(NodaTime.LocalInstant,NodaTime.CalendarSystem)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.LocalDateTime"/> struct.
            </summary>
            <param name="localInstant">The local instant.</param>
            <param name="calendar">The calendar system.</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="calendar"/> is <c>null</c>.</exception>
        </member>
        <member name="M:NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.LocalDateTime"/> struct using the ISO calendar system.
            </summary>
            <param name="year">The year.</param>
            <param name="month">The month.</param>
            <param name="day">The day.</param>
            <param name="hour">The hour.</param>
            <param name="minute">The minute.</param>
        </member>
        <member name="M:NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,NodaTime.CalendarSystem)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.LocalDateTime"/> struct.
            </summary>
            <param name="year">The year.</param>
            <param name="month">The month.</param>
            <param name="day">The day.</param>
            <param name="hour">The hour.</param>
            <param name="minute">The minute.</param>
            <param name="calendar">The calendar.</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="calendar"/> is <c>null</c>.</exception>
        </member>
        <member name="M:NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.LocalDateTime"/> struct using the ISO calendar system.
            </summary>
            <param name="year">The year.</param>
            <param name="month">The month.</param>
            <param name="day">The day.</param>
            <param name="hour">The hour.</param>
            <param name="minute">The minute.</param>
            <param name="second">The second.</param>
        </member>
        <member name="M:NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,NodaTime.CalendarSystem)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.LocalDateTime"/> struct.
            </summary>
            <param name="year">The year.</param>
            <param name="month">The month.</param>
            <param name="day">The day.</param>
            <param name="hour">The hour.</param>
            <param name="minute">The minute.</param>
            <param name="second">The second.</param>
            <param name="calendar">The calendar.</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="calendar"/> is <c>null</c>.</exception>
        </member>
        <member name="M:NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.LocalDateTime"/> struct using the ISO calendar system.
            </summary>
            <param name="year">The year.</param>
            <param name="month">The month.</param>
            <param name="day">The day.</param>
            <param name="hour">The hour.</param>
            <param name="minute">The minute.</param>
            <param name="second">The second.</param>
            <param name="millisecond">The millisecond.</param>
        </member>
        <member name="M:NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,NodaTime.CalendarSystem)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.LocalDateTime"/> struct.
            </summary>
            <param name="year">The year.</param>
            <param name="month">The month.</param>
            <param name="day">The day.</param>
            <param name="hour">The hour.</param>
            <param name="minute">The minute.</param>
            <param name="second">The second.</param>
            <param name="millisecond">The millisecond.</param>
            <param name="calendar">The calendar.</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="calendar"/> is <c>null</c>.</exception>
        </member>
        <member name="M:NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.LocalDateTime"/> struct.
            </summary>
            <param name="year">The year.</param>
            <param name="month">The month.</param>
            <param name="day">The day.</param>
            <param name="hour">The hour.</param>
            <param name="minute">The minute.</param>
            <param name="second">The second.</param>
            <param name="millisecond">The millisecond.</param>
            <param name="tickWithinMillisecond">The tick within millisecond.</param>
        </member>
        <member name="M:NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,NodaTime.CalendarSystem)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.LocalDateTime"/> struct.
            </summary>
            <param name="year">The year.</param>
            <param name="month">The month.</param>
            <param name="day">The day.</param>
            <param name="hour">The hour.</param>
            <param name="minute">The minute.</param>
            <param name="second">The second.</param>
            <param name="millisecond">The millisecond.</param>
            <param name="tickWithinMillisecond">The tick within millisecond.</param>
            <param name="calendar">The calendar.</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="calendar"/> is <c>null</c>.</exception>
        </member>
        <member name="M:NodaTime.LocalDateTime.ToDateTimeUnspecified">
            <summary>
            Constructs a <see cref="T:System.DateTime"/> from this value which has a <see cref="P:System.DateTime.Kind"/>
            of <see cref="F:System.DateTimeKind.Unspecified"/>.
            </summary>
            <remarks>
            <see cref="F:System.DateTimeKind.Unspecified"/> is slightly odd - it can be treated as UTC if you use <see cref="M:System.DateTime.ToLocalTime"/>
            or as system local time if you use <see cref="M:System.DateTime.ToUniversalTime"/>, but it's the only kind which allows
            you to construct a <see cref="T:System.DateTimeOffset"/> with an arbitrary offset, which makes it as close to
            the Noda Time non-system-specific "local" concept as exists in .NET.
            </remarks>
        </member>
        <member name="M:NodaTime.LocalDateTime.FromDateTime(System.DateTime)">
            <summary>
            Converts a <see cref="T:System.DateTime"/> of any kind to a LocalDateTime in the ISO calendar. This does not perform
            any time zone conversions, so a DateTime with a <see cref="P:System.DateTime.Kind"/> of <see cref="F:System.DateTimeKind.Utc"/>
            will still have the same day/hour/minute etc - it won't be converted into the local system time.
            </summary>
        </member>
        <member name="M:NodaTime.LocalDateTime.Equals(NodaTime.LocalDateTime)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.
                            </param>
        </member>
        <member name="M:NodaTime.LocalDateTime.op_Equality(NodaTime.LocalDateTime,NodaTime.LocalDateTime)">
            <summary>
            Implements the operator == (equality).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.op_Inequality(NodaTime.LocalDateTime,NodaTime.LocalDateTime)">
            <summary>
            Implements the operator != (inequality).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are not equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.op_Addition(NodaTime.LocalDateTime,NodaTime.Period)">
            <summary>
            Adds a period to a local date/time. Fields are added in the order provided by the period.
            </summary>
            <param name="localDateTime">Initial local date and time</param>
            <param name="period">Period to add</param>
            <returns>The resulting local date and time</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.op_Subtraction(NodaTime.LocalDateTime,NodaTime.Period)">
            <summary>
            Subtracts a period from a local date/time. Fields are subtracted in the order provided by the period.
            </summary>
            <param name="localDateTime">Initial local date and time</param>
            <param name="period">Period to subtract</param>
            <returns>The resulting local date and time</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
            <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance;
            otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data
            structures like a hash table. 
            </returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.ToString">
            <summary>
            Returns the fully qualified type name of this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> containing a fully qualified type name.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:NodaTime.LocalDateTime.Calendar">
            <summary>
            Gets the calendar system associated with this local date and time.
            </summary>
        </member>
        <member name="P:NodaTime.LocalDateTime.Era">
            <summary>
            Gets the era for this local date and time. The precise meaning of this value depends on the calendar
            system in use.
            </summary>
        </member>
        <member name="P:NodaTime.LocalDateTime.CenturyOfEra">
            <summary>
            Gets the century within the era of this local date and time.
            </summary>
        </member>
        <member name="P:NodaTime.LocalDateTime.Year">
            <summary>
            Gets the year of this local date and time.
            </summary>
        </member>
        <member name="P:NodaTime.LocalDateTime.YearOfCentury">
            <summary>
            Gets the year of this local date and time within its century.
            </summary>
        </member>
        <member name="P:NodaTime.LocalDateTime.YearOfEra">
            <summary>
            Gets the year of this local date and time within its era.
            </summary>
        </member>
        <member name="P:NodaTime.LocalDateTime.WeekYear">
            <summary>
            Gets the "week year" of this local date and time.
            </summary>
            <remarks>
            <para>
            The WeekYear is the year that matches with the WeekOfWeekYear field.
            In the standard ISO8601 week algorithm, the first week of the year
            is that in which at least 4 days are in the year. As a result of this
            definition, day 1 of the first week may be in the previous year.
            The WeekYear allows you to query the effective year for that day
            </para>
            <para>
            For example, January 1st 2011 was a Saturday, so only two days of that week
            (Saturday and Sunday) were in 2011. Therefore January 1st is part of
            week 52 of WeekYear 2010. Conversely, December 31st 2012 is a Monday,
            so is part of week 1 of WeekYear 2013.
            </para>
            </remarks>
        </member>
        <member name="P:NodaTime.LocalDateTime.MonthOfYear">
            <summary>
            Gets the month of this local date and time within the year.
            </summary>
        </member>
        <member name="P:NodaTime.LocalDateTime.WeekOfWeekYear">
            <summary>
            Gets the week within the WeekYear. See <see cref="P:NodaTime.LocalDateTime.WeekYear"/> for more details.
            </summary>
        </member>
        <member name="P:NodaTime.LocalDateTime.DayOfYear">
            <summary>
            Gets the day of this local date and time within the year.
            </summary>
        </member>
        <member name="P:NodaTime.LocalDateTime.DayOfMonth">
            <summary>
            Gets the day of this local date and time within the month.
            </summary>
        </member>
        <member name="P:NodaTime.LocalDateTime.IsoDayOfWeek">
            <summary>
            Gets the week day of this local date and time expressed as an <see cref="T:NodaTime.IsoDayOfWeek"/> value,
            for calendars which use ISO days of the week.
            </summary>
            <exception cref="T:System.InvalidOperationException">The underlying calendar doesn't use ISO days of the week.</exception>
        </member>
        <member name="P:NodaTime.LocalDateTime.DayOfWeek">
            <summary>
            Gets the week day of this local date and time as a number.
            </summary>
            <remarks>
            For calendars using ISO week days, this gives 1 for Monday to 7 for Sunday.
            </remarks>
            <seealso cref="P:NodaTime.LocalDateTime.IsoDayOfWeek"/>
        </member>
        <member name="P:NodaTime.LocalDateTime.HourOfDay">
            <summary>
            Gets the hour of day of this local date and time, in the range 0 to 23 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.LocalDateTime.MinuteOfHour">
            <summary>
            Gets the minute of this local date and time, in the range 0 to 59 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.LocalDateTime.SecondOfMinute">
            <summary>
            Gets the second of this local date and time within the minute, in the range 0 to 59 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.LocalDateTime.SecondOfDay">
            <summary>
            Gets the second of this local date and time within the day, in the range 0 to 86,399 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.LocalDateTime.MillisecondOfSecond">
            <summary>
            Gets the millisecond of this local date and time within the second, in the range 0 to 999 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.LocalDateTime.MillisecondOfDay">
            <summary>
            Gets the millisecond of this local date and time within the day, in the range 0 to 86,399,999 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.LocalDateTime.TickOfMillisecond">
            <summary>
            Gets the tick of this local date and time within the millisceond, in the range 0 to 9,999 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.LocalDateTime.TickOfDay">
            <summary>
            Gets the tick of this local date and time within the day, in the range 0 to 863,999,999,999 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.LocalDateTime.TimeOfDay">
            <summary>
            Gets the time portion of this local date and time as a <see cref="T:NodaTime.LocalTime"/>.
            </summary>
        </member>
        <member name="P:NodaTime.LocalDateTime.Date">
            <summary>
            Gets the date portion of this local date and time as a <see cref="T:NodaTime.LocalDate"/>.
            </summary>
        </member>
        <member name="T:NodaTime.TimeZones.ZoneRecurrenceCollection">
            <summary>
            
            </summary>
            <remarks>
            <para>
            Not immutable, not thread safe. 
            </para>
            </remarks>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrenceCollection.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate
            through the collection.
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrenceCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate
            through the collection.
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrenceCollection.SetFixedSavings(System.String,NodaTime.Offset)">
            <summary>
            Sets the fixed savings for this rule set.
            </summary>
            <param name="nameKey">The name key.</param>
            <param name="savings">The savings <see cref="T:NodaTime.Offset"/>.</param>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrenceCollection.AddRule(NodaTime.TimeZones.ZoneRecurrence)">
            <summary>
            Adds the given rule to the set if it is not already in the set.
            </summary>
            <param name="rule">The rule to add.</param>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrenceCollection.SetUpperLimit(System.Int32,NodaTime.TimeZones.ZoneYearOffset)">
            <summary>
            Sets the inclusive upper limit for where this rule set applies.
            </summary>
            <param name="year">The end year (inclusive).</param>
            <param name="yearOffset">The end point in the year (inclusive).</param>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrenceCollection.GetUpperLimit(NodaTime.Offset)">
            <summary>
            Gets the inclusive upper limit of time that this rule set applies to.
            </summary>
            <param name="savings">The daylight savings value.</param>
            <returns>The <see cref="T:NodaTime.LocalInstant"/> of the upper limit for this rule set.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrenceCollection.Iterator(NodaTime.Instant)">
            <summary>
            Returns an iterator over the transitions defined by this rule set.
            </summary>
            <param name="startingInstant">The starting instant.</param>
            <returns>The <see cref="T:NodaTime.TimeZones.ZoneRecurrenceCollection.TransitionIterator"/> that iterates the transitions.</returns>
        </member>
        <member name="T:NodaTime.TimeZones.ZoneRecurrenceCollection.TransitionIterator">
            <summary>
            Iterates through all of the time transitions starting with the given instant using the
            rules in the RuleSet to generate each one.
            </summary>
            <remarks>
            <para>
            Conceptually a rule set is an expression language that describes a sequence of
            transitions points on a time-line where there are time dicontinuities. This iterator
            takes the rules and generates each transition from a given instant forward through time.
            </para>
            <para>
            This is the most complicated part of the <see cref="T:NodaTime.TimeZones.DateTimeZoneBuilder"/> classes.
            There is no guarentee that the rules will be in any order and even if they were there
            can be two rules, one for when DST starts and one for when DST ends, that generate
            alternate transitions through the years. The basic process asks each rule for the
            earliest transition it can generate that is after the last transition time and then
            returns the earliest of those as the next transition.
            </para>
            <para>
            In order to speed things up a bit (and to support the BuildTailZone functionality) we
            remove each rule as it becomes exhausted. A rule becomes exhausted when the last
            transition time exceeds the end date of the rule. In order to not affect the rule set we
            make a copy of the list when we are created and modify the copy.
            </para>
            <para>
            If there are only two rules left in the list and both are infinite rules then we can
            return a special class that will encapsulate them and save on generating every
            transition for the next hundred years. This is the BuildTailZone functionality.
            </para>
            <para>
            Not immutable, not thread safe. 
            </para>
            </remarks>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrenceCollection.TransitionIterator.#ctor(NodaTime.TimeZones.ZoneRecurrenceCollection,NodaTime.Instant)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.ZoneRecurrenceCollection.TransitionIterator"/> class.
            </summary>
            <param name="ruleSet">The rule set to iterate over.</param>
            <param name="startingInstant">The starting instant.</param>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrenceCollection.TransitionIterator.First">
            <summary>
            Returns the first transition. If called after iteration has started, resets to the
            beginning and returns the first transition.
            </summary>
            <returns>The first <see cref="T:NodaTime.TimeZones.ZoneTransition"/> or <c>null</c> there are none.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrenceCollection.TransitionIterator.Next">
            <summary>
            Returns the next transition if any.
            </summary>
            <returns>The next <see cref="T:NodaTime.TimeZones.ZoneTransition"/> or <c>null</c> if no more.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrenceCollection.TransitionIterator.BuildTailZone(System.String)">
            <summary>
            If there are only two rules left and they are both infinite rules then a <see cref="T:NodaTime.DateTimeZone"/> implementation is returned that encapsulates those rules,
            otherwise null is returned.
            </summary>
            <param name="id">The id of the new <see cref="T:NodaTime.DateTimeZone"/>.</param>
            <returns>The new <see cref="T:NodaTime.DateTimeZone"/> or <c>null</c>.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrenceCollection.TransitionIterator.SetupNext(NodaTime.TimeZones.ZoneTransition)">
            <summary>
            Setups the next iteration by saving off necessary data.
            </summary>
            <param name="transition">The current transition to get the data from.</param>
        </member>
        <member name="T:NodaTime.TimeZones.winmap">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.winmap.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.winmap.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="T:NodaTime.TimeZones.DateTimeZoneWriter">
            <summary>
              Provides an <see cref="T:NodaTime.DateTimeZone"/> writer that simply writes the values
              without any compression. Can be used as a base for implementing specific 
              compression writers by overriding the methods for the types to be compressed.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneWriter.#ctor(System.IO.Stream)">
            <summary>
              Constructs a DateTimeZoneWriter.
            </summary>
            <param name="output">Where to send the serialized output.</param>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneWriter.WriteBoolean(System.Boolean)">
            <summary>
              Writes a boolean value to the stream.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneWriter.WriteCount(System.Int32)">
            <summary>
              Writes the given non-negative integer value to the stream.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneWriter.WriteDictionary(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
              Writes the given dictionary of string to string to the stream.
            </summary>
            <param name="dictionary">The <see cref="T:System.Collections.Generic.IDictionary`2"/> to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneWriter.WriteEnum(System.Int32)">
            <summary>
              Writes an enumeration's integer value to the stream.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneWriter.WriteInstant(NodaTime.Instant)">
            <summary>
              Writes the <see cref="T:NodaTime.Instant"/> value to the stream.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneWriter.WriteInteger(System.Int32)">
            <summary>
              Writes the integer value to the stream.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneWriter.WriteLocalInstant(NodaTime.LocalInstant)">
            <summary>
              Writes the <see cref="T:NodaTime.LocalInstant"/> value to the stream.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneWriter.WriteMilliseconds(System.Int32)">
            <summary>
              Writes the integer milliseconds value to the stream.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneWriter.WriteOffset(NodaTime.Offset)">
            <summary>
              Writes the <see cref="T:NodaTime.Offset"/> value to the stream.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneWriter.WriteString(System.String)">
            <summary>
              Writes the string value to the stream.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneWriter.WriteTicks(System.Int64)">
            <summary>
              Writes the long ticks value to the stream.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneWriter.WriteTimeZone(NodaTime.DateTimeZone)">
            <summary>
              Writes the <see cref="T:NodaTime.DateTimeZone"/> value to the stream.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneWriter.WriteInt16(System.Int16)">
            <summary>
              Writes the given 16 bit integer value to the stream.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneWriter.WriteInt32(System.Int32)">
            <summary>
              Writes the given 32 bit integer value to the stream.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneWriter.WriteInt64(System.Int64)">
            <summary>
              Writes the given 64 bit integer value to the stream.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneWriter.WriteInt8(System.Byte)">
            <summary>
              Writes the given 8 bit integer value to the stream.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="T:NodaTime.TimeZones.DateTimeZoneReader">
            <summary>
              Provides an <see cref="T:NodaTime.DateTimeZone"/> reader that simply reads the values
              without any compression. Can be used as a base for implementing specific 
              compression readers by overriding the methods for the types to be compressed.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneReader.ReadBoolean">
            <summary>
              Reads a boolean value from the stream.
            </summary>
            <remarks>
              The value must have been written by <see cref="M:NodaTime.TimeZones.DateTimeZoneWriter.WriteBoolean(System.Boolean)"/>.
            </remarks>
            <returns>The boolean value.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneReader.ReadCount">
            <summary>
              Reads a non-negative integer value from the stream.
            </summary>
            <remarks>
              The value must have been written by <see cref="M:NodaTime.TimeZones.DateTimeZoneWriter.WriteCount(System.Int32)"/>.
            </remarks>
            <returns>The integer value from the stream.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneReader.ReadDictionary">
            <summary>
              Reads a string to string dictionary value from the stream.
            </summary>
            <remarks>
              The value must have been written by <see cref="M:NodaTime.TimeZones.DateTimeZoneWriter.WriteDictionary(System.Collections.Generic.IDictionary{System.String,System.String})"/>.
            </remarks>
            <returns>The <see cref="T:System.Collections.Generic.IDictionary`2"/> value from the stream.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneReader.ReadEnum">
            <summary>
              Reads an enumeration integer value from the stream.
            </summary>
            <remarks>
              The value must have been written by <see cref="M:NodaTime.TimeZones.DateTimeZoneWriter.WriteEnum(System.Int32)"/>.
            </remarks>
            <returns>The integer value from the stream.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneReader.ReadInstant">
            <summary>
              Reads an <see cref="T:NodaTime.Instant"/> value from the stream.
            </summary>
            <remarks>
              The value must have been written by <see cref="M:NodaTime.TimeZones.DateTimeZoneWriter.WriteInstant(NodaTime.Instant)"/>.
            </remarks>
            <returns>The <see cref="T:NodaTime.Instant"/> value from the stream.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneReader.ReadInteger">
            <summary>
              Reads an integer value from the stream.
            </summary>
            <remarks>
              The value must have been written by <see cref="M:NodaTime.TimeZones.DateTimeZoneWriter.WriteInteger(System.Int32)"/>.
            </remarks>
            <returns>The integer value from the stream.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneReader.ReadLocalInstant">
            <summary>
              Reads an <see cref="T:NodaTime.LocalInstant"/> value from the stream.
            </summary>
            <remarks>
              The value must have been written by <see cref="M:NodaTime.TimeZones.DateTimeZoneWriter.WriteLocalInstant(NodaTime.LocalInstant)"/>.
            </remarks>
            <returns>The <see cref="T:NodaTime.LocalInstant"/> value from the stream.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneReader.ReadMilliseconds">
            <summary>
              Reads an integer millisecond value from the stream.
            </summary>
            <remarks>
              The value must have been written by <see cref="M:NodaTime.TimeZones.DateTimeZoneWriter.WriteMilliseconds(System.Int32)"/>.
            </remarks>
            <returns>The integer millisecond value from the stream.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneReader.ReadString">
            <summary>
              Reads a string value from the stream.
            </summary>
            <remarks>
              The value must have been written by <see cref="M:NodaTime.TimeZones.DateTimeZoneWriter.WriteString(System.String)"/>.
            </remarks>
            <returns>The string value from the stream.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneReader.ReadTicks">
            <summary>
              Reads a long ticks value from the stream.
            </summary>
            <remarks>
              The value must have been written by <see cref="M:NodaTime.TimeZones.DateTimeZoneWriter.WriteTicks(System.Int64)"/>.
            </remarks>
            <returns>The long ticks value from the stream.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneReader.ReadTimeZone(System.String)">
            <summary>
              Reads an <see cref="T:NodaTime.DateTimeZone"/> value from the stream.
            </summary>
            <remarks>
              The value must have been written by <see cref="M:NodaTime.TimeZones.DateTimeZoneWriter.WriteTimeZone(NodaTime.DateTimeZone)"/>.
            </remarks>
            <returns>The <see cref="T:NodaTime.DateTimeZone"/> value from the stream.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneReader.ReadInt16">
            <summary>
              Reads a signed 16 bit integer value from the stream and returns it as an int.
            </summary>
            <returns>The 16 bit int value.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneReader.ReadInt32">
            <summary>
              Reads a signed 32 bit integer value from the stream and returns it as an int.
            </summary>
            <returns>The 32 bit int value.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneReader.ReadInt64">
            <summary>
              Reads a signed 64 bit integer value from the stream and returns it as an long.
            </summary>
            <returns>The 64 bit long value.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneReader.ReadInt8">
            <summary>
              Reads a signed 8 bit integer value from the stream and returns it as an int.
            </summary>
            <returns>The 8 bit int value.</returns>
        </member>
        <member name="T:NodaTime.Fields.TicksDurationField">
            <summary>
            Singleton duration field for a fixed duration of 1 tick.
            </summary>
        </member>
        <member name="T:NodaTime.Fields.DurationField">
            <summary>
            Defines the calculation engine for duration fields.
            The abstract class defines a set of methods that manipulate a tick duration
            with regards to a single field, such as months or seconds. This class is
            threadsafe, and all subclasses must be too.
            </summary>
        </member>
        <member name="M:NodaTime.Fields.DurationField.GetValue(NodaTime.Duration)">
            <summary>
            Get the value of this field from the ticks, which is approximate
            if this field is imprecise.
            </summary>
            <param name="duration">The duration to query, which may be negative</param>
            <returns>The value of the field, in the units of the field, which may be negative</returns>
        </member>
        <member name="M:NodaTime.Fields.DurationField.GetInt64Value(NodaTime.Duration)">
            <summary>
            Get the value of this field from the ticks, which is approximate
            if this field is imprecise.
            </summary>
            <param name="duration">The duration to query, which may be negative</param>
            <returns>The value of the field, in the units of the field, which may be negative</returns>
        </member>
        <member name="M:NodaTime.Fields.DurationField.GetValue(NodaTime.Duration,NodaTime.LocalInstant)">
            <summary>
            Get the value of this field from the duration relative to an
            instant. For precise fields this method produces the same result as for
            the single argument get method.
            <para>
            If the duration is positive, then the instant is treated as a "start instant". 
            If negative, the instant is treated as an "end instant".
            </para>
            </summary>
            <param name="duration">The duration to query, which may be negative</param>
            <param name="localInstant">The start instant to calculate relative to</param>
            <returns>The value of the field, in the units of the field, which may be negative</returns>
        </member>
        <member name="M:NodaTime.Fields.DurationField.GetInt64Value(NodaTime.Duration,NodaTime.LocalInstant)">
            <summary>
            Get the value of this field from the duration relative to an
            instant. For precise fields this method produces the same result as for
            the single argument get method.
            <para>
            If the duration is positive, then the instant is treated as a "start instant". 
            If negative, the instant is treated as an "end instant".
            </para>
            </summary>
            <param name="duration">The duration to query, which may be negative</param>
            <param name="localInstant">the start instant to calculate relative to</param>
            <returns>The value of the field, in the units of the field, which may be negative</returns>
        </member>
        <member name="M:NodaTime.Fields.DurationField.GetDuration(System.Int64)">
            <summary>
            Get the duration of this field from its value, which is
            approximate if this field is imprecise.
            </summary>
            <param name="value">The value of the field, which may be negative</param>
            <returns>The duration that the field represents, which may be negative</returns>
        </member>
        <member name="M:NodaTime.Fields.DurationField.GetDuration(System.Int64,NodaTime.LocalInstant)">
            <summary>
            Get the duration of this field from its value relative to an instant.
            For precise fields this method produces the same result as for
            the single argument GetDuration method.
            <para>
            If the value is positive, then the instant is treated as a "start
            instant". If negative, the instant is treated as an "end instant".
            </para>
            </summary>
            <param name="value">The value of the field, which may be negative</param>
            <param name="localInstant">The instant to calculate relative to</param>
            <returns>The duration that the field represents, which may be negative</returns>
        </member>
        <member name="M:NodaTime.Fields.DurationField.Add(NodaTime.LocalInstant,System.Int32)">
            <summary>
            Adds a duration value (which may be negative) to the instant.
            </summary>
            <param name="localInstant">The local instant to add to</param>
            <param name="value">The value to add, in the units of the field</param>
            <returns>The updated local instant</returns>
        </member>
        <member name="M:NodaTime.Fields.DurationField.Add(NodaTime.LocalInstant,System.Int64)">
            <summary>
            Adds a duration value (which may be negative) to the instant.
            </summary>
            <param name="localInstant">The local instant to add to</param>
            <param name="value">The value to add, in the units of the field</param>
            <returns>The updated local instant</returns>
        </member>
        <member name="M:NodaTime.Fields.DurationField.Subtract(NodaTime.LocalInstant,System.Int32)">
            <summary>
            Subtracts a duration value (which may be negative) from the instant.
            </summary>
            <param name="localInstant">The local instant to subtract from</param>
            <param name="value">The value to subtract, in the units of the field</param>
            <returns>The updated local instant</returns>
        </member>
        <member name="M:NodaTime.Fields.DurationField.Subtract(NodaTime.LocalInstant,System.Int64)">
            <summary>
            Subtracts a duration value (which may be negative) from the instant.
            </summary>
            <param name="localInstant">The local instant to subtract from</param>
            <param name="value">The value to subtract, in the units of the field</param>
            <returns>The updated local instant</returns>
        </member>
        <member name="M:NodaTime.Fields.DurationField.GetDifference(NodaTime.LocalInstant,NodaTime.LocalInstant)">
            <summary>
            Computes the difference between two instants, as measured in the units
            of this field. Any fractional units are dropped from the result. Calling
            GetDifference reverses the effect of calling add. In the following code:
            <code>
            LocalInstant instant = ...
            int v = ...
            int age = GetDifference(Add(instant, v), instant);
            </code>
            The value 'age' is the same as the value 'v'.
            </summary>
            <param name="minuendInstant">The local instant to subtract from</param>
            <param name="subtrahendInstant">The local instant to subtract from minuendInstant</param>
            <returns>The difference in the units of this field</returns>
        </member>
        <member name="M:NodaTime.Fields.DurationField.GetInt64Difference(NodaTime.LocalInstant,NodaTime.LocalInstant)">
            <summary>
            Computes the difference between two instants, as measured in the units
            of this field. Any fractional units are dropped from the result. Calling
            GetDifference reverses the effect of calling add. In the following code:
            <code>
            LocalInstant instant = ...
            long v = ...
            long age = GetInt64Difference(Add(instant, v), instant);
            </code>
            The value 'age' is the same as the value 'v'.
            </summary>
            <param name="minuendInstant">The local instant to subtract from</param>
            <param name="subtrahendInstant">The local instant to subtract from minuendInstant</param>
            <returns>The difference in the units of this field</returns>
        </member>
        <member name="P:NodaTime.Fields.DurationField.FieldType">
            <summary>
            Get the type of the field.
            </summary>
        </member>
        <member name="P:NodaTime.Fields.DurationField.IsSupported">
            <summary>
            Returns true if this field is supported.
            </summary>
        </member>
        <member name="P:NodaTime.Fields.DurationField.IsPrecise">
            <summary>
            Is this field precise. A precise field can calculate its value from
            milliseconds without needing a reference date. Put another way, a
            precise field's unit size is not variable.
            </summary>
        </member>
        <member name="P:NodaTime.Fields.DurationField.UnitTicks">
            <summary>
            Returns the amount of ticks per unit value of this field.
            For example, if this field represents "seconds", then this returns the
            ticks in one second.
            </summary>
        </member>
        <member name="T:NodaTime.Fields.ScaledDurationField">
            <summary>
            TODO: Decide whether this wouldn't be better as a DelegatedDurationField...
            </summary>
        </member>
        <member name="T:NodaTime.Fields.DecoratedDurationField">
            <summary>
            Porting status: Done.
            </summary>
        </member>
        <member name="T:NodaTime.Fields.GJDayOfWeekDateTimeField">
            <summary>
            Porting status: need text.
            </summary>
        </member>
        <member name="T:NodaTime.Fields.PreciseDurationDateTimeField">
            <summary>
            Precise datetime field, which has a precise unit duration field.
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="F:NodaTime.Fields.PreciseDurationDateTimeField.unitTicks">
            <summary>
            The fractional unit in ticks
            </summary>
        </member>
        <member name="M:NodaTime.Fields.PreciseDurationDateTimeField.SetValue(NodaTime.LocalInstant,System.Int64)">
            <summary>
            Sets a value in the milliseconds supplied.
            <para>
            The value of this field will be set.
            If the value is invalid, an exception if thrown.
            </para>
            <para>
            If setting this field would make other fields invalid, then those fields
            may be changed. For example if the current date is the 31st January, and
            the month is set to February, the day would be invalid. Instead, the day
            would be changed to the closest value - the 28th/29th February as appropriate.
            </para>
            </summary>
            <param name="localInstant">The local instant to set in</param>
            <param name="value">The value to set, in the units of the field</param>
            <returns>The updated local instant</returns>
        </member>
        <member name="M:NodaTime.Fields.PreciseDurationDateTimeField.GetMaximumValueForSet(NodaTime.LocalInstant,System.Int64)">
            <summary>
            Called by <see cref="M:NodaTime.Fields.DateTimeField.SetValue(NodaTime.LocalInstant,System.Int64)"/> (and related overloads)
            to get the maximum allowed value. By default, returns GetMaximumValue(localInstant). Override to provide
            a faster implementation.
            </summary>
        </member>
        <member name="P:NodaTime.Fields.PreciseDurationDateTimeField.DurationField">
            <summary>
            Gets the duration per unit value of this field, or UnsupportedDurationField if field has no duration.
            For example, if this
            field represents "hour of day", then the duration is an hour.
            </summary>
        </member>
        <member name="P:NodaTime.Fields.PreciseDurationDateTimeField.IsLenient">
            <summary>
            Returns false by default.
            </summary>
        </member>
        <member name="T:NodaTime.Format.Builder.FormatterBuilder`2.NodaFunc`2">
            <summary>
            Equivalent to Func{T}, but without requiring .NET 3.5. If we ever require .NET 3.5,
            we can remove this.
            </summary>
        </member>
        <member name="M:NodaTime.Format.Builder.FormatterBuilder`2.PatternFormatter.Format(`0)">
            <summary>
            Formats the specified value using the <see cref="T:System.IFormatProvider"/> given when the formatter
            was constructed. This does NOT use the current thread <see cref="T:System.IFormatProvider"/>.
            </summary>
            <param name="value">The value to format.</param>
            <returns>The value formatted as a string.</returns>
        </member>
        <member name="M:NodaTime.Format.Builder.FormatterBuilder`2.PatternFormatter.WithFormatProvider(System.IFormatProvider)">
            <summary>
            Returns a new copy of this formatter that uses the given <see cref="T:System.IFormatProvider"/> for
            formatting instead of the one that this formatter uses.
            </summary>
            <param name="formatProvider">The format provider to use.</param>
            <returns>A new copy of this formatter using the given <see cref="T:System.IFormatProvider"/>.</returns>
        </member>
        <member name="M:NodaTime.Format.Builder.FormatterBuilder`2.PatternFormatter.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:NodaTime.Fields.PreciseDateTimeField">
            <summary>
            Precise datetime field, composed of two precise duration fields.
            </summary>
            <remarks>
            This DateTimeField is useful for defining fields that are composed
            of precise durations, like time of day fields. If either duration field is
            imprecise, then an ImpreciseDateTimeField may be used instead.
            </remarks>
        </member>
        <member name="T:NodaTime.Fields.BasicDayOfYearDateTimeField">
            <summary>
            Porting status: Needs partial and max for set support.
            </summary>
        </member>
        <member name="T:NodaTime.Format.ISignedValue">
            <summary>
              Provides an interface for value objects that are signed.
            </summary>
        </member>
        <member name="P:NodaTime.Format.ISignedValue.IsNegative">
            <summary>
              Gets a value indicating whether this instance is negative.
            </summary>
            <value>
              <c>true</c> if this instance is negative; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:NodaTime.Format.ISignedValue.Sign">
            <summary>
              Gets the sign string.
            </summary>
        </member>
        <member name="T:NodaTime.Chronology">
            <summary>
            A chronology is a calendar system with an associated time zone, for example
            "the ISO calendar in the Europe/London time zone".
            TODO: Make this a struct? The hard work will be done in the calendar system
            and time zone classes.
            </summary>
        </member>
        <member name="M:NodaTime.Chronology.#ctor(NodaTime.DateTimeZone,NodaTime.CalendarSystem)">
            <summary>
            Creates a chronology for the given time zone and calendar system.
            </summary>
        </member>
        <member name="M:NodaTime.Chronology.Equals(NodaTime.Chronology)">
            <summary>
            Compares two chronologies for equality by comparing their time zones and calendar systems.
            </summary>
        </member>
        <member name="M:NodaTime.Chronology.Equals(System.Object)">
            <summary>
            Compares two chronologies for equality by comparing their time zones and calendar systems.
            </summary>
        </member>
        <member name="M:NodaTime.Chronology.GetHashCode">
            <summary>
            Returns a hash code for this chronology by hashing the time zone and calendar.
            </summary>
        </member>
        <member name="M:NodaTime.Chronology.op_Equality(NodaTime.Chronology,NodaTime.Chronology)">
            <summary>
            Implements the operator ==.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:NodaTime.Chronology.op_Inequality(NodaTime.Chronology,NodaTime.Chronology)">
            <summary>
            Implements the operator !=.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="P:NodaTime.Chronology.IsoUtc">
            <summary>
            Gets a reference to a chronology instance for the ISO calendar system in UTC.
            </summary>
        </member>
        <member name="P:NodaTime.Chronology.Zone">
            <summary>
            Gets the time zone of this chronology.
            </summary>
        </member>
        <member name="P:NodaTime.Chronology.Calendar">
            <summary>
            Gets the calendar system of this chronology.
            </summary>
        </member>
        <member name="T:NodaTime.TimeZones.UtcProvider">
            <summary>
            Provides an implementation of <see cref="T:NodaTime.TimeZones.IDateTimeZoneProvider"/> that can find and return
            the UTC time zone.
            </summary>
            <remarks>
            Original name: UTCProvider
            </remarks>
        </member>
        <member name="T:NodaTime.TimeZones.IDateTimeZoneProvider">
            <summary>
            Provides the interface for objects that can retrieve time zone definitions given and id.
            </summary>
            <remarks>
            Original name: Provider. (I felt this was too general, and likely to clash with IOC
            containers etc.)
            </remarks>
        </member>
        <member name="M:NodaTime.TimeZones.IDateTimeZoneProvider.ForId(System.String)">
            <summary>
            Returns the time zone definition associated with the given id.
            </summary>
            <remarks>
            If the time zone does not yet exist, its definition is loaded from where ever this
            provider gets time zone definitions. Time zones should not be cached in the provider as
            they will be cached in <see cref="T:NodaTime.DateTimeZone"/>.
            </remarks>
            <param name="id">The id of the time zone to return.</param>
            <returns>The <see cref="T:NodaTime.DateTimeZone"/> or <c>null</c> if there is no time zone with the given id.</returns>
        </member>
        <member name="P:NodaTime.TimeZones.IDateTimeZoneProvider.Ids">
            <summary>
            Returns an enumeration of the available ids from this provider.
            </summary>
            <value>The <see cref="T:System.Collections.Generic.IEnumerable`1"/> of ids.</value>
        </member>
        <member name="M:NodaTime.TimeZones.UtcProvider.ForId(System.String)">
            <summary>
            Returns the time zone definition associated with the given id.
            </summary>
            <param name="id">The id of the time zone to return.</param>
            <returns>
            The <see cref="T:NodaTime.DateTimeZone"/> or <c>null</c> if there is no time zone with the given id.
            </returns>
            <remarks>
            If the time zone does not yet exist, its definition is loaded from where ever this
            provider gets time zone definitions. Time zones should not be cached in the provider as
            they will be cached in <see cref="T:NodaTime.DateTimeZone"/>.
            </remarks>
        </member>
        <member name="P:NodaTime.TimeZones.UtcProvider.Ids">
            <summary>
            Returns an enumeration of the available ids from this provider.
            </summary>
            <value>The <see cref="T:System.Collections.Generic.IEnumerable`1"/> of ids.</value>
        </member>
        <member name="T:NodaTime.TimeZones.PrecalculatedDateTimeZone">
            <summary>
            Most time zones have a relatively small set of transitions at their start until they finally 
            settle down to either a fixed time zone or a daylight savings time zone. This provides the
            container for the initial zone intervals and a pointer to the time zone that handles all of
            the rest until the end of time.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.PrecalculatedDateTimeZone.#ctor(System.String,System.Collections.Generic.IList{NodaTime.TimeZones.ZoneTransition},NodaTime.Instant,NodaTime.DateTimeZone)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.PrecalculatedDateTimeZone"/> class.
            </summary>
            <param name="id">The id.</param>
            <param name="transitions">The transitions.</param>
            <param name="precalcedEnd">The precalced end.</param>
            <param name="tailZone">The tail zone.</param>
        </member>
        <member name="M:NodaTime.TimeZones.PrecalculatedDateTimeZone.#ctor(System.String,NodaTime.TimeZones.ZoneInterval[],NodaTime.DateTimeZone)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.PrecalculatedDateTimeZone"/> class.
            This is only visible to make testing simpler.
            </summary>
            <param name="id">The id.</param>
            <param name="periods">The periods.</param>
            <param name="tailZone">The tail zone.</param>
        </member>
        <member name="M:NodaTime.TimeZones.PrecalculatedDateTimeZone.ValidatePeriods(NodaTime.TimeZones.ZoneInterval[],NodaTime.DateTimeZone)">
            <summary>
            Validates that all the periods before the tail zone make sense. We have to start at the beginning of time,
            and then have adjoining periods. This is only called in the 
            </summary>
            <remarks>This is only called from the constructors, but is internal to make it easier to test.</remarks>
            <exception cref="T:System.ArgumentException">The periods specified are invalid</exception>
        </member>
        <member name="M:NodaTime.TimeZones.PrecalculatedDateTimeZone.GetZoneInterval(NodaTime.Instant)">
            <summary>
            Gets the zone offset period for the given instant. Null is returned if no period is defined by the time zone
            for the given instant.
            TODO: Is it even possible for a zone to not have a zone interval for a particular instant? It makes no logical
            sense. Suggest we state that this can't happen, and throw an exception...
            </summary>
            <param name="instant">The Instant to test.</param>
            <returns>The defined ZoneOffsetPeriod or <c>null</c>.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.PrecalculatedDateTimeZone.IsCachable">
            <summary>
            Returns true if this time zone is worth caching. Small time zones or time zones with
            lots of quick changes do not work well with <see cref="T:NodaTime.TimeZones.CachedDateTimeZone"/>.
            </summary>
            <returns><c>true</c> if this instance is cachable; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.PrecalculatedDateTimeZone.Write(NodaTime.TimeZones.DateTimeZoneWriter)">
            <summary>
            Writes the time zone to the specified writer.
            </summary>
            <param name="writer">The writer to write to.</param>
        </member>
        <member name="M:NodaTime.TimeZones.PrecalculatedDateTimeZone.Read(NodaTime.TimeZones.DateTimeZoneReader,System.String)">
            <summary>
            Reads the specified reader.
            </summary>
            <param name="reader">The reader.</param>
            <param name="id">The id.</param>
            <returns></returns>
        </member>
        <member name="T:NodaTime.TimeZones.ZoneLocalMapping">
            <summary>
            Complete information about the mapping from a local date and time within a time zone. This is usually
            obtained from a call to <see cref="M:NodaTime.DateTimeZone.MapLocalDateTime(NodaTime.LocalDateTime)"/>
            </summary>
            <remarks>
            <para>
            The result will either be unambiguous (a single ZonedDateTime), ambiguous (two ZonedDateTime values
            which both map to the same LocalDateTime due to the clocks going back at a daylight saving
            transition) or a gap (the given LocalDateTime was skipped in this time zone due to the clocks going
            forward at a daylight saving transition).
            </para>
            <para>
            This type is effectively a discriminated union of the three result types. If you attempt to use a
            property corresponding to a different result type, it will throw InvalidOperationException.
            </para>
            </remarks>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneLocalMapping.#ctor(NodaTime.TimeZones.ZoneLocalMapping.ResultType)">
            <summary>
            Private constructor, called by nested subclasses. Note that this means that the *only*
            implementations can be the nested types here.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneLocalMapping.Type">
            <summary>
            Returns the type of this result, which will always be one of the values defined in the
            <see cref="T:NodaTime.TimeZones.ZoneLocalMapping.ResultType"/> enum.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneLocalMapping.UnambiguousMapping">
            <summary>
            In an unambiguous mapping, returns the sole ZonedDateTime which maps to the original LocalDateTime.
            </summary>
            <exception cref="T:System.InvalidOperationException">The mapping isn't unambiguous.</exception>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneLocalMapping.EarlierMapping">
            <summary>
            In an ambiguous mapping, returns the earlier of the two ZonedDateTimes which map to the original LocalDateTime.
            </summary>
            <exception cref="T:System.InvalidOperationException">The mapping isn't ambiguous.</exception>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneLocalMapping.LaterMapping">
            <summary>
            In an ambiguous mapping, returns the later of the two ZonedDateTimes which map to the original LocalDateTime.
            </summary>
            <exception cref="T:System.InvalidOperationException">The mapping isn't ambiguous.</exception>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneLocalMapping.ZoneIntervalBeforeTransition">
            <summary>
            In a mapping where the original LocalDateTime value is skipped in the time zone,
            returns the time zone interval from before the daylight saving transition.
            </summary>
            <exception cref="T:System.InvalidOperationException">The mapping doesn't skip the original LocalDateTime.</exception>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneLocalMapping.ZoneIntervalAfterTransition">
            <summary>
            In a mapping where the original LocalDateTime value is skipped in the time zone,
            returns the time zone interval from after the daylight saving transition.
            </summary>
            <exception cref="T:System.InvalidOperationException">The mapping doesn't skip the original LocalDateTime.</exception>
        </member>
        <member name="T:NodaTime.TimeZones.ZoneLocalMapping.ResultType">
            <summary>
            The type of result represented by this mapping. The underlying integer value is the same
            as the number of ZonedDateTime values which map to the original LocalDateTime.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.ZoneLocalMapping.ResultType.Skipped">
            <summary>
            The original LocalDateTime was skipped in this time zone due to the clocks going
            forward at a daylight saving transition. Use the ZoneIntervalBeforeTransition and
            ZoneIntervalAfterTransition properties to find out more about the gap.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.ZoneLocalMapping.ResultType.Unambiguous">
            <summary>
            The original LocalDateTime was unambiguous. Use the UnambiguousMapping property
            to obtain the corresponding ZonedDateTime.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.ZoneLocalMapping.ResultType.Ambiguous">
            <summary>
            The original LocalDateTime was ambiguous due to the clocks going back at a daylight saving
            transition. Use the EarlierMapping and LaterMapping properties to obtain the corresponding
            ZonedDateTime values.
            </summary>
        </member>
        <member name="T:NodaTime.TimeZones.ZoneInterval">
            <summary>
              Represents a range of time for which a particular Offset applies.
            </summary>
            <remarks>
              <para>
                This type is immutable and thread-safe.
              </para>
            </remarks>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneInterval.#ctor(System.String,NodaTime.Instant,NodaTime.Instant,NodaTime.Offset,NodaTime.Offset)">
            <summary>
              Initializes a new instance of the <see cref="T:NodaTime.TimeZones.ZoneInterval"/> class.
            </summary>
            <param name="name">The name of this offset period (e.g. PST or PDT).</param>
            <param name="start">The first <see cref="T:NodaTime.Instant"/> that the <paramref name="offset"/> applies.</param>
            <param name="end">The last <see cref="T:NodaTime.Instant"/> (exclusive) that the <paramref name="offset"/> applies.</param>
            <param name="offset">The <see cref="P:NodaTime.TimeZones.ZoneInterval.Offset"/> from UTC for this period including any daylight savings.</param>
            <param name="savings">The <see cref="P:NodaTime.TimeZones.ZoneInterval.Offset"/> daylight savings contribution to the offset.</param>
            <exception cref="T:System.ArgumentException">If <c><paramref name="start"/> &gt;= <paramref name="end"/></c>.</exception>
            <exception cref="T:System.ArgumentNullException">If the <paramref name="name"/> parameter is null.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneInterval.WithStart(NodaTime.Instant)">
            <summary>
            Returns a copy of this zone interval, but with the given start instant.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneInterval.Contains(NodaTime.Instant)">
            <summary>
              Determines whether this period contains the given Instant in its range.
            </summary>
            <remarks>
            Usually this is half-open, i.e. the end is exclusive, but an interval with an end point of "the end of time" 
            is deemed to be inclusive at the end.
            </remarks>
            <param name="instant">The instant to test.</param>
            <returns>
              <c>true</c> if this period contains the given Instant in its range; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneInterval.Contains(NodaTime.LocalInstant)">
            <summary>
              Determines whether this period contains the given LocalInstant in its range.
            </summary>
            <param name="localInstant">The local instant to test.</param>
            <returns>
              <c>true</c> if this period contains the given LocalInstant in its range; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneInterval.Equals(NodaTime.TimeZones.ZoneInterval)">
            <summary>
              Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
              true if the current object is equal to the <paramref name = "other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.
            </param>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneInterval.Equals(System.Object)">
            <summary>
              Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.
            </summary>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />; otherwise, <c>false</c>.
            </returns>
            <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />.</param>
            <exception cref="T:System.NullReferenceException">The <paramref name = "obj" /> parameter is null.</exception>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneInterval.GetHashCode">
            <summary>
              Serves as a hash function for a particular type.
            </summary>
            <returns>
              A hash code for the current <see cref="T:System.Object" />.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneInterval.ToString">
            <summary>
              Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneInterval.Read(NodaTime.TimeZones.DateTimeZoneReader)">
            <summary>
              Reads the specified reader.
            </summary>
            <param name="reader">The reader.</param>
            <returns></returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneInterval.Write(NodaTime.TimeZones.DateTimeZoneWriter)">
            <summary>
              Writes the specified writer.
            </summary>
            <param name="writer">The writer.</param>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneInterval.BaseOffset">
            <summary>
              Gets the base offset for this period. This is the offset without any daylight savings
              contributions.
            </summary>
            <remarks>
              This is effectively <c>Offset - Savings</c>.
            </remarks>
            <value>The base Offset.</value>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneInterval.Duration">
            <summary>
              Gets the duration of this period.
            </summary>
            <remarks>
              This is effectively <c>End - Start</c>.
            </remarks>
            <value>The Duration of this period.</value>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneInterval.End">
            <summary>
              Gets the last Instant (exclusive) that the Offset applies.
            </summary>
            <value>The last Instant (exclusive) that the Offset applies.</value>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneInterval.LocalEnd">
            <summary>
              Gets the end time as a LocalInstant.
            </summary>
            <remarks>
              This is effectively <c>End + Offset</c>.
            </remarks>
            <value>The ending LocalInstant.</value>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneInterval.LocalStart">
            <summary>
              Gets the start time as a LocalInstant.
            </summary>
            <remarks>
              This is effectively <c>Start + Offset</c>.
            </remarks>
            <value>The starting LocalInstant.</value>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneInterval.IsoLocalStart">
            <summary>
            Returns the local start time of the interval, as LocalDateTime
            in the ISO calendar.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneInterval.IsoLocalEnd">
            <summary>
            Returns the local start time of the interval, as LocalDateTime
            in the ISO calendar. This does not include any daylight saving 
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneInterval.Name">
            <summary>
              Gets the name of this offset period (e.g. PST or PDT).
            </summary>
            <value>The name of this offset period (e.g. PST or PDT).</value>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneInterval.Offset">
            <summary>
              Gets the offset from UTC for this period. This includes any daylight savings value.
            </summary>
            <value>The offset from UTC for this period.</value>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneInterval.Savings">
            <summary>
              Gets the daylight savings value for this period.
            </summary>
            <value>The savings value.</value>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneInterval.Start">
            <summary>
              Gets the first Instant that the Offset applies.
            </summary>
            <value>The first Instant that the Offset applies.</value>
        </member>
        <member name="T:NodaTime.Calendars.GregorianCalendarSystem">
            <summary>
            Implements a pure proleptic Gregorian calendar system, which defines every
            fourth year as leap, unless the year is divisible by 100 and not by 400.
            This improves upon the Julian calendar leap year rule.
            </summary>
            <remarks>
            <para>
            Although the Gregorian calendar did not exist before 1582 CE, this
            chronology assumes it did, thus it is proleptic. This implementation also
            fixes the start of the year at January 1, and defines the year zero.
            </para>
            <para>
            This is exposed via <see cref="M:NodaTime.CalendarSystem.GetGregorianCalendar(System.Int32)"/>.
            </para>
            </remarks>
        </member>
        <member name="M:NodaTime.Calendars.GregorianCalendarSystem.GetInstance(System.Int32)">
            <summary>
            Returns the instance of the Gregorian calendar system with the given number of days in the week.
            </summary>
            <param name="minDaysInFirstWeek">The minimum number of days at the start of the year to consider it
            a week in that year as opposed to at the end of the previous year.</param>
        </member>
        <member name="T:NodaTime.Globalization.NodaCultureInfo">
            <summary>
              Provides wrapper around a <see cref="T:System.Globalization.CultureInfo"/> that supports NodaTime formatting information. This allows
              for the <see cref="P:NodaTime.Globalization.NodaCultureInfo.NodaFormatInfo"/> data to be set into the <see cref="P:System.Threading.Thread.CurrentCulture"/>
              so it does not have to be passed around. If the underlying culture info is read only then this is also
              read only. To change it you need to clone it first.
            </summary>
        </member>
        <member name="M:NodaTime.Globalization.NodaCultureInfo.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref="T:NodaTime.Globalization.NodaCultureInfo"/> class.
            </summary>
            <param name="name">The name of the base culture.</param>
        </member>
        <member name="M:NodaTime.Globalization.NodaCultureInfo.#ctor(System.String,System.Boolean)">
            <summary>
              Initializes a new instance of the <see cref="T:NodaTime.Globalization.NodaCultureInfo"/> class.
            </summary>
            <param name="name">The name of the base culture.</param>
            <param name="useUserOverride">A Boolean that denotes whether to use the user-selected culture settings (true) or the default culture settings (false).</param>
        </member>
        <member name="M:NodaTime.Globalization.NodaCultureInfo.#ctor(System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:NodaTime.Globalization.NodaCultureInfo"/> class.
            </summary>
            <param name="culture">A predefined <see cref="T:System.Globalization.CultureInfo"/> identifier, <see cref="P:System.Globalization.CultureInfo.LCID"/> property of an existing <see cref="T:System.Globalization.CultureInfo"/> object, or Windows-only culture identifier.</param>
        </member>
        <member name="M:NodaTime.Globalization.NodaCultureInfo.#ctor(System.Int32,System.Boolean)">
            <summary>
              Initializes a new instance of the <see cref="T:NodaTime.Globalization.NodaCultureInfo"/> class.
            </summary>
            <param name="culture">A predefined <see cref="T:System.Globalization.CultureInfo"/> identifier, <see cref="P:System.Globalization.CultureInfo.LCID"/> property of an existing <see cref="T:System.Globalization.CultureInfo"/> object, or Windows-only culture identifier.</param>
            <param name="useUserOverride">A Boolean that denotes whether to use the user-selected culture settings (true) or the default culture settings (false).</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
              <paramref name="culture"/> is less than zero.
            </exception>
            <exception cref="T:System.ArgumentException">
              <paramref name="culture"/> is not a valid culture identifier.
              -or-
              In .NET Compact Framework applications, <paramref name="culture"/> is not supported by the operating system of the device.
            </exception>
        </member>
        <member name="M:NodaTime.Globalization.NodaCultureInfo.Clone">
            <summary>
              Creates a copy of the current <see cref="T:System.Globalization.CultureInfo" />.
            </summary>
            <returns>
              A copy of the current <see cref="T:System.Globalization.CultureInfo" />.
            </returns>
        </member>
        <member name="M:NodaTime.Globalization.NodaCultureInfo.GetFormat(System.Type)">
            <summary>
              Gets an object that defines how to format the specified type.
            </summary>
            <param name="formatType">The <see cref="T:System.Type" /> for which to get a formatting object. This method only supports the <see cref="T:System.Globalization.NumberFormatInfo" /> and <see cref="T:System.Globalization.DateTimeFormatInfo" /> types.</param>
            <returns>
              The value of the <see cref="P:System.Globalization.CultureInfo.NumberFormat" /> property, which is a <see cref="T:System.Globalization.NumberFormatInfo" /> containing the default number format information for the current <see cref="T:System.Globalization.CultureInfo" />, if <paramref name = "formatType" /> is the <see cref="T:System.Type" /> object for the <see cref="T:System.Globalization.NumberFormatInfo" /> class.
              -or-
              The value of the <see cref="P:System.Globalization.CultureInfo.DateTimeFormat" /> property, which is a <see cref="T:System.Globalization.DateTimeFormatInfo" /> containing the default date and time format information for the current <see cref="T:System.Globalization.CultureInfo" />, if <paramref name = "formatType" /> is the <see cref="T:System.Type" /> object for the <see cref="T:System.Globalization.DateTimeFormatInfo" /> class.
              -or-
              null, if <paramref name = "formatType" /> is any other object.
            </returns>
        </member>
        <member name="M:NodaTime.Globalization.NodaCultureInfo.GetCultureInfo(System.Int32)">
            <summary>
              Gets the culture info.
            </summary>
            <param name="culture">The culture.</param>
            <returns></returns>
        </member>
        <member name="M:NodaTime.Globalization.NodaCultureInfo.GetCultureInfo(System.String)">
            <summary>
              Gets the culture info.
            </summary>
            <param name="name">The name.</param>
            <returns></returns>
        </member>
        <member name="M:NodaTime.Globalization.NodaCultureInfo.ToString">
            <summary>
              Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="P:NodaTime.Globalization.NodaCultureInfo.InvariantCulture">
            <summary>
              Gets the invariant culture.
            </summary>
            <value>The invariant culture.</value>
        </member>
        <member name="P:NodaTime.Globalization.NodaCultureInfo.NodaFormatInfo">
            <summary>
              Gets or sets the noda format info of this object.
            </summary>
            <value>
              The <see cref="P:NodaTime.Globalization.NodaCultureInfo.NodaFormatInfo"/> value. This will never be <c>null</c>.
            </value>
        </member>
        <member name="P:NodaTime.Globalization.NodaCultureInfo.Parent">
            <summary>
              Gets the <see cref="T:System.Globalization.CultureInfo" /> that represents the parent culture of the current
              <see cref="T:System.Globalization.CultureInfo" />.
            </summary>
            <value></value>
            <returns>
              The <see cref="T:System.Globalization.CultureInfo" /> that represents the parent culture of the current
              <see cref="T:System.Globalization.CultureInfo" />.
            </returns>
        </member>
        <member name="T:NodaTime.AmbiguousTimeException">
            <summary>
            Exception thrown to indicate that the specified local time occurs twice
            in a particular time zone due to daylight saving time changes.    
            </summary>
            <remarks>
            <para>
            This occurs for fall transitions, where the clock goes backward
            (usually by an hour). For example, suppose the time zone goes backward
            at 2am, so the second after 01:59:59 becomes 01:00:00. In that case,
            times such as 01:30:00 occur twice.
            </para>
            <para>
            This exception is used to indicate such problems, as they're usually
            not the same as other <see cref="T:System.ArgumentOutOfRangeException"/> causes,
            such as entering "15" for a month number.
            </para>
            <para>
            In theory this isn't calendar-specific; the local instant will be ambiguous in
            this time zone regardless of the calendar used. However, this exception is
            always created in conjunction with a specific calendar, which leads to a more
            natural way of examining its information and constructing an error message.
            </para>
            </remarks>
        </member>
        <member name="M:NodaTime.AmbiguousTimeException.#ctor(NodaTime.LocalDateTime,NodaTime.DateTimeZone,NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)">
            <summary>
            Constructs an instance from the given information.
            </summary>
            <remarks>
            User code is unlikely to need to deliberately call this constructor except
            possibly for testing.
            </remarks>
        </member>
        <member name="P:NodaTime.AmbiguousTimeException.LocalDateTime">
            <summary>
            The local date and time which is ambiguous in the time zone.
            </summary>
        </member>
        <member name="P:NodaTime.AmbiguousTimeException.Zone">
            <summary>
            The time zone in which the local date and time is ambiguous.
            </summary>
        </member>
        <member name="P:NodaTime.AmbiguousTimeException.EarlierMapping">
            <summary>
            The earlier of the two occurrences of the local date and time within the time zone.
            </summary>
        </member>
        <member name="P:NodaTime.AmbiguousTimeException.LaterMapping">
            <summary>
            The later of the two occurrences of the local date and time within the time zone.
            </summary>
        </member>
        <member name="T:NodaTime.TimeZones.DateTimeZoneResourceProvider">
            <summary>
            Provides an implementation of a <see cref="T:NodaTime.TimeZones.IDateTimeZoneProvider"/> that looks
            for its time zone definitions from a named resource in an assembly.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.DateTimeZoneResourceProvider.IdMapKey">
            <summary>
            The key used to find ID mappings within the resource.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneResourceProvider.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.DateTimeZoneResourceProvider"/> class.
            </summary>
            <param name="baseName">GetName of the base.</param>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneResourceProvider.#ctor(System.String,System.Reflection.Assembly)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.DateTimeZoneResourceProvider"/> class.
            </summary>
            <param name="baseName">GetName of the base.</param>
            <param name="assembly">The assembly to search for the time zone resources.</param>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneResourceProvider.#ctor(System.Resources.ResourceManager)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.DateTimeZoneResourceProvider"/> class.
            </summary>
            <param name="source">The <see cref="T:System.Resources.ResourceManager"/> to search for the time zone resources.</param>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneResourceProvider.#ctor(System.Resources.ResourceSet)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.DateTimeZoneResourceProvider"/> class.
            </summary>
            <param name="source">The <see cref="T:System.Resources.ResourceSet"/> to search for the time zone resources.</param>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneResourceProvider.ForId(System.String)">
            <summary>
            Returns the time zone definition associated with the given id.
            </summary>
            <param name="id">The id of the time zone to return.</param>
            <returns>
            The <see cref="T:NodaTime.DateTimeZone"/> or <c>null</c> if there is no time zone with the given id.
            </returns>
            <remarks>
            If the time zone does not yet exist, its definition is loaded from where ever this
            provider gets time zone definitions. Time zones should not be cached in the provider as
            they will be cached in <see cref="T:NodaTime.DateTimeZone"/>.
            </remarks>
        </member>
        <member name="P:NodaTime.TimeZones.DateTimeZoneResourceProvider.Ids">
            <summary>
            Returns a sequence of the available IDs from this provider.
            </summary>
        </member>
        <member name="T:NodaTime.TimeZones.ZoneRecurrence">
            <summary>
            Extends <see cref="T:NodaTime.TimeZones.ZoneYearOffset"/> with a name and savings.
            </summary>
            <remarks>
            <para>
            This represents a recurring transition from or to a daylight savings time. The name is the
            name of the time zone during this period (e.g. PST or PDT). The savings is usually 0 or the
            daylight offset. This is also used to support some of the tricky transitions that occurred
            before that calendars were "standardized."
            </para>
            <para>
            Immutable, thread safe.
            </para>
            </remarks>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrence.#ctor(System.String,NodaTime.Offset,NodaTime.TimeZones.ZoneYearOffset,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.ZoneRecurrence"/> class.
            </summary>
            <param name="name">The name of the time zone period e.g. PST.</param>
            <param name="savings">The savings for this period.</param>
            <param name="yearOffset">The year offset of when this period starts in a year.</param>
            <param name="fromYear">The first year in which this recurrence is valid</param>
            <param name="toYear">The last year in which this recurrence is valid</param>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrence.Equals(NodaTime.TimeZones.ZoneRecurrence)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter;
            otherwise, false.
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrence.op_Equality(NodaTime.TimeZones.ZoneRecurrence,NodaTime.TimeZones.ZoneRecurrence)">
            <summary>
            Implements the operator ==.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrence.op_Inequality(NodaTime.TimeZones.ZoneRecurrence,NodaTime.TimeZones.ZoneRecurrence)">
            <summary>
            Implements the operator !=.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrence.Next(NodaTime.Instant,NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Returns the given instant adjusted one year forward taking into account leap years and other
            adjustments like day of week.
            </summary>
            <remarks>
            If the given instant is before the starting year, the year of the given instant is
            adjusted to the beginning of the starting year. The then first transition after the
            adjusted instant is determined. If the next adjustment is after the ending year the
            input instant is returned otherwise the next transition is returned.
            </remarks>
            <param name="instant">The <see cref="T:NodaTime.Instant"/> lower bound for the next trasnition.</param>
            <param name="standardOffset">The <see cref="T:NodaTime.Offset"/> standard offset.</param>
            <param name="previousSavings">The <see cref="T:NodaTime.Offset"/> savings adjustment at the given Instant.</param>
            <returns></returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrence.Previous(NodaTime.Instant,NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Returns the given instant adjusted one year backward taking into account leap years and other
            adjustments like day of week.
            </summary>
            <param name="instant">The <see cref="T:NodaTime.Instant"/> lower bound for the next trasnition.</param>
            <param name="standardOffset">The <see cref="T:NodaTime.Offset"/> standard offset.</param>
            <param name="previousSavings">The <see cref="T:NodaTime.Offset"/> savings adjustment at the given Instant.</param>
            <returns></returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrence.RenameAppend(System.String)">
            <summary>
            Returns a new <see cref="T:NodaTime.TimeZones.ZoneRecurrence"/> with the same settings and given suffix appended
            to the original name. Used to created "-Summer" versions of conflicting recurrences.
            </summary>
            <param name="suffix">The suffix to append to the name key.</param>
            <returns>The newly created <see cref="T:NodaTime.TimeZones.ZoneRecurrence"/> with the new name.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrence.Write(NodaTime.TimeZones.DateTimeZoneWriter)">
            <summary>
            Writes this object to the given <see cref="T:NodaTime.TimeZones.DateTimeZoneWriter"/>.
            </summary>
            <param name="writer">Where to send the output.</param>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrence.Read(NodaTime.TimeZones.DateTimeZoneReader)">
            <summary>
            Reads the specified reader.
            </summary>
            <param name="reader">The reader.</param>
            <returns></returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrence.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
            <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance;
            otherwise, <c>false</c>.
            </returns>
            <exception cref="T:System.NullReferenceException">
            The <paramref name="obj"/> parameter is null.
            </exception>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrence.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data
            structures like a hash table. 
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrence.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrence.ToStartOfTime">
            <summary>
            Returns either "this" (if this zone recurrence already has a from year of int.MinValue)
            or a new zone recurrence which is identical but with a from year of int.MinValue.
            </summary>
        </member>
        <member name="T:NodaTime.TimeZones.DateTimeZoneCompressionReader">
            <summary>
              A very specific compressing binary stream reader for time zones.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneCompressionReader.#ctor(System.IO.Stream)">
            <summary>
              Initializes a new instance of the <see cref="T:NodaTime.TimeZones.DateTimeZoneCompressionReader"/> class.
            </summary>
            <param name="stream">The stream to read from.</param>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneCompressionReader.ReadCount">
            <summary>
              Reads a non-negative integer value from the stream.
            </summary>
            <remarks>
              The value must have been written by <see cref="M:NodaTime.TimeZones.DateTimeZoneWriter.WriteCount(System.Int32)"/>.
            </remarks>
            <returns>The integer value from the stream.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneCompressionReader.ReadMilliseconds">
            <summary>
              Reads an integer millisecond value from the stream.
            </summary>
            <remarks>
              The value must have been written by <see cref="M:NodaTime.TimeZones.DateTimeZoneWriter.WriteMilliseconds(System.Int32)"/>.
            </remarks>
            <returns>The integer millisecond value from the stream.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneCompressionReader.ReadTicks">
            <summary>
              Reads a long ticks value from the stream.
            </summary>
            <remarks>
              The value must have been written by <see cref="M:NodaTime.TimeZones.DateTimeZoneWriter.WriteTicks(System.Int64)"/>.
            </remarks>
            <returns>The long ticks value from the stream.</returns>
        </member>
        <member name="T:NodaTime.PeriodType">
            <summary>
            Controls a period implementation by specifying which duration fields are to be used.
            </summary>
            <remarks>
            The properties are effectively singletons - accessing the same property
            twice will return the same reference both times. New instances are created with the
            WithXXXRemoved methods.
            TODO: Consider implementing operator- and operator+?
            </remarks>
        </member>
        <member name="M:NodaTime.PeriodType.BuildIndices(NodaTime.Fields.DurationFieldType[])">
            <summary>
            Builds a set of indexes from the given field types, to avoid having to specify them
            in all the static variable initializers. This doesn't have to be particularly fast,
            as it's not called often.
            </summary>
        </member>
        <member name="M:NodaTime.PeriodType.IndexOf(NodaTime.Fields.DurationFieldType)">
            <summary>
            Gets the index of the field in this period.
            </summary>
            <param name="fieldType">The type to check; may be null which returns -1</param>
            <returns>The index or -1 if not supported</returns>
        </member>
        <member name="M:NodaTime.PeriodType.IsSupported(NodaTime.Fields.DurationFieldType)">
            <summary>
            Checks whether the field specified is supported by this period.
            </summary>
            <param name="fieldType">The type to check, may be null which returns false</param>
            <returns>True if the field is supported, false otherwise</returns>
        </member>
        <member name="M:NodaTime.PeriodType.WithYearsRemoved">
            <summary>
            Returns a version of this PeriodType instance that does not support years.
            </summary>
            <returns>A new period type that supports the original set of fields except years</returns>
        </member>
        <member name="M:NodaTime.PeriodType.WithMonthsRemoved">
            <summary>
            Returns a version of this PeriodType instance that does not support months.
            </summary>
            <returns>A new period type that supports the original set of fields except months</returns>
        </member>
        <member name="M:NodaTime.PeriodType.WithWeeksRemoved">
            <summary>
            Returns a version of this PeriodType instance that does not support weeks.
            </summary>
            <returns>A new period type that supports the original set of fields except weeks</returns>
        </member>
        <member name="M:NodaTime.PeriodType.WithDaysRemoved">
            <summary>
            Returns a version of this PeriodType instance that does not support days.
            </summary>
            <returns>A new period type that supports the original set of fields except days</returns>
        </member>
        <member name="M:NodaTime.PeriodType.WithHoursRemoved">
            <summary>
            Returns a version of this PeriodType instance that does not support hours.
            </summary>
            <returns>A new period type that supports the original set of fields except hours</returns>
        </member>
        <member name="M:NodaTime.PeriodType.WithMinutesRemoved">
            <summary>
            Returns a version of this PeriodType instance that does not support minutes.
            </summary>
            <returns>A new period type that supports the original set of fields except minutes</returns>
        </member>
        <member name="M:NodaTime.PeriodType.WithSecondsRemoved">
            <summary>
            Returns a version of this PeriodType instance that does not support seconds.
            </summary>
            <returns>A new period type that supports the original set of fields except seconds</returns>
        </member>
        <member name="M:NodaTime.PeriodType.WithMillisecondsRemoved">
            <summary>
            Returns a version of this PeriodType instance that does not support milliseconds.
            </summary>
            <returns>A new period type that supports the original set of fields except milliseconds</returns>
        </member>
        <member name="M:NodaTime.PeriodType.WithTicksRemoved">
            <summary>
            Returns a version of this PeriodType instance that does not support ticks.
            </summary>
            <returns>A new period type that supports the original set of fields except ticks</returns>
        </member>
        <member name="M:NodaTime.PeriodType.Equals(NodaTime.PeriodType)">
            <summary>
            Compares this object with another <see cref="T:NodaTime.PeriodType"/> for equality.
            </summary>
            <returns>True if <paramref name="other"/> consists of the same field types as this period type; False otherwise.</returns>
        </member>
        <member name="M:NodaTime.PeriodType.Equals(System.Object)">
            <summary>
            Compares this object with another for equality.
            </summary>
            <returns>True if <paramref name="obj"/> is a <see cref="T:NodaTime.PeriodType"/> consisting of the same field types; False otherwise.</returns>
        </member>
        <member name="M:NodaTime.PeriodType.GetHashCode">
            <summary>
            Returns the hash code for this period type, based on the field types within it.
            </summary>
        </member>
        <member name="M:NodaTime.PeriodType.op_Equality(NodaTime.PeriodType,NodaTime.PeriodType)">
            <summary>
            Compares two period types for equality.
            </summary>
        </member>
        <member name="M:NodaTime.PeriodType.op_Inequality(NodaTime.PeriodType,NodaTime.PeriodType)">
            <summary>
            Compares two period types for inequality.
            </summary>
        </member>
        <member name="M:NodaTime.PeriodType.ToString">
            <summary>
            Returns a text representation of this period type.
            </summary>
        </member>
        <member name="M:NodaTime.PeriodType.GetEnumerator">
            <summary>
            Returns an iterator over the field types within this period.
            </summary>
        </member>
        <member name="P:NodaTime.PeriodType.Years">
            <summary>Gets a type that defines just the years field.</summary>
        </member>
        <member name="P:NodaTime.PeriodType.Months">
            <summary>Gets a type that defines just the months field.</summary>
        </member>
        <member name="P:NodaTime.PeriodType.Weeks">
            <summary>Gets a type that defines just the weeks field.</summary>
        </member>
        <member name="P:NodaTime.PeriodType.Days">
            <summary>Gets a type that defines just the days field.</summary>
        </member>
        <member name="P:NodaTime.PeriodType.Hours">
            <summary>Gets a type that defines just the hours field.</summary>
        </member>
        <member name="P:NodaTime.PeriodType.Minutes">
            <summary>Gets a type that defines just the minutes field.</summary>
        </member>
        <member name="P:NodaTime.PeriodType.Seconds">
            <summary>Gets a type that defines just the seconds field.</summary>
        </member>
        <member name="P:NodaTime.PeriodType.Milliseconds">
            <summary>Gets a type that defines just the milliseconds field.</summary>
        </member>
        <member name="P:NodaTime.PeriodType.Ticks">
            <summary>Gets a type that defines just the ticks field.</summary>
        </member>
        <member name="P:NodaTime.PeriodType.AllFields">
            <summary>
            Gets a type that defines all fields.
            </summary>
        </member>
        <member name="P:NodaTime.PeriodType.YearMonthDayTime">
            <summary>
            Gets a type that defines all standard fields except weeks.
            </summary>
        </member>
        <member name="P:NodaTime.PeriodType.YearMonthDay">
            <summary>
            Gets a type that defines the year, month and day fields.
            </summary>
        </member>
        <member name="P:NodaTime.PeriodType.YearWeekDayTime">
            <summary>
            Gets a type that defines all standard fields except months.
            </summary>
        </member>
        <member name="P:NodaTime.PeriodType.YearWeekDay">
            <summary>
            Gets a type that defines year, week and day fields.
            </summary>
        </member>
        <member name="P:NodaTime.PeriodType.YearDayTime">
            <summary>
            Gets a type that defines all standard fields except months and weeks.
            </summary>
        </member>
        <member name="P:NodaTime.PeriodType.YearDay">
            <summary>
            Gets a type that defines the year and day fields.
            </summary>
        </member>
        <member name="P:NodaTime.PeriodType.DayTime">
            <summary>
            Gets a type that defines all standard fields from days downwards.
            </summary>
        </member>
        <member name="P:NodaTime.PeriodType.Time">
            <summary>
            Gets a type that defines all standard time fields.
            </summary>
        </member>
        <member name="P:NodaTime.PeriodType.Name">
            <summary>
            Gets the name of the period type.
            </summary>
        </member>
        <member name="P:NodaTime.PeriodType.Size">
            <summary>
            Gets the number of fields in the period type.
            </summary>
        </member>
        <member name="P:NodaTime.PeriodType.HasTimeFields">
            <summary>
            Returns whether or not this period type supports any duration fields smaller than a day.
            </summary>
        </member>
        <member name="P:NodaTime.PeriodType.HasDateFields">
            <summary>
            Returns whether or not this period type supports any duration fields larger than an hour.
            </summary>
        </member>
        <member name="P:NodaTime.PeriodType.Item(System.Int32)">
            <summary>
            Returns the field type at the given index, which must be between 0 (inclusive) and <see cref="P:NodaTime.PeriodType.Size"/> (exclusive).
            </summary>
        </member>
        <member name="T:NodaTime.Fields.BasicMonthOfYearDateTimeField">
            <summary>
            Provides time calculations for the month of the year component of time.
            </summary>
        </member>
        <member name="T:NodaTime.Fields.ImpreciseDateTimeField">
            <summary>
            Abstract datetime field class that defines its own DurationField, which
            delegates back into this ImpreciseDateTimeField.
            </summary>
            <remarks>
            This DateTimeField is useful for defining DateTimeFields that are composed
            of imprecise durations. If both duration fields are precise, then a
            <see cref="T:NodaTime.Fields.PreciseDurationDateTimeField"/> should be used instead.
            <para>
            When defining imprecise DateTimeFields where a matching DurationField is
            already available, just extend BaseDateTimeField directly so as not to
            create redundant DurationField instances.
            </para>
            <para>
            ImpreciseDateTimeField is thread-safe and immutable, and its subclasses must
            be as well.
            </para>
            </remarks>
        </member>
        <member name="M:NodaTime.Fields.BasicMonthOfYearDateTimeField.GetValue(NodaTime.LocalInstant)">
            <summary>
            Get the Month component of the specified local instant.
            </summary>
            <param name="localInstant">The local instant to query</param>
            <returns>The month extracted from the input.</returns>
        </member>
        <member name="M:NodaTime.Fields.BasicMonthOfYearDateTimeField.GetInt64Value(NodaTime.LocalInstant)">
            <summary>
            Get the Month component of the specified local instant.
            </summary>
            <param name="localInstant">The local instant to query</param>
            <returns>The month extracted from the input.</returns>
        </member>
        <member name="M:NodaTime.Fields.BasicMonthOfYearDateTimeField.Add(NodaTime.LocalInstant,System.Int32)">
            <summary>
            Add the specified month to the specified time instant.
            The amount added may be negative.
            </summary>
            <param name="localInstant">The local instant to update</param>
            <param name="value">The months to add (can be negative).</param>
            <returns>The updated local instant</returns>
            <remarks>
            If the new month has less total days than the specified
            day of the month, this value is coerced to the nearest
            sane value. e.g.
            07-31 - (1 month) = 06-30
            03-31 - (1 month) = 02-28 or 02-29 depending
            </remarks>
        </member>
        <member name="M:NodaTime.Fields.BasicMonthOfYearDateTimeField.AddWrapField(NodaTime.LocalInstant,System.Int32)">
            <summary>
            Add to the Month component of the specified time instant
            wrapping around within that component if necessary.
            </summary>
            <param name="localInstant">The local instant to update</param>
            <param name="value">The months to add (can be negative)</param>
            <returns>The updated local instant</returns>
        </member>
        <member name="T:NodaTime.TimeZones.ZoneIntervalPair">
            <summary>
            A pair of possibly null ZoneInterval values. This is the result of fetching a time zone
            interval by LocalInstant, as the result could be 0, 1 or 2 matching ZoneIntervals.
            This is a sort of light-weight version of ZoneLocalMapping, used when we won't need to
            know the details of the gaps and it's handy to use a struct instead of creating a new object.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneIntervalPair.Equals(System.Object)">
            <summary>
              Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.
            </summary>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />; otherwise, <c>false</c>.
            </returns>
            <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />.</param>
            <exception cref="T:System.NullReferenceException">The <paramref name = "obj" /> parameter is null.</exception>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneIntervalPair.Equals(NodaTime.TimeZones.ZoneIntervalPair)">
            <summary>
              Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
              true if the current object is equal to the <paramref name = "other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.
            </param>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneIntervalPair.GetHashCode">
            <summary>
              Serves as a hash function for a particular type.
            </summary>
            <returns>
              A hash code for the current <see cref="T:System.Object" />.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneIntervalPair.EarlyInterval">
            <summary>
            The earlier of the two zone intervals matching the original local instant, or null
            if there were no matches. If there is a single match (the most common case) this
            value will be non-null, and LateInterval will be null.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneIntervalPair.LateInterval">
            <summary>
            The later of the two zone intervals matching the original local instant, or null
            if there were no matches. If there is a single match (the most common case) this
            value will be null, and EarlyInterval will be non-null.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneIntervalPair.MatchingIntervals">
            <summary>
            Returns the number of intervals contained within this pair - 0 for a "gap",
            1 for an unambiguous match, 2 for an ambiguous match.
            </summary>
        </member>
        <member name="T:NodaTime.TimeZones.DateTimeZoneCompressionWriter">
            <summary>
              Very specific compressing binary writer for time zones.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneCompressionWriter.#ctor(System.IO.Stream)">
            <summary>
              Initializes a new instance of the <see cref="T:NodaTime.TimeZones.DateTimeZoneCompressionWriter"/> class.
            </summary>
            <param name="output">Where to send the serialized output.</param>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneCompressionWriter.WriteCount(System.Int32)">
            <summary>
              Writes the given non-negative integer value to the stream.
            </summary>
            <remarks>
            Negative values are handled but in an inefficient way (5 bytes).
            </remarks>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneCompressionWriter.WriteMilliseconds(System.Int32)">
            <summary>
              Writes the integer milliseconds value to the stream.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneCompressionWriter.WriteTicks(System.Int64)">
            <summary>
              Writes the long ticks value to the stream.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="T:NodaTime.TimeZones.Transition">
            <summary>
            A transition between two offsets, usually for daylight saving reasons.
            TODO(jon): Potentially rename this to ZoneTransition after doing something
            else with the current ZoneTransition class :)
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.Transition.op_Equality(NodaTime.TimeZones.Transition,NodaTime.TimeZones.Transition)">
            <summary>
            Implements the operator == (equality).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.Transition.op_Inequality(NodaTime.TimeZones.Transition,NodaTime.TimeZones.Transition)">
            <summary>
            Implements the operator != (inequality).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are not equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.Transition.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
            <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance;
            otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.Transition.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data
            structures like a hash table. 
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.Transition.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="P:NodaTime.TimeZones.Transition.OldOffset">
            <summary>
            The offset which applied from the previous transition until this
            one.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.Transition.NewOffset">
            <summary>
            The offset from the time when this transition occurs until the next transition.
            </summary>
        </member>
        <member name="T:NodaTime.Fields.PreciseDurationField">
            <summary>
            Duration field class representing a field with a fixed unit length.
            </summary>
        </member>
        <member name="F:NodaTime.Fields.PreciseDurationField.unitTicks">
            <summary>
            The size of the unit, in ticks.
            </summary>
        </member>
        <member name="P:NodaTime.Fields.PreciseDurationField.IsPrecise">
            <summary>
            Always returns true.
            </summary>
        </member>
        <member name="P:NodaTime.Fields.PreciseDurationField.IsSupported">
            <summary>
            Always returns true.
            </summary>
        </member>
        <member name="T:NodaTime.Fields.GJYearOfEraDateTimeField">
            <summary>
            Porting status: Need AddWrapField
            </summary>
        </member>
        <member name="T:NodaTime.Format.DateTimeParseStyles">
            <summary>
            Styles applied when parsing values.
            </summary>
        </member>
        <member name="F:NodaTime.Format.DateTimeParseStyles.None">
            <summary>
            Default formatting options must be used.
            </summary>
        </member>
        <member name="F:NodaTime.Format.DateTimeParseStyles.AllowInnerWhite">
            <summary>
            Leading white-space characters must be ignored during parsing, except if they occur in the specified format patterns.
            </summary>
        </member>
        <member name="F:NodaTime.Format.DateTimeParseStyles.AllowLeadingWhite">
            <summary>
            Trailing white-space characters must be ignored during parsing, except if they occur in the specified format patterns.
            </summary>
        </member>
        <member name="F:NodaTime.Format.DateTimeParseStyles.AllowTrailingWhite">
            <summary>
            Extra white-space characters in the middle of the string must be ignored during parsing, except if they occur in the specified format patterns.
            </summary>
        </member>
        <member name="F:NodaTime.Format.DateTimeParseStyles.AllowWhiteSpaces">
            <summary>
            Extra white-space characters anywhere in the string must be ignored during parsing, except if they occur in the specified format patterns.
            This value is a combination of the AllowLeadingWhite, AllowTrailingWhite, and AllowInnerWhite values.
            </summary>
        </member>
        <member name="T:NodaTime.NodaConstants">
            <summary>
            Original name: NodaConstants.
            
            I'm not sure that everything in NodaConstants
            really belongs in one file, and it should perhaps be named to reflect its ISO background
            as well. We should consider an Iso8601Month enum etc. Possibly start
            with everything in here, then refactor it out when it's all working.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.BCE">
            <summary>
            Constant for the era known as BCE (Before Common Era).
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.BC">
            <summary>
            Constant for the BC era; equal to BCE but provided for flexibility of expression..
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.BeforeCommonEra">
            <summary>
            Constant for the BC era; equal to BCE but provided for flexibility of expression..
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.CE">
            <summary>
            Constant for the common era.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.CommonEra">
            <summary>
            Constant for the common era; equal to CE but provided for flexibility of expression.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.AD">
            <summary>
            Constant for the "Anno Domini" era; equal to CE but provided for flexibility of expression.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.TicksPerMillisecond">
            <summary>
            A constant for the number of ticks in a millisecond. The value of this constant is 10,000.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.TicksPerSecond">
            <summary>
            A constant for the number of ticks in a second. The value of this constant is 10,000,000.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.TicksPerMinute">
            <summary>
            A constant for the number of ticks in a minute. The value of this constant is 600,000,000.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.TicksPerHour">
            <summary>
            A constant for the number of ticks in a minute. The value of this constant is 36,000,000,000.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.TicksPerStandardDay">
            <summary>
            A constant for the number of ticks in a standard 24-hour day.
            The value of this constant is 864,000,000,000.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.TicksPerStandardWeek">
            <summary>
            A constant for the number of ticks in a standard week of seven 24-hour days.
            The value of this constant is 6,048,000,000,000.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.MillisecondsPerSecond">
            <summary>
            A constant for the number of milliseconds per second.
            The value of this constant is 1000.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.MillisecondsPerMinute">
            <summary>
            A constant for the number of milliseconds per minute.
            The value of this constant is 60,000.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.MillisecondsPerHour">
            <summary>
            A constant for the number of milliseconds per hour.
            The value of this constant is 3,600,000.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.MillisecondsPerStandardDay">
            <summary>
            A constant for the number of milliseconds per standard 24-hour day.
            The value of this constant is 86,400,000.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.MillisecondsPerStandardWeek">
            <summary>
            A constant for the number of milliseconds per standard week of seven 24-hour days.
            The value of this constant is 604,800,000.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.SecondsPerMinute">
            <summary>
            A constant for the number of seconds per minute.
            The value of this constant is 60.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.SecondsPerHour">
            <summary>
            A constant for the number of seconds per hour.
            The value of this constant is 3,600.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.SecondsPerDay">
            <summary>
            A constant for the number of seconds per standard 24-hour day.
            The value of this constant is 86,400.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.SecondsPerWeek">
            <summary>
            A constant for the number of seconds per standard week of seven 24-hour days.
            The value of this constant is 604,800.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.MinutesPerHour">
            <summary>
            A constant for the number of minutes per hour.
            The value of this constant is 60.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.MinutesPerStandardDay">
            <summary>
            A constant for the number of minutes per standard 24-hour day.
            The value of this constant is 1,440.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.MinutesPerStandardWeek">
            <summary>
            A constant for the number of minutes per standard week of seven 24-hour days.
            The value of this constant is 10,080.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.HoursPerStandardDay">
            <summary>
            A constant for the number of hours in a standard day. Note that the number of hours
            in a day can vary due to daylight saving effects.
            The value of this constant is 24.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.HoursPerStandardWeek">
            <summary>
            A constant for the number of hours in a standard week of seven 24-hour days.
            The value of this constant is 168.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.DaysPerStandardWeek">
            <summary>
            Number of days in a standard Gregorian week.
            The value of this constant is 7.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.DateTimeEpochTicks">
            <summary>
            The number of ticks in a <see cref="T:System.DateTime"/> at the Unix epoch.
            </summary>
            <remarks>
            Noda Time and the .NET framework use different "epochs" or origins for their time frames.
            Noda Time associates 0 ticks with midnight on January 1st 1970 UTC; .NET associates
            0 ticks with midnight on January 0001 UTC. If the value of this field is added to
            the number of ticks in an <see cref="T:NodaTime.Instant"/>, the result is the number of ticks in
            the corresponding DateTime.
            </remarks>
        </member>
        <member name="T:NodaTime.TimeZones.TimeZoneCache">
            <summary>
              Provides a cache for time zone providers and previously looked up time zones. The process of
              loading and creating time zones is potentially long (it could conceivably include network
              requests) so caching them is necessary.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.TimeZoneCache.#ctor(System.Boolean)">
            <summary>
              Initializes a new instance of the <see cref="T:NodaTime.TimeZones.TimeZoneCache" /> class.
            </summary>
            <param name="isUtcOnly">if set to <c>true</c> only the UTC provider will be available.</param>
        </member>
        <member name="M:NodaTime.TimeZones.TimeZoneCache.AddProvider(NodaTime.TimeZones.IDateTimeZoneProvider)">
            <summary>
              Adds the given time zone provider to the front of the provider list.
            </summary>
            <remarks>
              Because this adds the new provider to the from of the list, it will be checked first for
              time zone definitions and therefore can override the default system definitions. This
              allows for adding new or replacing existing time zones without updating the system. If
              the provider is already on the list nothing changes.
            </remarks>
            <param name="provider">The <see cref="T:NodaTime.TimeZones.IDateTimeZoneProvider"/> to add.</param>
        </member>
        <member name="M:NodaTime.TimeZones.TimeZoneCache.RemoveProvider(NodaTime.TimeZones.IDateTimeZoneProvider)">
            <summary>
              Removes the given time zone provider from the provider list.
            </summary>
            <remarks>
              If the provider is not on the list nothing changes.
            </remarks>
            <param name="provider">The <see cref="T:NodaTime.TimeZones.IDateTimeZoneProvider"/> to remove.</param>
            <returns><c>true</c> if the provider was removed.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.TimeZoneCache.ForId(System.String)">
            <summary>
              Returns the time zone with the given id.
            </summary>
            <param name="id">The time zone id to find.</param>
            <returns>The <see cref="T:NodaTime.DateTimeZone"/> with the given id or <c>null</c> if there isn't one defined.</returns>
        </member>
        <member name="P:NodaTime.TimeZones.TimeZoneCache.SystemDefault">
            <summary>
              Gets the system default time zone which can only be changed by the system.
            </summary>
            <remarks>
              <para>
                The time zones defined in the operating system are different than the ones defines in
                this library so a mapping will occur. If an exact mapping can be made then that will be
                used otherwise UTC will be used.
              </para>
            </remarks>
            <value>The system default <see cref="T:NodaTime.DateTimeZone" /> this will never be <c>null</c>.</value>
        </member>
        <member name="P:NodaTime.TimeZones.TimeZoneCache.Current">
            <summary>
              Gets or sets the current time zone.
            </summary>
            <remarks>
              This is the time zone that is used whenever a time zone is not given to a method. It can
              be set to any valid time zone. Setting it to <c>null</c> causes the
              <see cref="P:NodaTime.DateTimeZone.SystemDefault" /> time zone to be used.
            </remarks>
            <value>The current <see cref="T:NodaTime.DateTimeZone" />. This will never be <c>null</c>.</value>
        </member>
        <member name="P:NodaTime.TimeZones.TimeZoneCache.Ids">
            <summary>
              Gets the complete list of valid time zone ids provided by all of the registered
              providers. This list will be sorted in lexigraphical order by the id name.
            </summary>
            <value>The <see cref="T:System.Collections.Generic.IEnumerable`1"/> of string ids.</value>
        </member>
        <member name="T:NodaTime.Fields.ZeroIsMaxDateTimeField">
            <summary>
            Wraps another field such that zero values are replaced with one more than
            it's maximum. This is particularly useful for implementing an clockhourOfDay
            field, where the midnight value of 0 is replaced with 24.
            </summary>
        </member>
        <member name="T:NodaTime.Fields.DividedDateTimeField">
            <summary>
            Porting status: need AddWrapField. Also consider making min/max ints - check usage.
            </summary>
        </member>
        <member name="T:NodaTime.Format.OffsetParse">
            <summary>
              Provides the implementation for parsing strings into <see cref="T:NodaTime.Offset"/> values.
            </summary>
            <remarks>
              The concept and general format for this class comes from the Microsoft system libraries and their
              implementations of parsing of objects like <see cref="T:System.Int32"/> and <see cref="T:System.DateTime"/>.
            </remarks>
        </member>
        <member name="M:NodaTime.Format.OffsetParse.Parse(System.String,NodaTime.Globalization.NodaFormatInfo,NodaTime.Format.DateTimeParseStyles)">
            <summary>
              Parses the specified value.
            </summary>
            <param name="value">The value.</param>
            <param name="formatInfo">The format info.</param>
            <param name="styles">The styles.</param>
            <returns></returns>
        </member>
        <member name="T:NodaTime.Calendars.WrappedCalendarSystem">
            <summary>
            A calendar system which wraps another one, allowing the wrapped system to be used for some operations.
            </summary>
        </member>
        <member name="P:NodaTime.Calendars.WrappedCalendarSystem.Calendar">
            <summary>
            The calendar system wrapped by this one.
            </summary>
        </member>
        <member name="T:NodaTime.TimeZones.DateTimeZoneBuilder">
            <summary>
            Provides a means of programatically creating complex time zones. Currently internal, but we
            may want to make it public again eventually.
            </summary>
            <remarks>
            <para>
            DateTimeZoneBuilder allows complex DateTimeZones to be constructed. Since creating a new
            DateTimeZone this way is a relatively expensive operation, built zones can be written to a
            file. Reading back the encoded data is a quick operation.
            </para>
            <para>
            DateTimeZoneBuilder itself is mutable and not thread-safe, but the DateTimeZone objects that
            it builds are thread-safe and immutable.
            </para>
            <para>
            It is intended that {@link ZoneInfoCompiler} be used to read time zone data files,
            indirectly calling DateTimeZoneBuilder. The following complex example defines the
            America/Los_Angeles time zone, with all historical transitions:
            </para>
            <para>
            <example>
                DateTimeZone America_Los_Angeles = new DateTimeZoneBuilder()
                    .AddCutover(-2147483648, 'w', 1, 1, 0, false, 0)
                    .SetStandardOffset(-28378000)
                    .SetFixedSavings("LMT", 0)
                    .AddCutover(1883, 'w', 11, 18, 0, false, 43200000)
                    .SetStandardOffset(-28800000)
                    .AddRecurringSavings("PDT", 3600000, 1918, 1919, 'w',  3, -1, 7, false, 7200000)
                    .AddRecurringSavings("PST",       0, 1918, 1919, 'w', 10, -1, 7, false, 7200000)
                    .AddRecurringSavings("PWT", 3600000, 1942, 1942, 'w',  2,  9, 0, false, 7200000)
                    .AddRecurringSavings("PPT", 3600000, 1945, 1945, 'u',  8, 14, 0, false, 82800000)
                    .AddRecurringSavings("PST",       0, 1945, 1945, 'w',  9, 30, 0, false, 7200000)
                    .AddRecurringSavings("PDT", 3600000, 1948, 1948, 'w',  3, 14, 0, false, 7200000)
                    .AddRecurringSavings("PST",       0, 1949, 1949, 'w',  1,  1, 0, false, 7200000)
                    .AddRecurringSavings("PDT", 3600000, 1950, 1966, 'w',  4, -1, 7, false, 7200000)
                    .AddRecurringSavings("PST",       0, 1950, 1961, 'w',  9, -1, 7, false, 7200000)
                    .AddRecurringSavings("PST",       0, 1962, 1966, 'w', 10, -1, 7, false, 7200000)
                    .AddRecurringSavings("PST",       0, 1967, 2147483647, 'w', 10, -1, 7, false, 7200000)
                    .AddRecurringSavings("PDT", 3600000, 1967, 1973, 'w', 4, -1,  7, false, 7200000)
                    .AddRecurringSavings("PDT", 3600000, 1974, 1974, 'w', 1,  6,  0, false, 7200000)
                    .AddRecurringSavings("PDT", 3600000, 1975, 1975, 'w', 2, 23,  0, false, 7200000)
                    .AddRecurringSavings("PDT", 3600000, 1976, 1986, 'w', 4, -1,  7, false, 7200000)
                    .AddRecurringSavings("PDT", 3600000, 1987, 2147483647, 'w', 4, 1, 7, true, 7200000)
                    .ToDateTimeZone("America/Los_Angeles");
            </example>
            </para>
            <para>
            Original name: DateTimeZoneBuilder.
            </para>
            </remarks>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneBuilder.AddCutover(System.Int32,NodaTime.TimeZones.TransitionMode,System.Int32,System.Int32,System.Int32,System.Boolean,NodaTime.Offset)">
            <summary>
            Adds a cutover for added rules.
            </summary>
            <remarks>
            A cutover is a point where the standard offset from GMT/UTC changed. This occurs mostly
            pre-1900. The standard offset at the cutover defaults to 0. Call <see cref="M:NodaTime.TimeZones.DateTimeZoneBuilder.SetStandardOffset(NodaTime.Offset)"/> afterwards to change it.
            </remarks>
            <param name="year">The year of cutover.</param>
            <param name="mode">The transition mode.</param>
            <param name="monthOfYear">The month of year.</param>
            <param name="dayOfMonth">The day of the month. If negative, set to ((last day of month)
            - ~dayOfMonth). For example, if -1, set to last day of month</param>
            <param name="dayOfWeek">The day of week. If 0, ignore.</param>
            <param name="advanceDayOfWeek">if dayOfMonth does not fall on dayOfWeek, then if advanceDayOfWeek set to <c>true</c>
            advance to dayOfWeek when true, otherwise retreat to dayOfWeek when true.</param>
            <param name="tickOfDay">The <see cref="T:NodaTime.Duration"/> into the day. Additional precision for specifying time of day of transitions</param>
            <returns>This <see cref="T:NodaTime.TimeZones.DateTimeZoneBuilder"/> for chaining.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneBuilder.AddCutover(System.Int32,NodaTime.TimeZones.ZoneYearOffset)">
            <summary>
            Adds a cutover for added rules.
            </summary>
            <param name="year">The year of cutover.</param>
            <param name="yearOffset">The offset into the year of the cutover.</param>
            <returns></returns>
            <remarks>
            A cutover is a point where the standard offset from GMT/UTC changed. This occurs mostly
            pre-1900. The standard offset at the cutover defaults to 0.
            Call <see cref="M:NodaTime.TimeZones.DateTimeZoneBuilder.SetStandardOffset(NodaTime.Offset)"/> afterwards to change it.
            </remarks>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneBuilder.SetStandardOffset(NodaTime.Offset)">
            <summary>
            Sets the standard offset to use for newly added rules until the next cutover is added.
            </summary>
            <param name="standardOffset">The standard offset.</param>
            <returns>This <see cref="T:NodaTime.TimeZones.DateTimeZoneBuilder"/> for chaining.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneBuilder.SetFixedSavings(System.String,NodaTime.Offset)">
            <summary>
            Sets a fixed savings rule at the cutover.
            </summary>
            <param name="nameKey">The name key of new rule.</param>
            <param name="savings">The <see cref="T:NodaTime.Duration"/> to add to standard offset.</param>
            <returns>This <see cref="T:NodaTime.TimeZones.DateTimeZoneBuilder"/> for chaining.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneBuilder.AddRecurringSavings(System.String,NodaTime.Offset,System.Int32,System.Int32,NodaTime.TimeZones.TransitionMode,System.Int32,System.Int32,System.Int32,System.Boolean,NodaTime.Offset)">
            <summary>
            Adds a recurring daylight saving time rule.
            </summary>
            <param name="nameKey">The name key of new rule.</param>
            <param name="savings">The <see cref="T:NodaTime.Duration"/> to add to standard offset.</param>
            <param name="fromYear">First year that rule is in effect. <see cref="F:System.Int32.MinValue"/> indicates beginning of time.</param>
            <param name="toYear">Last year (inclusive) that rule is in effect. <see cref="F:System.Int32.MaxValue"/> indicates end of time.</param>
            <param name="mode">The transition mode.</param>
            <param name="monthOfYear">The month of year.</param>
            <param name="dayOfMonth">The day of the month. If negative, set to ((last day of month)
            - ~dayOfMonth). For example, if -1, set to last day of month</param>
            <param name="dayOfWeek">The day of week. If 0, ignore.</param>
            <param name="advanceDayOfWeek">if dayOfMonth does not fall on dayOfWeek, then if advanceDayOfWeek set to <c>true</c>
            advance to dayOfWeek when true, otherwise retreat to dayOfWeek when true.</param>
            <param name="tickOfDay">The <see cref="T:NodaTime.Duration"/> into the day. Additional precision for specifying time of day of transitions</param>
            <returns>This <see cref="T:NodaTime.TimeZones.DateTimeZoneBuilder"/> for chaining.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneBuilder.AddRecurringSavings(System.String,NodaTime.Offset,System.Int32,System.Int32,NodaTime.TimeZones.ZoneYearOffset)">
            <summary>
            Adds a recurring daylight saving time rule.
            </summary>
            <param name="nameKey">The name key of new rule.</param>
            <param name="savings">The <see cref="T:NodaTime.Duration"/> to add to standard offset.</param>
            <param name="fromYear">First year that rule is in effect. <see cref="F:System.Int32.MinValue"/> indicates beginning of time.</param>
            <param name="toYear">Last year (inclusive) that rule is in effect. <see cref="F:System.Int32.MaxValue"/> indicates end of time.</param>
            <param name="yearOffset">The offset into the year.</param>
            <returns>This <see cref="T:NodaTime.TimeZones.DateTimeZoneBuilder"/> for chaining.</returns> 
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneBuilder.AddRecurringSavings(NodaTime.TimeZones.ZoneRecurrence)">
            <summary>
            Adds a recurring daylight saving time rule.
            </summary>
            <param name="recurrence">The zone recurrence defining the recurrening savings.</param>
            <returns>This <see cref="T:NodaTime.TimeZones.DateTimeZoneBuilder"/> for chaining.</returns> 
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneBuilder.ToDateTimeZone(System.String)">
            <summary>
            Processes all the rules and builds a DateTimeZone.
            </summary>
            <param name="zoneId">Time zone ID to assign</param>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneBuilder.AddTransition(System.Collections.Generic.IList{NodaTime.TimeZones.ZoneTransition},NodaTime.TimeZones.ZoneTransition)">
            <summary>
            Adds the given transition to the transition list if it represents a new transition.
            </summary>
            <param name="transitions">The list of <see cref="T:NodaTime.TimeZones.ZoneTransition"/> to add to.</param>
            <param name="transition">The transition to add.</param>
            <returns><c>true</c> if the transition was added.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneBuilder.AddEndOfTimeRuleSet">
            <summary>
            Adds a rule set that spans from the last one to the end of time.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.DateTimeZoneBuilder.LastRuleSet">
            <summary>
            Gets the last rule set if there are no rule sets one that spans all of time is created and returned.
            </summary>
            <value>The last rule set.</value>
        </member>
        <member name="T:NodaTime.Fields.OffsetDateTimeField">
            <summary>
            Generic offset adjusting datetime field.
            </summary>
        </member>
        <member name="T:NodaTime.Fields.FieldSet">
            <summary>
            An immutable collection of date/time and duration fields.
            </summary>
        </member>
        <member name="M:NodaTime.Fields.FieldSet.WithSupportedFieldsFrom(NodaTime.Fields.FieldSet)">
            <summary>
            Convenience method to create a new field set with
            the current field set as a "base" overridden with
            supported fields from the given set.
            </summary>
        </member>
        <member name="M:NodaTime.Fields.FieldSet.Builder.WithSupportedFieldsFrom(NodaTime.Fields.FieldSet)">
            <summary>
            Copies just the supported fields from the specified set into this builder,
            and returns this builder again (for fluent building).
            </summary>
            <param name="other">The set of fields to copy.</param>
        </member>
        <member name="T:NodaTime.LocalTime">
            <summary>
            LocalTime is an immutable struct representing a time of day, with no reference
            to a particular calendar, time zone or date.
            </summary>
        </member>
        <member name="M:NodaTime.LocalTime.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a local time at the given hour, minute and second,
            with millisecond-of-second and tick-of-millisecond values of zero.
            </summary>
            <param name="hour">The hour of day.</param>
            <param name="minute">The minute of the hour.</param>
            <param name="second">The second of the minute.</param>
        </member>
        <member name="M:NodaTime.LocalTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a local time at the given hour, minute, second and millisecond,
            with a tick-of-millisecond value of zero.
            </summary>
            <param name="hour">The hour of day.</param>
            <param name="minute">The minute of the hour.</param>
            <param name="second">The second of the minute.</param>
            <param name="millisecond">The millisecond of the second.</param>
        </member>
        <member name="M:NodaTime.LocalTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a local time at the given hour, minute, second, millisecond and tick within millisecond.
            </summary>
            <param name="hour">The hour of day.</param>
            <param name="minute">The minute of the hour.</param>
            <param name="second">The second of the minute.</param>
            <param name="millisecond">The millisecond of the second.</param>
            <param name="tickWithinMillisecond">The tick within the millisecond.</param>
        </member>
        <member name="M:NodaTime.LocalTime.op_Addition(NodaTime.LocalTime,NodaTime.Period)">
            <summary>
            TODO: Assert no units as large a day
            </summary>
        </member>
        <member name="M:NodaTime.LocalTime.op_Subtraction(NodaTime.LocalTime,NodaTime.Period)">
            <summary>
            TODO: Assert no units as large as a day
            </summary>
        </member>
        <member name="M:NodaTime.LocalTime.op_Equality(NodaTime.LocalTime,NodaTime.LocalTime)">
            <summary>
            Compares two local times for equality, by checking whether they represent
            the exact same local time, down to the tick.
            </summary>
        </member>
        <member name="M:NodaTime.LocalTime.op_Inequality(NodaTime.LocalTime,NodaTime.LocalTime)">
            <summary>
            Compares two local times for inequality.
            </summary>
        </member>
        <member name="M:NodaTime.LocalTime.ToString">
            <summary>
            Converts this local time to text form, using the current format provider's default
            formatting information.
            </summary>
        </member>
        <member name="M:NodaTime.LocalTime.GetHashCode">
            <summary>
            Returns a hash code for this local time.
            </summary>
        </member>
        <member name="M:NodaTime.LocalTime.Equals(NodaTime.LocalTime)">
            <summary>
            Compares this local time with the specified one for equality,
            by checking whether the two values represent the exact same local time, down to the tick.
            </summary>
        </member>
        <member name="M:NodaTime.LocalTime.Equals(System.Object)">
            <summary>
            Compares this local time with the specified reference. A local time is
            only equal to another local time with the same underlying tick value.
            </summary>
        </member>
        <member name="P:NodaTime.LocalTime.HourOfDay">
            <summary>
            Gets the hour of day of this local time, in the range 0 to 23 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.LocalTime.MinuteOfHour">
            <summary>
            Gets the minute of this local time, in the range 0 to 59 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.LocalTime.SecondOfMinute">
            <summary>
            Gets the second of this local time within the minute, in the range 0 to 59 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.LocalTime.SecondOfDay">
            <summary>
            Gets the second of this local time within the day, in the range 0 to 86,399 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.LocalTime.MillisecondOfSecond">
            <summary>
            Gets the millisecond of this local time within the second, in the range 0 to 999 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.LocalTime.MillisecondOfDay">
            <summary>
            Gets the millisecond of this local time within the day, in the range 0 to 86,399,999 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.LocalTime.TickOfMillisecond">
            <summary>
            Gets the tick of this local time within the millisceond, in the range 0 to 9,999 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.LocalTime.TickOfDay">
            <summary>
            Gets the tick of this local time within the day, in the range 0 to 863,999,999,999 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.LocalTime.LocalDateTime">
            <summary>
            Returns a LocalDateTime with this local time, on January 1st 1970 in the ISO calendar.
            </summary>
        </member>
        <member name="T:NodaTime.Fields.BasicDayOfMonthDateTimeField">
            <summary>
            Porting status: Needs partial and max for set support.
            </summary>
        </member>
        <member name="T:NodaTime.Format.FormatHelper">
            <summary>
              Provides helper methods for formatting values using pattern strings.
            </summary>
        </member>
        <member name="F:NodaTime.Format.FormatHelper.MaximumPaddingLength">
            <summary>
              The maximum number of characters allowed for padded values.
            </summary>
        </member>
        <member name="M:NodaTime.Format.FormatHelper.FormatSign(NodaTime.Format.ISignedValue,System.Boolean,System.Text.StringBuilder)">
            <summary>
              Formats a sign character.
            </summary>
            <param name="value">The <see cref="T:NodaTime.Format.ISignedValue"/> value.</param>
            <param name="required">if set to <c>true</c> the sin will always be output, otherwise only if the value is negative.</param>
            <param name="outputBuffer">The output buffer to add the sign to.</param>
        </member>
        <member name="M:NodaTime.Format.FormatHelper.LeftPad(System.Int32,System.Int32,System.Text.StringBuilder)">
            <summary>
              Formats the given value left padded with zeros.
            </summary>
            <remarks>
              Left pads with zeros the value into a field of <paramref name="length"/> characters. If the value
              is longer than <paramref name="length"/>, the entire value is formatted.
            </remarks>
            <param name="value">The value to format.</param>
            <param name="length">The length to fill.</param>
            <param name="outputBuffer">The output buffer to add the digits to.</param>
            <exception cref="T:System.FormatException">if too many characters are requested. <see cref="F:NodaTime.Format.FormatHelper.MaximumPaddingLength"/>.</exception>
        </member>
        <member name="M:NodaTime.Format.FormatHelper.RightPad(System.Int32,System.Int32,System.Int32,System.Text.StringBuilder)">
            <summary>
              Formats the given value right padded with zeros.
            </summary>
            <param name="value">The value to format.</param>
            <param name="length">The length to fill.</param>
            <param name="scale">The scale of the value i.e. the number of significant digits is the range of the value.</param>
            <param name="outputBuffer">The output buffer to add the digits to.</param>
        </member>
        <member name="M:NodaTime.Format.FormatHelper.RightPadTruncate(System.Int32,System.Int32,System.Int32,System.String,System.Text.StringBuilder)">
            <summary>
              Formats the given value right padded with zeros. The rightmost zeros are truncated.  If the entire value is truncated then
              the preceeding decimal separater is also removed.
            </summary>
            <param name="value">The value to format.</param>
            <param name="length">The length to fill.</param>
            <param name="scale">The scale of the value i.e. the number of significant digits is the range of the value.</param>
            <param name="decimalSeparator">The decimal separator for this culture.</param>
            <param name="outputBuffer">The output buffer to add the digits to.</param>
        </member>
        <member name="T:NodaTime.Calendars.BasicFixedMonthCalendarSystem">
            <summary>
            Abstract implementation of a calendar system based around months which always have 30 days.
            </summary>
            <remarks>
            As the month length is fixed various calculations can be optimised.
            This implementation assumes any additional days after twelve
            months fall into a thirteenth month.
            </remarks>
        </member>
        <member name="T:NodaTime.TimeZones.FixedDateTimeZone">
            <summary>
            Basic <see cref="T:NodaTime.DateTimeZone"/> implementation that has a fixed name key and offset i.e.
            no daylight savings.
            </summary>
            <remarks>
            This type is thread-safe and immutable.
            </remarks>
        </member>
        <member name="M:NodaTime.TimeZones.FixedDateTimeZone.#ctor(NodaTime.Offset)">
            <summary>
            Creates a new fixed time zone.
            </summary>
            <param name="offset">The <see cref="T:NodaTime.Offset"/> from UTC.</param>
        </member>
        <member name="M:NodaTime.TimeZones.FixedDateTimeZone.#ctor(System.String,NodaTime.Offset)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.FixedDateTimeZone"/> class.
            </summary>
            <param name="id">The id.</param>
            <param name="offset">The offset.</param>
        </member>
        <member name="M:NodaTime.TimeZones.FixedDateTimeZone.MakeId(NodaTime.Offset)">
            <summary>
            Makes the id for this time zone. The format is "UTC+/-Offset".
            </summary>
            <param name="offset">The offset.</param>
            <returns>The generated id string.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.FixedDateTimeZone.GetZoneInterval(NodaTime.Instant)">
            <summary>
            Gets the zone interval for the given instant. This implementation always returns the same interval.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.FixedDateTimeZone.GetZoneIntervals(NodaTime.LocalInstant)">
            <summary>
            Gets the zone interval pair for the given instant. This implementation always returns the same unambiguous interval pair.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.FixedDateTimeZone.GetOffsetFromUtc(NodaTime.Instant)">
            <summary>
            Returns the offset from UTC, where a positive duration indicates that local time is later
            than UTC. In other words, local time = UTC + offset.
            </summary>
            <param name="instant">The instant for which to calculate the offset.</param>
            <returns>
            The offset from UTC at the specified instant.
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.FixedDateTimeZone.Write(NodaTime.TimeZones.DateTimeZoneWriter)">
            <summary>
            Writes the specified writer.
            </summary>
            <param name="writer">The writer.</param>
        </member>
        <member name="M:NodaTime.TimeZones.FixedDateTimeZone.Read(NodaTime.TimeZones.DateTimeZoneReader,System.String)">
            <summary>
            Reads the specified reader.
            </summary>
            <param name="reader">The reader.</param>
            <param name="id">The id.</param>
            <returns></returns>
        </member>
        <member name="M:NodaTime.TimeZones.FixedDateTimeZone.Equals(NodaTime.TimeZones.FixedDateTimeZone)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.
                            </param>
        </member>
        <member name="M:NodaTime.TimeZones.FixedDateTimeZone.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>. 
                            </param><exception cref="T:System.NullReferenceException">The <paramref name="obj"/> parameter is null.
                            </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.TimeZones.FixedDateTimeZone.GetHashCode">
            <summary>
            Serves as a hash function for a particular type. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.TimeZones.FixedDateTimeZone.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="T:NodaTime.SkippedTimeException">
            <summary>
            Exception thrown to indicate that the specified local time doesn't
            exist in a particular time zone due to daylight saving time changes.    
            </summary>
            <remarks>
            <para>
            This occurs for spring transitions, where the clock goes forward
            (usually by an hour). For example, suppose the time zone goes forward
            at 2am, so the second after 01:59:59 becomes 03:00:00. In that case,
            times such as 02:30:00 never occur.
            </para>
            <para>
            This exception is used to indicate such problems, as they're usually
            not the same as other <see cref="T:System.ArgumentOutOfRangeException"/> causes,
            such as entering "15" for a month number.
            </para>
            <para>
            In theory this isn't calendar-specific; the local instant won't exist in
            this time zone regardless of the calendar used. However, this exception is
            always created in conjunction with a specific calendar, which leads to a more
            natural way of examining its information and constructing an error message.
            </para>
            </remarks>
        </member>
        <member name="M:NodaTime.SkippedTimeException.#ctor(NodaTime.LocalDateTime,NodaTime.DateTimeZone)">
            <summary>
            Creates a new instance for the given local date/time and time zone.
            </summary>
            <remarks>
            User code is unlikely to need to deliberately call this constructor except
            possibly for testing.
            </remarks>
        </member>
        <member name="P:NodaTime.SkippedTimeException.LocalDateTime">
            <summary>
            The local instant which is invalid in the time zone
            </summary>
        </member>
        <member name="P:NodaTime.SkippedTimeException.Zone">
            <summary>
            The time zone in which the local instant is invalid
            </summary>
        </member>
        <member name="T:NodaTime.Fields.BasicWeekOfWeekYearDateTimeField">
            <summary>
            Needs partial and max for set support.
            </summary>
        </member>
        <member name="T:NodaTime.Format.OffsetParseInfo">
            <summary>
              Provides a container for the interim parsed pieces of an <see cref="T:NodaTime.Offset"/> value.
            </summary>
        </member>
        <member name="F:NodaTime.Format.OffsetParseInfo.FractionalSeconds">
            <summary>
              The fractions of a seconds in milliseconds.
            </summary>
        </member>
        <member name="F:NodaTime.Format.OffsetParseInfo.Hours">
            <summary>
              The hours in the range [0, 23].
            </summary>
        </member>
        <member name="F:NodaTime.Format.OffsetParseInfo.Milliseconds">
            <summary>
              The total millisconds. This is the only value that can be negative.
            </summary>
        </member>
        <member name="F:NodaTime.Format.OffsetParseInfo.Minutes">
            <summary>
              The minutes in the range [0, 59].
            </summary>
        </member>
        <member name="F:NodaTime.Format.OffsetParseInfo.Seconds">
            <summary>
              The seconds in the range [0, 59].
            </summary>
        </member>
        <member name="M:NodaTime.Format.OffsetParseInfo.#ctor(System.IFormatProvider,NodaTime.Format.DateTimeParseStyles)">
            <summary>
              Initializes a new instance of the <see cref="T:NodaTime.Format.OffsetParseInfo"/> class.
            </summary>
            <param name="formatInfo">The format info.</param>
            <param name="parseStyles">The parse styles.</param>
        </member>
        <member name="M:NodaTime.Format.OffsetParseInfo.#ctor(NodaTime.Offset,System.IFormatProvider)">
            <summary>
              Initializes a new instance of the <see cref="T:NodaTime.Format.OffsetParseInfo"/> class.
            </summary>
            <param name="value">The value.</param>
            <param name="formatInfo">The format info.</param>
        </member>
        <member name="M:NodaTime.Format.OffsetParseInfo.CalculateValue">
            <summary>
              Calculates the value from the parsed pieces.
            </summary>
        </member>
        <member name="P:NodaTime.Format.OffsetParseInfo.Value">
            <summary>
              Gets or sets the value.
            </summary>
            <value>
              The value.
            </value>
        </member>
        <member name="P:NodaTime.Format.OffsetParseInfo.IsNegative">
            <summary>
              Gets a value indicating whether this instance is negative.
            </summary>
            <value>
              <c>true</c> if this instance is negative; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:NodaTime.Format.OffsetParseInfo.Sign">
            <summary>
              Gets the sign.
            </summary>
        </member>
        <member name="T:NodaTime.Calendars.CopticCalendarSystem">
            <summary>
            Implements the Coptic calendar system, which defines every fourth year as
            leap, much like the Julian calendar. The year is broken down into 12 months,
            each 30 days in length. An extra period at the end of the year is either 5
            or 6 days in length. In this implementation, it is considered a 13th month.
            </summary>
            <remarks>
            <para>
            Year 1 in the Coptic calendar began on August 29, 284 CE (Julian), thus
            Coptic years do not begin at the same time as Julian years. This chronology
            is not proleptic, as it does not allow dates before the first Coptic year.
            </para>
            <para>
            This implementation defines a day as midnight to midnight exactly as per
            the ISO chronology. Some references indicate that a coptic day starts at
            sunset on the previous ISO day, but this has not been confirmed and is not
            implemented.
            </para>
            </remarks>
        </member>
        <member name="F:NodaTime.Calendars.CopticCalendarSystem.AnnoMartyrm">
            <summary>
            Constant value for 'Anno Martyrum' or 'Era of the Martyrs', equivalent
            to the value returned for AD/CE.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.CopticCalendarSystem.GetInstance(System.Int32)">
            <summary>
            Returns the instance of the Coptic calendar system with the given number of days in the week.
            </summary>
            <param name="minDaysInFirstWeek">The minimum number of days at the start of the year to consider it
            a week in that year as opposed to at the end of the previous year.</param>
        </member>
        <member name="T:NodaTime.Fields.UnsupportedDateTimeField">
            <summary>
            A placeholder implementation to use when a datetime field is not supported.
            Operations which can be performed solely on the duration field delegate to that; most
            just throw <see cref="T:System.NotSupportedException"/>.
            TODO: See whether we really need the delegation, or whether DurationField could just throw.
            </summary>
        </member>
        <member name="M:NodaTime.Fields.UnsupportedDateTimeField.GetInstance(NodaTime.Fields.DateTimeFieldType,NodaTime.Fields.DurationField)">
            <summary>
            Returns an instance for the specified field type and duration field.
            The returned value is cached.
            TODO: Potentially use ReaderWriterLockSlim? Assess performance of caching in the first place...
            </summary>
        </member>
        <member name="T:NodaTime.Fields.RemainderDateTimeField">
            <summary>
            Status: Need AddWrapField
            </summary>
        </member>
        <member name="T:NodaTime.Format.INodaParser`1">
            <summary>
            Provides an interface for value parsers in the Noda Time package. The parsers
            provided by Noda Time are all immutable and thread-safe.
            </summary>
            <remarks>
            <para>
            Different implementations expose specific configuration options, such as which calendar
            system to use when parsing a value. These are not exposed on this interface, as they're
            not common to all parsers.
            </para>
            <para>
            Noda Time supports the common .NET model of overloaded ToString, Parse and TryParse methods,
            but using this type and <see cref="T:NodaTime.Format.INodaFormatter`1"/> allows formatting patterns and 
            options to be set one and then reused.
            </para>
            </remarks>
            <typeparam name="T">The type to parse.</typeparam>
        </member>
        <member name="M:NodaTime.Format.INodaParser`1.Parse(System.String)">
            <summary>
            Parses the given text using the <see cref="T:System.IFormatProvider"/> given when the parser
            was constructed. This does NOT use the current thread <see cref="T:System.IFormatProvider"/>.
            </summary>
            <exception cref="T:System.FormatException">If the text cannot be parsed.</exception>
        </member>
        <member name="M:NodaTime.Format.INodaParser`1.TryParse(System.String,`0@)">
            <summary>
            Attempts to parse the given text, but does not throw an exception if parsing fails.
            Instead, the return value indicates success or failure.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NodaTime.Format.INodaParser`1.WithFormatProvider(System.IFormatProvider)">
            <summary>
            Returns a new copy of this parser that uses the given <see cref="T:System.IFormatProvider"/> for
            formatting instead of the one that this parser uses.
            </summary>
            <param name="formatProvider">The format provider to use.</param>
            <returns>A new copy of this parser using the given <see cref="T:System.IFormatProvider"/>.</returns>
        </member>
        <member name="P:NodaTime.Format.INodaParser`1.FormatProvider">
            <summary>
            Gets the format provider use by this parse to parse values.
            </summary>
            <value>
            The format provider.
            </value>
        </member>
        <member name="T:NodaTime.TimeZones.DaylightSavingsTimeZone">
            <summary>
            Provides a basic daylight savings time zone. A DST time zone has a simple recurrence
            where an extra offset is applied between two dates of a year.
            </summary>
            <remarks>
            IMPORTANT: This class *accepts* recurrences which start from a particular year
            rather than being infinite back to the start of time, but *treats* them as if
            they were infinite. This makes various calculations easier, but this zone should
            only be used as part of a PrecalculatedDateTimeZone which will only ask it for
            values within the right portion of the timeline.
            </remarks>
        </member>
        <member name="M:NodaTime.TimeZones.DaylightSavingsTimeZone.#ctor(System.String,NodaTime.Offset,NodaTime.TimeZones.ZoneRecurrence,NodaTime.TimeZones.ZoneRecurrence)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.DaylightSavingsTimeZone"/> class.
            </summary>
            <remarks>
            At least one of the recurrences (it doesn't matter which) must be a "standard", i.e. not have any savings
            applied. The other may still not have any savings (e.g. for America/Resolute) but any savings must be
            non-negative.
            </remarks>
            <param name="id">The id.</param>
            <param name="standardOffset">The standard offset.</param>
            <param name="startRecurrence">The start recurrence.</param>
            <param name="endRecurrence">The end recurrence.</param>
        </member>
        <member name="M:NodaTime.TimeZones.DaylightSavingsTimeZone.Equals(NodaTime.TimeZones.DaylightSavingsTimeZone)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:NodaTime.TimeZones.DaylightSavingsTimeZone.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>. 
                            </param><exception cref="T:System.NullReferenceException">The <paramref name="obj"/> parameter is null.
                            </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.TimeZones.DaylightSavingsTimeZone.GetHashCode">
            <summary>
            Serves as a hash function for a particular type. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.TimeZones.DaylightSavingsTimeZone.GetZoneInterval(NodaTime.Instant)">
            <summary>
            Gets the zone interval for the given instant.
            </summary>
            <param name="instant">The Instant to test.</param>
            <returns>The ZoneInterval in effect at the given instant.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The instant falls outside the bounds
            of the recurrence rules of the zone.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.DaylightSavingsTimeZone.FindMatchingRecurrence(NodaTime.Instant)">
            <summary>
            Finds the recurrence containing the given instant, if any.
            </summary>
            <returns>The recurrence containing the given instant, or null if
            the instant occurs before the start of the earlier recurrence.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.DaylightSavingsTimeZone.NextTransition(NodaTime.Instant)">
            <summary>
            Returns the transition occurring strictly after the specified instant
            </summary>
            <param name="instant">The instant after which to consider transitions.</param>
        </member>
        <member name="M:NodaTime.TimeZones.DaylightSavingsTimeZone.PreviousTransition(NodaTime.Instant)">
            <summary>
            Returns the transition occurring strictly before the specified instant.
            </summary>
            <param name="instant">The instant before which to consider transitions.</param>
            <returns>
            The instant of the previous transition, or null if there are no further transitions.
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.DaylightSavingsTimeZone.GetOffsetFromUtc(NodaTime.Instant)">
            <summary>
            Returns the offset from UTC, where a positive duration indicates that local time is later
            than UTC. In other words, local time = UTC + offset.
            </summary>
            <param name="instant">The instant for which to calculate the offset.</param>
            <returns>
            The offset from UTC at the specified instant.
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.DaylightSavingsTimeZone.Write(NodaTime.TimeZones.DateTimeZoneWriter)">
            <summary>
            Writes the time zone to the specified writer.
            </summary>
            <param name="writer">The writer to write to.</param>
        </member>
        <member name="T:NodaTime.NamespaceDoc">
            <summary>
            <para>
            The NodaTime namespace contains the core types for NodaTime, including the public classes for time zone and calendar
            support which have implementations in other namespaces. For formatting and parsing functionality, see the
            NodaTime.Format and NodaTime.Globalization namespaces.
            </para>
            </summary>
        </member>
        <member name="T:NodaTime.Format.ParseString">
            <summary>
              Provides a simple parser for value strings.
            </summary>
        </member>
        <member name="T:NodaTime.Format.Parsable">
            <summary>
              Provides the base for parsable strings: format strings (<see cref="T:NodaTime.Format.Pattern"/>) and value
              strings (<see cref="T:NodaTime.Format.ParseString"/>).
            </summary>
        </member>
        <member name="F:NodaTime.Format.Parsable.Nul">
            <summary>
              A nul character. This character is not allowed in any parsable string and is used to
              indicate that the current character is not set.
            </summary>
        </member>
        <member name="M:NodaTime.Format.Parsable.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref="T:NodaTime.Format.Parsable"/> class.
            </summary>
            <param name="value">The string to parse.</param>
        </member>
        <member name="M:NodaTime.Format.Parsable.ToString">
            <summary>
              Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:NodaTime.Format.Parsable.GetNextCharacter">
            <summary>
              Gets the next character.
            </summary>
            <returns>The next character from the string.</returns>
            <exception cref="T:System.FormatException">if there are no more characters.</exception>
        </member>
        <member name="M:NodaTime.Format.Parsable.PeekNext">
            <summary>
              Returns the next character if there is one or <see cref="F:NodaTime.Format.Parsable.Nul"/> if there isn't.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NodaTime.Format.Parsable.Move(System.Int32)">
            <summary>
              Moves the specified target index. If the new index is out of range of the valid indicies
              for this string then the index is set to the beginning or the end of the string whichever
              is nearest the requested index.
            </summary>
            <param name="targetIndex">Index of the target.</param>
            <returns><c>true</c> if the requested index is in range.</returns>
        </member>
        <member name="M:NodaTime.Format.Parsable.MoveCurrent">
            <summary>
              Moves to the current index. This resets various values and is used when the index
              is moved manually.
            </summary>
            <returns><c>true</c> if the requested index is in range.</returns>
        </member>
        <member name="M:NodaTime.Format.Parsable.MoveNext">
            <summary>
              Moves to the enxt character.
            </summary>
            <returns><c>true</c> if the requested index is in range.</returns>
        </member>
        <member name="M:NodaTime.Format.Parsable.MovePrevious">
            <summary>
              Moves to the previous character.
            </summary>
            <returns><c>true</c> if the requested index is in range.</returns>
        </member>
        <member name="M:NodaTime.Format.Parsable.SkipWhiteSpaces">
            <summary>
              Moves the current index forward as long as the current character is a white space character.
            </summary>
            <returns><c>true</c> if the requested index is in range.</returns>
        </member>
        <member name="M:NodaTime.Format.Parsable.TrimLeadingInQuoteSpaces">
            <summary>
              If the string starts with a quoted string then any leading white space characters in
              that string are removed. This modifies the value string.
            </summary>
        </member>
        <member name="M:NodaTime.Format.Parsable.TrimLeadingWhiteSpaces">
            <summary>
              Any leading white space characters are removed. This modifies the value string.
            </summary>
        </member>
        <member name="M:NodaTime.Format.Parsable.TrimTrailingInQuoteSpaces">
            <summary>
              If the string end with a quoted string then any trailing white space characters in
              that string are removed. This modifies the value string.
            </summary>
        </member>
        <member name="M:NodaTime.Format.Parsable.TrimTrailingWhiteSpaces">
            <summary>
              Any trailing white space characters are removed. This modifies the value string.
            </summary>
        </member>
        <member name="P:NodaTime.Format.Parsable.Current">
            <summary>
              Gets the current character.
            </summary>
        </member>
        <member name="P:NodaTime.Format.Parsable.HasMoreCharacters">
            <summary>
              Gets a value indicating whether this instance has more characters.
            </summary>
            <value>
              <c>true</c> if this instance has more characters; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:NodaTime.Format.Parsable.Index">
            <summary>
              Gets the current index into the string being parsed.
            </summary>
        </member>
        <member name="P:NodaTime.Format.Parsable.Length">
            <summary>
              Gets the length of the string being parsed.
            </summary>
        </member>
        <member name="P:NodaTime.Format.Parsable.Value">
            <summary>
              Gets the string being parsed.
            </summary>
        </member>
        <member name="P:NodaTime.Format.Parsable.Remainder">
            <summary>
              Gets the remainder the string that has not been parsed yet.
            </summary>
        </member>
        <member name="M:NodaTime.Format.ParseString.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref="T:NodaTime.Format.ParseString"/> class.
            </summary>
            <param name="value">The string to parse.</param>
        </member>
        <member name="M:NodaTime.Format.ParseString.Match(System.Char)">
            <summary>
              Attempts to match the specified character with the current character of the string. If the
              character matches then the index is moved passed the character.
            </summary>
            <param name="character">The character to match.</param>
            <returns><c>true</c> if the character matches.</returns>
        </member>
        <member name="M:NodaTime.Format.ParseString.Match(System.String)">
            <summary>
              Attempts to match the specified string with the current point in the string. If the
              character matches then the index is moved passed the string.
            </summary>
            <param name="match">The string to match.</param>
            <returns><c>true</c> if the string matches.</returns>
        </member>
        <member name="M:NodaTime.Format.ParseString.ParseDigits(System.Int32,System.Int32,System.Int32@)">
            <summary>
              Parses digits at the current point in the string. If the minimum required
              digits are not present then the index is unchanged. If there are more digits than
              the maximum allowed they are ignored.
            </summary>
            <param name="minimumDigits">The minimum allowed digits.</param>
            <param name="maximumDigits">The maximum allowed digits.</param>
            <param name="result">The result integer value.</param>
            <returns><c>true</c> if the digits were parsed.</returns>
        </member>
        <member name="M:NodaTime.Format.ParseString.ParseFractionExact(System.Int32,System.Int32,System.Int32@)">
            <summary>
              Parses digits at the current point in the string as a fractional value.
            </summary>
            <param name="maximumDigits">The maximum allowed digits.</param>
            <param name="scale">The scale of the fractional value.</param>
            <param name="result">The result value scaled by scale.</param>
            <returns><c>true</c> if the digits were parsed.</returns>
        </member>
        <member name="M:NodaTime.Format.ParseString.GetDigit">
            <summary>
              Gets the integer value of the current digit character. Allows for non-roman digits.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NodaTime.Format.ParseString.IsDigit">
            <summary>
              Determines whether the current character is a digit character.
            </summary>
            <returns>
              <c>true</c> if the current character is a digit; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NodaTime.Format.InstantFormat.Format(NodaTime.Instant,System.String,System.IFormatProvider)">
            <summary>
              Handles common default processing and parameter validation for simple formatting.
            </summary>
            <param name="value">The value to format.</param>
            <param name="format">The format string. If <c>null</c> or empty defaults to "g".</param>
            <param name="formatProvider">The <see cref="T:System.IFormatProvider"/> to use. If <c>null</c> the thread's current culture is used.</param>
            <exception cref="T:System.FormatException"></exception>
            <returns>The value formatted as a string.</returns>
        </member>
        <member name="T:NodaTime.Format.InstantFormat.InstantFormatterN">
            <summary>
            A Noda formatter implementation for the N pattern (ticks as a group separated number).
            </summary>
        </member>
        <member name="M:NodaTime.Format.InstantFormat.InstantFormatterN.#ctor(System.IFormatProvider)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.Format.InstantFormat.InstantFormatterN"/> class.
            </summary>
            <param name="formatProvider">The format provider.</param>
        </member>
        <member name="T:NodaTime.Format.DurationFormatter">
            <summary>
              Provides a <see cref="T:NodaTime.Format.INodaFormatter`1"/> factory for generating <see cref="T:NodaTime.Duration"/>
              formatters base on the format string.
            </summary>
        </member>
        <member name="M:NodaTime.Format.DurationFormatter.GetFormatter(System.String)">
            <summary>
              Gets the formatter for the given format string.
            </summary>
            <param name="format">The format string.</param>
            <returns>The <see cref="T:NodaTime.Format.INodaFormatter`1"/> corresponding to the format string.</returns>
            <exception cref="T:System.FormatException">format is invalid or not supported.</exception>
        </member>
        <member name="T:NodaTime.Format.DurationFormatter.DurationGeneralFormatter">
            <summary>
              Provides an implementation of <see cref="T:NodaTime.Format.INodaFormatter`1"/> that formats <see cref="T:NodaTime.Offset"/>
              objects in the general format.
            </summary>
        </member>
        <member name="M:NodaTime.Format.DurationFormatter.DurationGeneralFormatter.Format(NodaTime.Duration)">
            <summary>
              Overridden in subclasses to provides the actual formatting implementation.
            </summary>
            <param name="value">The value to format. This can be <c>null</c> if T is a reference type.</param>
            <returns>The formatted string.</returns>
        </member>
        <member name="T:NodaTime.Format.DurationFormatter.DurationLongFormatter">
            <summary>
              Provides an implementation of <see cref="T:NodaTime.Format.INodaFormatter`1"/> that formats <see cref="T:NodaTime.Offset"/>
              objects in the general format.
            </summary>
        </member>
        <member name="M:NodaTime.Format.DurationFormatter.DurationLongFormatter.Format(NodaTime.Duration)">
            <summary>
              Overridden in subclasses to provides the actual formatting implementation.
            </summary>
            <param name="value">The value to format. This can be <c>null</c> if T is a reference type.</param>
            <returns>The formatted string.</returns>
        </member>
        <member name="T:NodaTime.Format.DurationFormatter.DurationShortFormatter">
            <summary>
              Provides an implementation of <see cref="T:NodaTime.Format.INodaFormatter`1"/> that formats <see cref="T:NodaTime.Offset"/>
              objects in the general format.
            </summary>
        </member>
        <member name="M:NodaTime.Format.DurationFormatter.DurationShortFormatter.Format(NodaTime.Duration)">
            <summary>
              Overridden in subclasses to provides the actual formatting implementation.
            </summary>
            <param name="value">The value to format. This can be <c>null</c> if T is a reference type.</param>
            <returns>The formatted string.</returns>
        </member>
        <member name="T:NodaTime.Utility.HashCodeHelper">
            <summary>
            Provides method to help with generating hash codes for structures and classes. This handles
            value types, nullable type, and objects.
            </summary>
            <remarks>
            The basic usage pattern is:
            <example>
            <code>
               public override int GetHashCode()
               {
                   int hash = HashCodeHelper.Initialize();
                   hash = HashCodeHelper.Hash(hash, Field1);
                   hash = HashCodeHelper.Hash(hash, Field1);
                   hash = HashCodeHelper.Hash(hash, Field1);
                   ...
                   return hash;
               }
            </code>
            </example>
            </remarks>
        </member>
        <member name="F:NodaTime.Utility.HashCodeHelper.HashcodeMultiplier">
            <summary>
            The multiplier for each value.
            </summary>
        </member>
        <member name="F:NodaTime.Utility.HashCodeHelper.HashcodeInitializer">
            <summary>
            The initial hash value.
            </summary>
        </member>
        <member name="M:NodaTime.Utility.HashCodeHelper.Initialize">
            <summary>
            Returns the initial value for a hash code.
            </summary>
            <returns>The initial interger value.</returns>
        </member>
        <member name="M:NodaTime.Utility.HashCodeHelper.Hash``1(System.Int32,``0)">
            <summary>
            Adds the hash value for the given value to the current hash and returns the new value.
            </summary>
            <typeparam name="T">The type of the value being hashed.</typeparam>
            <param name="code">The previous hash code.</param>
            <param name="value">The value to hash.</param>
            <returns>The new hash code.</returns>
        </member>
        <member name="M:NodaTime.Utility.HashCodeHelper.MakeHash(System.Int32,System.Int32)">
            <summary>
            Adds the hash value for a int to the current hash value and returns the new value.
            </summary>
            <param name="code">The previous hash code.</param>
            <param name="value">The value to add to the hash code.</param>
            <returns>The new hash code.</returns>
        </member>
        <member name="T:NodaTime.TimeZones.ZoneYearOffset">
            <summary>
            Defines an offset within a year as an expression that can be used to reference multiple
            years.
            </summary>
            <remarks>
            <para>
            A year offset defines a way of determining an offset into a year based on certain criteria.
            The most basic is the month of the year and the day of the month. If only these two are
            supplied then the offset is always the same day of each year. The only exception is if the
            day is February 29th, then it only refers to those years that have a February 29th.
            </para>
            <para>
            If the day of the week is specified then the offset determined by the month and day are
            adjusted to the nearest day that falls on the given day of the week. If the month and day
            fall on that day of the week then nothing changes. Otherwise the offset is moved forward or
            backward up to 6 days to make the day fall on the correct day of the week. The direction the
            offset is moved is determined by the <see cref="P:NodaTime.TimeZones.ZoneYearOffset.AdvanceDayOfWeek"/> property.
            </para>
            <para>
            Finally the <see cref="P:NodaTime.TimeZones.ZoneYearOffset.Mode"/> property deterines whether the <see cref="P:NodaTime.TimeZones.ZoneYearOffset.TickOfDay"/> value
            is added to the calculated offset to generate an offset within the day.
            </para>
            <para>
            Immutable, thread safe
            </para>
            </remarks>
        </member>
        <member name="F:NodaTime.TimeZones.ZoneYearOffset.StartOfYear">
            <summary>
            An offset that specifies the beginning of the year.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.ZoneYearOffset.Months">
            <summary>
            The months of the year names as they appear in the TZDB zone files. They are
            always the short name in US English. Extra blank name at the beginning helps
            to make the indexes to come out right.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.ZoneYearOffset.DaysOfWeek">
            <summary>
            The days of the week names as they appear in the TZDB zone files. They are
            always the short name in US English.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneYearOffset.#ctor(NodaTime.TimeZones.TransitionMode,System.Int32,System.Int32,System.Int32,System.Boolean,NodaTime.Offset)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.ZoneYearOffset"/> class.
            </summary>
            <param name="mode">The transition mode.</param>
            <param name="monthOfYear">The month year offset.</param>
            <param name="dayOfMonth">The day of month. 0 means not set. Negatives count from end of month.</param>
            <param name="dayOfWeek">The day of week. 0 menas not set.</param>
            <param name="advance">if set to <c>true</c> [advance].</param>
            <param name="tickOfDay">The tick within the day.</param>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneYearOffset.Equals(NodaTime.TimeZones.ZoneYearOffset)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneYearOffset.NormalizeModeCharacter(System.Char)">
            <summary>
            Normalizes the transition mode characater.
            </summary>
            <param name="modeCharacter">The character to normalize.</param>
            <returns>The <see cref="T:NodaTime.TimeZones.TransitionMode"/>.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneYearOffset.MakeInstant(System.Int32,NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Returns an <see cref="T:NodaTime.Instant"/> that represents the point in the given year that this
            object defines. If the exact point is not valid then the nearest point that matches the
            definition is returned.
            </summary>
            <param name="year">The year to calculate for.</param>
            <param name="standardOffset">The standard offset.</param>
            <param name="savings">The daylight savings adjustment.</param>
            <returns>The <see cref="T:NodaTime.Instant"/> of the point in the given year.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneYearOffset.Next(NodaTime.Instant,NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Returns the given instant adjusted one year forward taking into account leap years and other
            adjustments like day of week.
            </summary>
            <param name="instant">The instant to adjust.</param>
            <param name="standardOffset">The standard offset.</param>
            <param name="savings">The daylight savings adjustment.</param>
            <returns>The adjusted <see cref="T:NodaTime.LocalInstant"/>.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneYearOffset.Previous(NodaTime.Instant,NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Returns the given instant adjusted one year backward taking into account leap years and other
            adjustments like day of week.
            </summary>
            <param name="instant">The instant to adjust.</param>
            <param name="standardOffset">The standard offset.</param>
            <param name="savings">The daylight savings adjustment.</param>
            <returns>The adjusted <see cref="T:NodaTime.LocalInstant"/>.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneYearOffset.Write(NodaTime.TimeZones.DateTimeZoneWriter)">
            <summary>
            Writes this object to the given <see cref="T:NodaTime.TimeZones.DateTimeZoneCompressionWriter"/>.
            </summary>
            <param name="writer">Where to send the output.</param>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneYearOffset.AdjustInstant(NodaTime.Instant,NodaTime.Offset,NodaTime.Offset,System.Int32)">
            <summary>
            Adjusts the instant one year in the given direction.
            </summary>
            <remarks>
            If there is an overflow/underflow in any operation performed in this method then <see cref="F:NodaTime.Instant.MinValue"/> or <see cref="F:NodaTime.Instant.MaxValue"/> will be returned depending
            on <paramref name="direction"/>.
            </remarks>
            <param name="instant">The instant to adjust.</param>
            <param name="standardOffset">The standard offset.</param>
            <param name="savings">The daylight savings adjustment.</param>
            <param name="direction">The direction to adjust. 1 for forward, -1 for backward.</param>
            <returns>The adjusted <see cref="T:NodaTime.Instant"/>.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneYearOffset.SetDayOfMonthWithLeap(NodaTime.CalendarSystem,NodaTime.LocalInstant,System.Int32)">
            <summary>
            Sets the day of month handling leap years.
            </summary>
            <remarks>
            If the day of the month is February 29 then the starting year is a leap year and we have
            to go forward or back to the next or previous leap year or February 29 will be an
            invalid date.
            </remarks>
            <param name="calendar">The calendar to use to set the values.</param>
            <param name="instant">The instant to adjust.</param>
            <param name="direction"></param>
            <returns>The adjusted <see cref="T:NodaTime.LocalInstant"/>.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneYearOffset.SetDayOfMonth(NodaTime.CalendarSystem,NodaTime.LocalInstant)">
            <summary>
            Sets the day of month of the given instant. If the day of the month is negative then sets the
            day from the end of the month.
            </summary>
            <param name="calendar">The calendar to use to set the values.</param>
            <param name="instant">The instant to adjust.</param>
            <returns>The adjusted <see cref="T:NodaTime.LocalInstant"/>.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneYearOffset.SetDayOfWeek(NodaTime.CalendarSystem,NodaTime.LocalInstant)">
            <summary>
            Sets the day of week of the given instant.
            </summary>
            <remarks>
            This will move the current day of the week either forward or backward by up to one week.
            If the day of the week is already correct then nothing changes.
            </remarks>
            <param name="calendar">The calendar to use to set the values.</param>
            <param name="instant">The instant to adjust.</param>
            <returns>The adjusted <see cref="T:NodaTime.LocalInstant"/>.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneYearOffset.GetOffset(NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Returns the offset to use for this object's <see cref="T:NodaTime.TimeZones.TransitionMode"/>.
            </summary>
            <param name="standardOffset">The standard offset.</param>
            <param name="savings">The daylight savings adjustment.</param>
            <returns>The base time offset as a <see cref="T:NodaTime.Duration"/>.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneYearOffset.op_Equality(NodaTime.TimeZones.ZoneYearOffset,NodaTime.TimeZones.ZoneYearOffset)">
            <summary>
            Implements the operator ==.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneYearOffset.op_Inequality(NodaTime.TimeZones.ZoneYearOffset,NodaTime.TimeZones.ZoneYearOffset)">
            <summary>
            Implements the operator !=.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneYearOffset.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
            <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance;
            otherwise, <c>false</c>.
            </returns>
            <exception cref="T:System.NullReferenceException">
            The <paramref name="obj"/> parameter is null.
            </exception>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneYearOffset.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data
            structures like a hash table. 
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneYearOffset.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneYearOffset.Mode">
            <summary>
            Gets the method by which offsets are added to Instants to get LocalInstants.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneYearOffset.MonthOfYear">
            <summary>
            Gets the month of year the rule starts.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneYearOffset.DayOfMonth">
            <summary>
            Gets the day of month this rule starts.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneYearOffset.DayOfWeek">
            <summary>
            Gets the day of week this rule starts.
            </summary>
            <value>The integer day of week (1=Mon, 2=Tue, etc.). 0 means not set.</value>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneYearOffset.AdvanceDayOfWeek">
            <summary>
            Gets a value indicating whether [advance day of week].
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneYearOffset.TickOfDay">
            <summary>
            Gets the tick of day when the rule takes effect.
            </summary>
        </member>
        <member name="T:NodaTime.TimeZones.Tzdb">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.Tzdb.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.Tzdb.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="T:NodaTime.Calendars.IsoCalendarSystem">
            <summary>
            Implements a calendar system that follows the rules of the ISO8601 standard,
            which is compatible with Gregorian for all modern dates. This class is a singleton.
            </summary>
            <remarks>
            <para>
            When ISO does not define a field, but it can be determined (such as AM/PM) it is included.
            </para>
            <para>
            With the exception of century related fields, IsoCalendarSystem is exactly the
            same as <see cref="T:NodaTime.Calendars.GregorianCalendarSystem"/>. In this chronology, centuries and year
            of century are zero based. For all years, the century is determined by
            dropping the last two digits of the year, ignoring sign. The year of century
            is the value of the last two year digits.
            </para>
            </remarks>
        </member>
        <member name="T:NodaTime.Fields.FieldUtils">
            <summary>
            TODO: Potentially remove this. Can move VerifyValueBounds into DateTimeField, probably.
            </summary>
        </member>
        <member name="M:NodaTime.Fields.FieldUtils.VerifyValueBounds(NodaTime.Fields.DateTimeFieldType,System.Int64,System.Int64,System.Int64)">
            <summary>
            Verifies the input value against the specified range, for the given field type.
            </summary>
            <param name="fieldType">The field type</param>
            <param name="value">The value to verify</param>
            <param name="lowerBound">The minimum valid value</param>
            <param name="upperBound">The maximum valid value</param>
        </member>
        <member name="M:NodaTime.Fields.FieldUtils.VerifyFieldValue(NodaTime.Fields.DateTimeField,System.String,System.Int64)">
            <summary>
            Verifies the input value against the valid range of the calendar field.
            </summary>
            <param name="field">The calendar field definition.</param>
            <param name="name">The name of the field for the error message.</param>
            <param name="value">The value to check.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">If the given value is not in the valid range of the given calendar field.</exception>
        </member>
        <member name="M:NodaTime.Fields.FieldUtils.VerifyFieldValue(NodaTime.Fields.DateTimeField,System.String,System.Int64,System.Boolean)">
            <summary>
            Verifies the input value against the valid range of the calendar field.
            </summary>
            <param name="field">The calendar field definition.</param>
            <param name="name">The name of the field for the error message.</param>
            <param name="value">The value to check.</param>
            <param name="allowNegated">if set to <c>true</c> all the range of value to be the negative as well.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">If the given value is not in the valid range of the given calendar field.</exception>
        </member>
        <member name="M:NodaTime.Fields.FieldUtils.GetWrappedValue(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Utility method used by AddWrapField implementations to ensure the new
            value lies within the field's legal value range.
            </summary>
            <param name="currentValue">The current value of the data, which may lie outside the wrapped value range</param>
            <param name="wrapValue">The value to add to current value before wrapping. This may be negative.</param>
            <param name="minValue">The wrap range minimum value.</param>
            <param name="maxValue">The wrap range maximum value. This must be greater than minValue (checked by the method).</param>
            <returns>The wrapped value</returns>
            <exception cref="T:System.ArgumentException">If minValue is greater than or equal to maxValue</exception>
        </member>
        <member name="M:NodaTime.Fields.FieldUtils.GetWrappedValue(System.Int32,System.Int32,System.Int32)">
            <summary>
            Utility method that ensures the given value lies within the field's
            legal value range.
            </summary>
            <param name="value">The value to fit into the wrapped value range</param>
            <param name="minValue">Whe wrap range minimum value.</param>
            <param name="maxValue">The wrap range maximum value. This must be greater than minValue (checked by the method).</param>
            <returns>The wrapped value</returns>
            <exception cref="T:System.ArgumentException">If minValue is greater than or equal to maxValue</exception>        
        </member>
        <member name="T:NodaTime.Fields.BasicWeekYearDateTimeField">
            <summary>
            Provides time calculations for the week of the weekyear component of time.
            </summary>
        </member>
        <member name="M:NodaTime.Fields.BasicWeekYearDateTimeField.GetValue(NodaTime.LocalInstant)">
            <summary>
            Get the Year of a week based year component of the specified local instant.
            </summary>
            <param name="localInstant">The local instant to query</param>
            <returns>The year extracted from the input.</returns>
        </member>
        <member name="M:NodaTime.Fields.BasicWeekYearDateTimeField.GetInt64Value(NodaTime.LocalInstant)">
            <summary>
            Get the Year of a week based year component of the specified local instant.
            </summary>
            <param name="localInstant">The local instant to query</param>
            <returns>The year extracted from the input.</returns>
        </member>
        <member name="P:NodaTime.Fields.BasicWeekYearDateTimeField.RangeDurationField">
            <summary>
            Always returns null(not supported)
            </summary>
        </member>
        <member name="P:NodaTime.Fields.BasicWeekYearDateTimeField.IsLenient">
            <summary>
            Always returns false, that means that it does not accept values that
            are out of bounds.
            </summary>
        </member>
        <member name="T:NodaTime.LocalDate">
            <summary>
            LocalDate is an immutable struct representing a date within the calendar,
            with no reference to a particular time zone or time of day.
            </summary>
        </member>
        <member name="M:NodaTime.LocalDate.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructs an instance for the given year, month and day in the ISO calendar.
            </summary>
        </member>
        <member name="M:NodaTime.LocalDate.#ctor(System.Int32,System.Int32,System.Int32,NodaTime.CalendarSystem)">
            <summary>
            Constructs an instance for the given year, month and day in the specified calendar.
            </summary>
        </member>
        <member name="M:NodaTime.LocalDate.op_Addition(NodaTime.LocalDate,NodaTime.Period)">
            <summary>
            Adds the specified period to the date.
            </summary>
        </member>
        <member name="M:NodaTime.LocalDate.op_Addition(NodaTime.LocalDate,NodaTime.LocalTime)">
            <summary>
            Combines the given <see cref="T:NodaTime.LocalDate"/> and <code>LocalTime</code> components
            into a single <see cref="P:NodaTime.LocalDate.LocalDateTime"/>.
            </summary>
        </member>
        <member name="M:NodaTime.LocalDate.op_Subtraction(NodaTime.LocalDate,NodaTime.Period)">
            <summary>
            Subtracts the specified period to the date.
            </summary>
        </member>
        <member name="M:NodaTime.LocalDate.op_Equality(NodaTime.LocalDate,NodaTime.LocalDate)">
            <summary>
            Compares two <code>LocalDate</code> values for equality. This requires
            that the dates be the same, within the same calendar.
            </summary>
        </member>
        <member name="M:NodaTime.LocalDate.op_Inequality(NodaTime.LocalDate,NodaTime.LocalDate)">
            <summary>
            Compares two <code>LocalDate</code> values for inequality.
            </summary>
        </member>
        <member name="M:NodaTime.LocalDate.ToString">
            <summary>
            Formats this local date according to the current format provider.
            </summary>
        </member>
        <member name="M:NodaTime.LocalDate.GetHashCode">
            <summary>
            Returns a hash code for this local date.
            </summary>
        </member>
        <member name="M:NodaTime.LocalDate.Equals(System.Object)">
            <summary>
            Compares two <code>LocalDate</code> values for equality. This requires
            that the dates be the same, within the same calendar.
            </summary>
        </member>
        <member name="P:NodaTime.LocalDate.Calendar">
            <summary>
            Gets the calendar system associated with this local date.
            </summary>
        </member>
        <member name="P:NodaTime.LocalDate.Year">
            <summary>
            Gets the year of this local date.
            </summary>
        </member>
        <member name="P:NodaTime.LocalDate.MonthOfYear">
            <summary>
            Gets the month of this local date within the year.
            </summary>
        </member>
        <member name="P:NodaTime.LocalDate.DayOfMonth">
            <summary>
            Gets the day of this local date within the month.
            </summary>
        </member>
        <member name="P:NodaTime.LocalDate.IsoDayOfWeek">
            <summary>
            Week day of this local date expressed as an <see cref="T:NodaTime.IsoDayOfWeek"/> value,
            for calendars which use ISO days of the week.
            </summary>
            <exception cref="T:System.InvalidOperationException">The underlying calendar doesn't use ISO days of the week.</exception>
        </member>
        <member name="P:NodaTime.LocalDate.DayOfWeek">
            <summary>
            Week day of this local date as a number.
            </summary>
            <remarks>
            For calendars using ISO week days, this gives 1 for Monday to 7 for Sunday.
            </remarks>
            <seealso cref="P:NodaTime.LocalDate.IsoDayOfWeek"/>
        </member>
        <member name="P:NodaTime.LocalDate.WeekYear">
            <summary>
            Gets the "week year" of this local date.
            </summary>
            <remarks>
            <para>
            The WeekYear is the year that matches with the WeekOfWeekYear field.
            In the standard ISO8601 week algorithm, the first week of the year
            is that in which at least 4 days are in the year. As a result of this
            definition, day 1 of the first week may be in the previous year.
            The WeekYear allows you to query the effective year for that day
            </para>
            <para>
            For example, January 1st 2011 was a Saturday, so only two days of that week
            (Saturday and Sunday) were in 2011. Therefore January 1st is part of
            week 52 of WeekYear 2010. Conversely, December 31st 2012 is a Monday,
            so is part of week 1 of WeekYear 2013.
            </para>
            </remarks>
        </member>
        <member name="P:NodaTime.LocalDate.WeekOfWeekYear">
            <summary>
            Gets the week within the WeekYear. See <see cref="P:NodaTime.LocalDate.WeekYear"/> for more details.
            </summary>
        </member>
        <member name="P:NodaTime.LocalDate.YearOfCentury">
            <summary>
            Gets the year of this local date within the century.
            </summary>
        </member>
        <member name="P:NodaTime.LocalDate.YearOfEra">
            <summary>
            Gets the year of this local date within the era.
            </summary>
        </member>
        <member name="P:NodaTime.LocalDate.DayOfYear">
            <summary>
            Gets the day of this local date within the year.
            </summary>
        </member>
        <member name="P:NodaTime.LocalDate.LocalDateTime">
            <summary>
            Gets a <see cref="P:NodaTime.LocalDate.LocalDateTime"/> at midnight on the date represented by this local date, in the same calendar system.
            </summary>
        </member>
        <member name="T:NodaTime.IsoDayOfWeek">
            <summary>
            Equates the days of the week with their numerical value according to
            ISO-8601. This corresponds with System.DayOfWeek except for Sunday, which
            is 7 in the ISO numbering and 0 in System.DayOfWeek.
            </summary>
        </member>
        <member name="F:NodaTime.IsoDayOfWeek.None">
            <summary>
            Value indicating no day of the week; this will never be returned
            by any IsoDayOfWeek property.
            </summary>
        </member>
        <member name="F:NodaTime.IsoDayOfWeek.Monday">
            <summary>
            Value representing Monday (1).
            </summary>
        </member>
        <member name="F:NodaTime.IsoDayOfWeek.Tuesday">
            <summary>
            Value representing Tuesday (2).
            </summary>
        </member>
        <member name="F:NodaTime.IsoDayOfWeek.Wednesday">
            <summary>
            Value representing Wednesday (3).
            </summary>
        </member>
        <member name="F:NodaTime.IsoDayOfWeek.Thursday">
            <summary>
            Value representing Thursday (4).
            </summary>
        </member>
        <member name="F:NodaTime.IsoDayOfWeek.Friday">
            <summary>
            Value representing Friday (5).
            </summary>
        </member>
        <member name="F:NodaTime.IsoDayOfWeek.Saturday">
            <summary>
            Value representing Saturday (6).
            </summary>
        </member>
        <member name="F:NodaTime.IsoDayOfWeek.Sunday">
            <summary>
            Value representing Sunday (7).
            </summary>
        </member>
        <member name="T:NodaTime.Globalization.NodaFormatInfo">
            <summary>
              Defines how NodaTime values are formatted and displayed, depending on the culture.
            </summary>
        </member>
        <member name="M:NodaTime.Globalization.NodaFormatInfo.#ctor(System.Globalization.CultureInfo)">
            <summary>
              Initializes a new instance of the <see cref="T:NodaTime.Globalization.NodaFormatInfo"/> class.
            </summary>
            <param name="cultureInfo">The culture info to base this on.</param>
        </member>
        <member name="M:NodaTime.Globalization.NodaFormatInfo.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
        </member>
        <member name="M:NodaTime.Globalization.NodaFormatInfo.GetFormat(System.Type)">
            <summary>
              Returns an object that provides formatting services for the specified type.
            </summary>
            <param name="formatType">An object that specifies the type of format object to return.</param>
            <returns>
              An instance of the object specified by <paramref name = "formatType" />, if the <see cref="T:System.IFormatProvider" />
              implementation can supply that type of object; otherwise, null.
            </returns>
        </member>
        <member name="M:NodaTime.Globalization.NodaFormatInfo.ClearCache">
            <summary>
              Clears the cache.
            </summary>
        </member>
        <member name="M:NodaTime.Globalization.NodaFormatInfo.GetFormatInfo(System.Globalization.CultureInfo)">
            <summary>
              Gets the <see cref="T:NodaTime.Globalization.NodaFormatInfo"/> for the given <see cref="P:NodaTime.Globalization.NodaFormatInfo.CultureInfo"/>.
            </summary>
            <param name="cultureInfo">The culture info.</param>
            <returns>The <see cref="T:NodaTime.Globalization.NodaFormatInfo"/>. Will next be <c>null</c>.</returns>
        </member>
        <member name="M:NodaTime.Globalization.NodaFormatInfo.GetInstance(System.IFormatProvider)">
            <summary>
              Gets the <see cref="T:NodaTime.Globalization.NodaFormatInfo"/> for the given <see cref="T:System.IFormatProvider"/>. If the
              format provider is <c>null</c> or if it does not provide a <see cref="T:NodaTime.Globalization.NodaFormatInfo"/>
              object then the format object for the current thread is returned.
            </summary>
            <param name="provider">The <see cref="T:System.IFormatProvider"/>.</param>
            <returns>The <see cref="T:NodaTime.Globalization.NodaFormatInfo"/>. Will next be <c>null.</c></returns>
        </member>
        <member name="M:NodaTime.Globalization.NodaFormatInfo.SetFormatInfo(System.Globalization.CultureInfo,NodaTime.Globalization.NodaFormatInfo)">
            <summary>
              Sets the <see cref="T:NodaTime.Globalization.NodaFormatInfo"/> to use for the given culture.
            </summary>
            <param name="cultureInfo">The culture info.</param>
            <param name="formatInfo">The format info.</param>
        </member>
        <member name="M:NodaTime.Globalization.NodaFormatInfo.ToString">
            <summary>
              Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.CultureInfo">
            <summary>
              Gets the culture info.
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.NumberFormat">
            <summary>
              Gets or sets the number format.
            </summary>
            <value>
              The <see cref="T:System.Globalization.NumberFormatInfo"/>. May not be <c>null</c>.
            </value>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.DateTimeFormat">
            <summary>
              Gets or sets the date time format.
            </summary>
            <value>
              The <see cref="T:System.Globalization.DateTimeFormatInfo"/>. May not be <c>null</c>.
            </value>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.DecimalSeparator">
            <summary>
              Gets the decimal separator.
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.Name">
            <summary>
            Name of the culture providing this formatting information.
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.PositiveSign">
            <summary>
              Gets the positive sign.
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.NegativeSign">
            <summary>
              Gets the negative sign.
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.TimeSeparator">
            <summary>
              Gets the time separator.
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.DateSeparator">
            <summary>
              Gets the date separator.
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.CurrentInfo">
            <summary>
              Gets the <see cref="T:NodaTime.Globalization.NodaFormatInfo"/> object for the current thread.
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.IsReadOnly">
            <summary>
              Gets or sets a value indicating whether this instance is read only.
            </summary>
            <value>
              <c>true</c> if this instance is read only; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.OffsetPatternFull">
            <summary>
              Gets or sets the <see cref="T:NodaTime.Offset"/> "F" pattern.
            </summary>
            <value>
              The offset full pattern.
            </value>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.OffsetPatternLong">
            <summary>
              Gets or sets the <see cref="T:NodaTime.Offset"/> "L" pattern.
            </summary>
            <value>
              The offset pattern long.
            </value>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.OffsetPatternMedium">
            <summary>
              Gets or sets the <see cref="T:NodaTime.Offset"/> "M" pattern.
            </summary>
            <value>
              The offset pattern medium.
            </value>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.OffsetPatternShort">
            <summary>
              Gets or sets the <see cref="T:NodaTime.Offset"/> "S" pattern.
            </summary>
            <value>
              The offset pattern short.
            </value>
        </member>
        <member name="T:NodaTime.Format.Pattern">
            <summary>
              Provides a simple pattern string parser for format strings.
            </summary>
        </member>
        <member name="M:NodaTime.Format.Pattern.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref="T:NodaTime.Format.Pattern"/> class.
            </summary>
            <param name="pattern">The format pattern string.</param>
        </member>
        <member name="M:NodaTime.Format.Pattern.GetQuotedString">
            <summary>
              Gets the quoted string using the current character as the close quote character.
            </summary>
            <returns>The quoted string sans open and close quotes. This can be an empty string but will not be <c>null</c>.</returns>
            <exception cref="T:System.FormatException">If the end quote is missing.</exception>
        </member>
        <member name="M:NodaTime.Format.Pattern.GetQuotedString(System.Char)">
            <summary>
              Gets the quoted string.
            </summary>
            <param name="closeQuote">The close quote character to match for the end of the quoted string.</param>
            <returns>The quoted string sans open and close quotes. This can be an empty string but will not be <c>null</c>.</returns>
            <exception cref="T:System.FormatException">If the end quote is missing.</exception>
        </member>
        <member name="M:NodaTime.Format.Pattern.GetRepeatCount(System.Int32)">
            <summary>
              Gets the pattern repeat count.
            </summary>
            <param name="maximumCount">The maximum number of repetitions allowed.</param>
            <returns>The repetition count which is alway at least <c>1</c>.</returns>
            <exception cref="T:System.FormatException">if the count exceeds <paramref name="maximumCount"/>.</exception>
        </member>
        <member name="M:NodaTime.Format.Pattern.GetRepeatCount(System.Int32,System.Char)">
            <summary>
              Gets the pattern repeat count.
            </summary>
            <param name="maximumCount">The maximum number of repetitions allowed.</param>
            <param name="patternCharacter">The pattern character to count.</param>
            <returns>The repetition count which is alway at least <c>1</c>.</returns>
            <exception cref="T:System.FormatException">if the count exceeds <paramref name="maximumCount"/>.</exception>
        </member>
        <member name="T:NodaTime.Calendars.JulianCalendarSystem">
            <summary>
            Implements a pure proleptic Julian calendar system, which defines every
            fourth year as leap. This implementation follows the leap year rule
            strictly, even for dates before 8 CE, where leap years were actually
            irregular. In the Julian calendar, year zero does not exist: 1 BCE is
            followed by 1 CE.
            </summary>
            <remarks>
            Although the Julian calendar did not exist before 45 BCE, this chronology
            assumes it did, thus it is proleptic. This implementation also fixes the
            start of the year at January 1.
            </remarks>
        </member>
        <member name="M:NodaTime.Calendars.JulianCalendarSystem.GetInstance(System.Int32)">
            <summary>
            Returns the instance of the Julian calendar system with the given number of days in the week.
            </summary>
            <param name="minDaysInFirstWeek">The minimum number of days at the start of the year to consider it
            a week in that year as opposed to at the end of the previous year.</param>
        </member>
        <member name="T:NodaTime.SystemClock">
            <summary>
            Singleton implementation of <see cref="T:NodaTime.IClock"/> which reads the current system time.
            </summary>
        </member>
        <member name="F:NodaTime.SystemClock.Instance">
            <summary>
            The singleton instance of <see cref="T:NodaTime.SystemClock"/>.
            </summary>
            <value>The singleton instance of <see cref="T:NodaTime.SystemClock"/>.</value>
        </member>
        <member name="P:NodaTime.SystemClock.Now">
            <summary>
            Gets the current time as an <see cref="T:NodaTime.Instant"/>.
            </summary>
            <value>The current time in ticks as an <see cref="T:NodaTime.Instant"/>.</value>
        </member>
        <member name="P:NodaTime.SystemClock.SystemNow">
            <summary>
            Retrieves the current system time; equivalent to calling <c>SystemClock.Instance.Now</c>.
            </summary>
        </member>
        <member name="T:NodaTime.Fields.UnsupportedDurationField">
            <summary>
            A placeholder implementation to use when a duration field is not supported.
            <para>
            UnsupportedDurationField is thread-safe and immutable.
            </para>
            </summary>
        </member>
        <member name="M:NodaTime.Fields.UnsupportedDurationField.ForFieldType(NodaTime.Fields.DurationFieldType)">
            <summary>
            Gets an instance of UnsupportedDurationField for a specific named field.
            The returned instance is cached.
            </summary>
            <param name="fieldType">The type to obtain</param>
            <returns>The instance</returns>
        </member>
        <member name="M:NodaTime.Fields.UnsupportedDurationField.GetValue(NodaTime.Duration)">
            <summary>
            Always throws NotSupportedException
            </summary>
            <param name="duration">The duration to query, which may be negative</param>
            <returns>The value of the field, in the units of the field, which may be negative</returns>
        </member>
        <member name="M:NodaTime.Fields.UnsupportedDurationField.GetInt64Value(NodaTime.Duration)">
            <summary>
            Always throws NotSupportedException
            </summary>
            <param name="duration">The duration to query, which may be negative</param>
            <returns>The value of the field, in the units of the field, which may be negative</returns>
        </member>
        <member name="M:NodaTime.Fields.UnsupportedDurationField.GetValue(NodaTime.Duration,NodaTime.LocalInstant)">
            <summary>
            Always throws NotSupportedException
            </summary>
            <param name="duration">The duration to query, which may be negative</param>
            <param name="localInstant">The start instant to calculate relative to</param>
            <returns>The value of the field, in the units of the field, which may be negative</returns>
        </member>
        <member name="M:NodaTime.Fields.UnsupportedDurationField.GetInt64Value(NodaTime.Duration,NodaTime.LocalInstant)">
            <summary>
            Always throws NotSupportedException
            </summary>
            <param name="duration">The duration to query, which may be negative</param>
            <param name="localInstant">The start instant to calculate relative to</param>
            <returns>The value of the field, in the units of the field, which may be negative</returns>
        </member>
        <member name="M:NodaTime.Fields.UnsupportedDurationField.GetDuration(System.Int64)">
            <summary>
            Always throws NotSupportedException
            </summary>
            <param name="value">The value of the field, which may be negative</param>
            <returns>The duration that the field represents, which may be negative</returns>
        </member>
        <member name="M:NodaTime.Fields.UnsupportedDurationField.GetDuration(System.Int64,NodaTime.LocalInstant)">
            <summary>
            Always throws NotSupportedException
            </summary>
            <param name="value">The value of the field, which may be negative</param>
            <param name="localInstant">The instant to calculate relative to</param>
            <returns>The duration that the field represents, which may be negative</returns>
        </member>
        <member name="M:NodaTime.Fields.UnsupportedDurationField.Add(NodaTime.LocalInstant,System.Int32)">
            <summary>
            Always throws NotSupportedException
            </summary>
            <param name="localInstant">The local instant to add to</param>
            <param name="value">The value to add, in the units of the field</param>
            <returns>The updated local instant</returns>
        </member>
        <member name="M:NodaTime.Fields.UnsupportedDurationField.Add(NodaTime.LocalInstant,System.Int64)">
            <summary>
            Always throws NotSupportedException
            </summary>
            <param name="localInstant">The local instant to add to</param>
            <param name="value">The value to add, in the units of the field</param>
            <returns>The updated local instant</returns>
        </member>
        <member name="M:NodaTime.Fields.UnsupportedDurationField.GetDifference(NodaTime.LocalInstant,NodaTime.LocalInstant)">
            <summary>
            Always throws NotSupportedException
            </summary>
            <param name="minuendInstant">The local instant to subtract from</param>
            <param name="subtrahendInstant">The local instant to subtract from minuendInstant</param>
            <returns>The difference in the units of this field</returns>
        </member>
        <member name="M:NodaTime.Fields.UnsupportedDurationField.GetInt64Difference(NodaTime.LocalInstant,NodaTime.LocalInstant)">
            <summary>
            Always throws NotSupportedException
            </summary>
            <param name="minuendInstant">The local instant to subtract from</param>
            <param name="subtrahendInstant">The local instant to subtract from minuendInstant</param>
            <returns>The difference in the units of this field</returns>
        </member>
        <member name="P:NodaTime.Fields.UnsupportedDurationField.IsSupported">
            <summary>
            This field is not supported, always returns false
            </summary>
        </member>
        <member name="P:NodaTime.Fields.UnsupportedDurationField.IsPrecise">
            <summary>
            This field is precise, always returns true
            </summary>
        </member>
        <member name="P:NodaTime.Fields.UnsupportedDurationField.UnitTicks">
            <summary>
            Always returns zero.
            </summary>
        </member>
        <member name="T:NodaTime.Fields.BasicYearDateTimeField">
            <summary>
            A year field suitable for many calendars.
            </summary>
        </member>
        <member name="M:NodaTime.Fields.BasicYearDateTimeField.GetValue(NodaTime.LocalInstant)">
            <summary>
            Get the Year component of the specified local instant.
            </summary>
            <param name="localInstant">The local instant to query</param>
            <returns>The year extracted from the input.</returns>
        </member>
        <member name="M:NodaTime.Fields.BasicYearDateTimeField.GetInt64Value(NodaTime.LocalInstant)">
            <summary>
            Get the Year component of the specified local instant.
            </summary>
            <param name="localInstant">The local instant to query</param>
            <returns>The year extracted from the input.</returns>
        </member>
        <member name="P:NodaTime.Fields.BasicYearDateTimeField.RangeDurationField">
            <summary>
            Always returns null(not supported)
            </summary>
        </member>
        <member name="P:NodaTime.Fields.BasicYearDateTimeField.IsLenient">
            <summary>
            Always returns false, that means that it does not accept values that
            are out of bounds.
            </summary>
        </member>
        <member name="T:NodaTime.FieldValueException">
            <summary>
            Exception thrown when attempting to set a field outside its supported range.
            </summary>
        </member>
        <member name="T:NodaTime.Utility.ResourceHelper">
            <summary>
            Provides helper methods for using resources.
            </summary>
        </member>
        <member name="M:NodaTime.Utility.ResourceHelper.GetMessage(System.String,System.Object[])">
            <summary>
            Returns the message string from the package resources formatted with the given replacement parameters.
            </summary>
            <remarks>
            <para>
            If there is no resource string with the given id then the id is returned as the message. 
            </para>
            </remarks>
            <param name="id">the message id to retrieve.</param>
            <param name="replacements">The optional replacement parameters.</param>
            <returns>The formatted string.</returns>
        </member>
        <member name="M:NodaTime.Utility.ResourceHelper.GetMessage(System.IFormatProvider,System.String,System.String,System.Object[])">
            <summary>
            Returns the message string from the package resources formatted with the given replacement parameters.
            </summary>
            <remarks>
            <para>
            If there is no resource string with the given id then the id is returned as the message. 
            </para>
            </remarks>
            <param name="formatProvider"></param>
            <param name="invariant"></param>
            <param name="id">the message id to retrieve.</param>
            <param name="replacements">The optional replacement parameters.</param>
            <returns>The formatted string.</returns>
        </member>
        <member name="M:NodaTime.Utility.ResourceHelper.NormalizeAsResourceName(System.String)">
            <summary>
            Normalizes the given name into a valid resource name by replacing invalid
            characters with alternatives.
            </summary>
            <param name="name">The name to normalize.</param>
            <returns>The normalized name.</returns>
        </member>
        <member name="M:NodaTime.Utility.ResourceHelper.GetDefaultResourceSet(System.Resources.ResourceManager)">
            <summary>
            Gets the default <see cref="T:System.Resources.ResourceSet"/> from a <see cref="T:System.Resources.ResourceManager"/>.
            </summary>
            <param name="manager">The <see cref="T:System.Resources.ResourceManager"/> to get resources from.</param>
            <returns>The default <see cref="T:System.Resources.ResourceSet"/>.</returns>
            <remarks>The default <see cref="T:System.Resources.ResourceSet"/> for a <see cref="T:System.Resources.ResourceManager"/> is the <see cref="T:System.Resources.ResourceSet"/> that is used by <see cref="M:System.Resources.ResourceManager.GetObject(System.String)"/>.</remarks>
        </member>
        <member name="M:NodaTime.Utility.ResourceHelper.LoadDictionary(System.Resources.ResourceSet,System.String)">
            <summary>
            Loads a dictionary of string to string with the given name from the given resource manager.
            </summary>
            <param name="source">The <see cref="T:System.Resources.ResourceSet"/> to load from.</param>
            <param name="name">The resource name.</param>
            <returns>The <see cref="T:System.Collections.Generic.IDictionary`2"/> or <c>null</c> if there is no such resource.</returns>
        </member>
        <member name="M:NodaTime.Utility.ResourceHelper.LoadTimeZone(System.Resources.ResourceSet,System.String,System.String)">
            <summary>
            Loads a time zone with the given name from the given resource manager.
            </summary>
            <param name="source">The <see cref="T:System.Resources.ResourceSet"/> to load from.</param>
            <param name="name">The resource name.</param>
            <param name="id">The time zone id for the loaded time zone.</param>
            <returns>The <see cref="T:NodaTime.DateTimeZone"/> or <c>null</c> if there is no such resource.</returns>
        </member>
        <member name="T:NodaTime.Fields.DateTimeFieldType">
            <summary>
            Type of a date time field. This is a "smart enum" type.
            </summary>
        </member>
        <member name="M:NodaTime.Fields.DateTimeFieldType.GetField(NodaTime.CalendarSystem)">
            <summary>
            Gets a suitable field for this type from the given calendar.
            </summary>
            <param name="calendar">The calendar to use</param>
            <returns>A suitable field</returns>
        </member>
        <member name="T:NodaTime.TimeZones.CachedDateTimeZone">
            <summary>
             Provides a <see cref="T:NodaTime.DateTimeZone"/> wrapper class that implements a simple cache to
             speed up the lookup of transitions.
            </summary>
            <remarks>
            <para>
            The cache supports multiple caching strategies which are implemented in nested subclasses of
            this one. Until we have a better sense of what the usage behavior is, we cannot tune the
            cache. It is possible that we may support multiple strategies selectable at runtime so the
            user can tune the performance based on their knowledge of how they are using the system.
            </para>
            <para>
            In fact, only one cache type is currently implemented: an MRU cache existed before
            the GetZoneIntervals call was created in DateTimeZone, but as it wasn't being used, it
            was more effort than it was worth to update. The mechanism is still available for future
            expansion though.
            </para>
            </remarks>
        </member>
        <member name="M:NodaTime.TimeZones.CachedDateTimeZone.#ctor(NodaTime.DateTimeZone)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.CachedDateTimeZone"/> class.
            </summary>
            <param name="timeZone">The time zone to cache.</param>
        </member>
        <member name="M:NodaTime.TimeZones.CachedDateTimeZone.ForZone(NodaTime.DateTimeZone)">
            <summary>
            Returns a cached time zone for the given time zone.
            </summary>
            <remarks>
            If the time zone is already cached or it is fixed then it is returned unchanged.
            </remarks>
            <param name="timeZone">The time zone to cache.</param>
            <returns>The cached time zone.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.CachedDateTimeZone.ForZone(NodaTime.DateTimeZone,NodaTime.TimeZones.CachedDateTimeZone.CacheType)">
            <summary>
            Returns a cached time zone for the given time zone.
            </summary>
            <remarks>
            If the time zone is already cached or it is fixed then it is returned unchanged.
            </remarks>
            <param name="timeZone">The time zone to cache.</param>
            <param name="type">The type of cache to store the zone in.</param>
            <returns>The cached time zone.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.CachedDateTimeZone.Write(NodaTime.TimeZones.DateTimeZoneWriter)">
            <summary>
            Writes the time zone to the specified writer.
            </summary>
            <param name="writer">The writer to write to.</param>
        </member>
        <member name="M:NodaTime.TimeZones.CachedDateTimeZone.Read(NodaTime.TimeZones.DateTimeZoneReader,System.String)">
            <summary>
            Reads the zone from the specified reader.
            </summary>
            <param name="reader">The reader.</param>
            <param name="id">The id.</param>
            <returns></returns>
        </member>
        <member name="P:NodaTime.TimeZones.CachedDateTimeZone.TimeZone">
            <summary>
            Gets the cached time zone.
            </summary>
            <value>The time zone.</value>
        </member>
        <member name="T:NodaTime.TimeZones.CachedDateTimeZone.HashArrayCache">
            <summary>
            This provides a simple cache based on two hash tables (one for local instants, another
            for instants).
            </summary>
            <remarks>
            Each hash table entry is either entry or contains a node with enough
            information for a particular "period" of about 40 days - so multiple calls for time
            zone information within the same few years are likely to hit the cache. Note that
            a single "period" may include a daylight saving change (or conceivably more than one);
            a node therefore has to contain enough intervals to completely represent that period.
            
            If another call is made which maps to the same cache entry number but is for a different
            period, the existing hash entry is simply overridden.
            </remarks>
        </member>
        <member name="F:NodaTime.TimeZones.CachedDateTimeZone.HashArrayCache.PeriodShift">
            <summary>
            Defines the number of bits to shift an instant value to get the period. This
            converts a number of ticks to a number of 40.6 days periods.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.CachedDateTimeZone.HashArrayCache.#ctor(NodaTime.DateTimeZone)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.CachedDateTimeZone"/> class.
            </summary>
            <param name="timeZone">The time zone to cache.</param>
        </member>
        <member name="M:NodaTime.TimeZones.CachedDateTimeZone.HashArrayCache.GetZoneInterval(NodaTime.Instant)">
            <summary>
            Gets the zone offset period for the given instant. Null is returned if no period is
            defined by the time zone for the given instant.
            </summary>
            <param name="instant">The Instant to test.</param>
            <returns>The defined ZoneOffsetPeriod or <c>null</c>.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.CachedDateTimeZone.HashArrayCache.HashCacheNode.CreateNode(System.Int32,NodaTime.DateTimeZone)">
            <summary>
            Creates a hash table node with all the information for this period.
            We start off by finding the interval for the start of the period, and
            then repeatedly check whether that interval ends after the end of the
            period - at which point we're done. If not, find the next interval, create
            a new node referring to that interval and the previous interval, and keep going.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.CachedDateTimeZone.HashArrayCache.HashCacheNode.#ctor(NodaTime.TimeZones.ZoneInterval,System.Int32,NodaTime.TimeZones.CachedDateTimeZone.HashArrayCache.HashCacheNode)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.CachedDateTimeZone.HashArrayCache.HashCacheNode"/> class.
            </summary>
            <param name="interval">The zone interval.</param>
            <param name="period"></param>
            <param name="previous">The previous <see cref="T:NodaTime.TimeZones.CachedDateTimeZone.HashArrayCache.HashCacheNode"/> node.</param>
        </member>
        <member name="T:NodaTime.Fields.DurationFieldValue">
            <summary>
            A simple combination of a <see cref="T:NodaTime.Fields.DurationFieldType"/> and a 64-bit integer value.
            These are used when representing periods.
            </summary>
        </member>
        <member name="M:NodaTime.Fields.DurationFieldValue.#ctor(NodaTime.Fields.DurationFieldType,System.Int64)">
            <summary>
            Creates a new instance combining the specified type and value.
            </summary>
        </member>
        <member name="P:NodaTime.Fields.DurationFieldValue.FieldType">
            <summary>
            The <see cref="T:NodaTime.Fields.DurationFieldType"/> component of the value.
            </summary>
        </member>
        <member name="P:NodaTime.Fields.DurationFieldValue.Value">
            <summary>
            The 64-bit integer component of the value.
            </summary>
        </member>
        <member name="T:NodaTime.LocalInstant">
            <summary>
            Represents a local date and time without reference to a calendar system,
            as the number of ticks since the Unix epoch which would represent that time
            of the same date in UTC. This needs a better description, and possibly a better name
            at some point...
            </summary>
        </member>
        <member name="M:NodaTime.LocalInstant.#ctor(System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.LocalInstant"/> struct.
            </summary>
            <param name="ticks">The number of ticks from the Unix Epoch.</param>
        </member>
        <member name="M:NodaTime.LocalInstant.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Convenience constructor for test purposes.
            </summary>
        </member>
        <member name="M:NodaTime.LocalInstant.ToDateTimeUnspecified">
            <summary>
            Constructs a <see cref="T:System.DateTime"/> from this LocalInstant which has a <see cref="P:System.DateTime.Kind"/>
            of <see cref="F:System.DateTimeKind.Unspecified"/> and represents the same local date and time as this value.
            </summary>
            <remarks>
            <see cref="F:System.DateTimeKind.Unspecified"/> is slightly odd - it can be treated as UTC if you use <see cref="M:System.DateTime.ToLocalTime"/>
            or as system local time if you use <see cref="M:System.DateTime.ToUniversalTime"/>, but it's the only kind which allows
            you to construct a <see cref="T:System.DateTimeOffset"/> with an arbitrary offset, which makes it as close to
            the Noda Time non-system-specific "local" concept as exists in .NET.
            </remarks>
        </member>
        <member name="M:NodaTime.LocalInstant.FromDateTime(System.DateTime)">
            <summary>
            Converts a <see cref="T:System.DateTime"/> of any kind to a LocalDateTime in the ISO calendar. This does not perform
            any time zone conversions, so a DateTime with a <see cref="P:System.DateTime.Kind"/> of <see cref="F:System.DateTimeKind.Utc"/>
            will still have the same day/hour/minute etc - it won't be converted into the local system time.
            </summary>
        </member>
        <member name="M:NodaTime.LocalInstant.op_Addition(NodaTime.LocalInstant,NodaTime.Duration)">
            <summary>
            Returns an instant after adding the given duration
            </summary>
        </member>
        <member name="M:NodaTime.LocalInstant.Add(NodaTime.LocalInstant,NodaTime.Duration)">
            <summary>
            Adds a duration to a local instant. Friendly alternative to <c>operator-()</c>.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.LocalInstant"/> representing the sum of the given values.</returns>
        </member>
        <member name="M:NodaTime.LocalInstant.op_Subtraction(NodaTime.LocalInstant,NodaTime.LocalInstant)">
            <summary>
            Returns the difference between two instants as a duration.
            </summary>
        </member>
        <member name="M:NodaTime.LocalInstant.Minus(NodaTime.Offset)">
            <summary>
            Subtracts the given time zone offset from this local instant, to give an <see cref="T:NodaTime.Instant"/>.
            </summary>
            <remarks>
            This would normally be implemented as an operator, but as the corresponding "plus" operation
            on Instant cannot be written (as Instant is a public class and LocalInstant is an internal class)
            it makes sense to keep them both as methods for consistency.
            </remarks>
            <param name="offset">The offset between UTC and a time zone for this local instant</param>
            <returns>A new <see cref="T:NodaTime.Instant"/> representing the difference of the given values.</returns>
        </member>
        <member name="M:NodaTime.LocalInstant.op_Subtraction(NodaTime.LocalInstant,NodaTime.Duration)">
            <summary>
            Returns an instant after subtracting the given duration
            </summary>
        </member>
        <member name="M:NodaTime.LocalInstant.Subtract(NodaTime.LocalInstant,NodaTime.LocalInstant)">
            <summary>
            Subtracts one local instant from another. Friendly alternative to <c>operator-()</c>.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Duration"/> representing the difference of the given values.</returns>
        </member>
        <member name="M:NodaTime.LocalInstant.Subtract(NodaTime.LocalInstant,NodaTime.Duration)">
            <summary>
            Subtracts a duration from a local instant. Friendly alternative to <c>operator-()</c>.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.LocalInstant"/> representing the difference of the given values.</returns>
        </member>
        <member name="M:NodaTime.LocalInstant.op_Equality(NodaTime.LocalInstant,NodaTime.LocalInstant)">
            <summary>
            Implements the operator == (equality).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.LocalInstant.op_Inequality(NodaTime.LocalInstant,NodaTime.LocalInstant)">
            <summary>
            Implements the operator != (inequality).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are not equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.LocalInstant.op_LessThan(NodaTime.LocalInstant,NodaTime.LocalInstant)">
            <summary>
            Implements the operator &lt; (less than).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is less than the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.LocalInstant.op_LessThanOrEqual(NodaTime.LocalInstant,NodaTime.LocalInstant)">
            <summary>
            Implements the operator &lt;= (less than or equal).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is less than or equal to the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.LocalInstant.op_GreaterThan(NodaTime.LocalInstant,NodaTime.LocalInstant)">
            <summary>
            Implements the operator &gt; (greater than).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is greater than the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.LocalInstant.op_GreaterThanOrEqual(NodaTime.LocalInstant,NodaTime.LocalInstant)">
            <summary>
            Implements the operator &gt;= (greater than or equal).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is greater than or equal to the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.LocalInstant.CompareTo(NodaTime.LocalInstant)">
            <summary>
            Compares the current object with another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            A 32-bit signed integer that indicates the relative order of the objects being compared.
            The return value has the following meanings:
            <list type="table">
            <listheader>
            <term>Value</term>
            <description>Meaning</description>
            </listheader>
            <item>
            <term>&lt; 0</term>
            <description>This object is less than the <paramref name="other"/> parameter.</description>
            </item>
            <item>
            <term>0</term>
            <description>This object is equal to <paramref name="other"/>.</description>
            </item>
            <item>
            <term>&gt; 0</term>
            <description>This object is greater than <paramref name="other"/>.</description>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:NodaTime.LocalInstant.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
            <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance;
            otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NodaTime.LocalInstant.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data
            structures like a hash table. 
            </returns>
        </member>
        <member name="M:NodaTime.LocalInstant.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:NodaTime.LocalInstant.Equals(NodaTime.LocalInstant)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter;
            otherwise, false.
            </returns>
        </member>
        <member name="P:NodaTime.LocalInstant.Ticks">
            <summary>
            Ticks since the Unix epoch.
            </summary>
        </member>
    </members>
</doc>
